// ***************************************************************************
// *                                                                         *
// *           Aflow STEFANO CURTAROLO - Duke University 2003-2018           *
// *           Aflow COREY OSES - Duke University 2013-2018                  *
// *                                                                         *
// ***************************************************************************
// Written by Corey Oses
// corey.oses@duke.edu
// Previous versions also written by Eric Perim and Eric Gossett

#include "aflow.h"
#include "aflow_chull.h"
#include "aflow_compare_structure.h"

// DEFINITIONS
const string AFLOW_WEB = string("http://" + AFLOWLIB_MATERIALS_SERVER);
const string ENTRY_PAGE_URL_PREFIX = string(AFLOW_WEB + "/material.php?id=");
static const string AFLOW_HULL_ENDPOINT_STRING = "aflow_hull_endpoint";

// DEFAULTS
const int CHULL_PRECISION = 8;                          //must be less than _precision_ in aflow_xatom.cpp, which is currently set to 14
const int FULL_PRECISION = 15;                          //max printing precision
const int COEF_PRECISION = 4;
const double ZERO_TOL = pow(10,-CHULL_PRECISION);       //lower bound for absolute resolution of floats, significant differences among floats should be well above this threshold
const double ROUNDOFF_TOL = pow(10,-CHULL_PRECISION+2); //make less strigent so we don't get 1e-6
const double ZERO_COEF_TOL = pow(10,-COEF_PRECISION);
const double ENERGY_TOL = 0.015;                        //eV, CO NOTES - structures within this thresold may be equivalent, I've seen as large as 5meV, keep at 15 to be safe
const int ZERO_RANGE_TOL = 1;
const uint BINARY_ENTRIES_THRESHOLD = 200;

// USAGE FLAGS
const bool IGNORE_BAD_DATABASE = true;   //skip bad entries
const bool CORRECT_BAD_DATABASE = true;  //make minor corrections

// LATEX PRINTING MODES
const char ADDPLOT_MODE_HULL_POINTS = 'P';
const char ADDPLOT_MODE_OFF_HULL_POINTS = 'O';
const char ADDPLOT_MODE_HULL_FACETS = 'F';
const char ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS = 'D';
const char ADDPLOT_MODE_HEAT_MAPS = 'H';

// AFLOW LOGO
const std::string _AFLOW_LOGO_BASE64_ = "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IABnAGUAbgDoAHIAaQBjAEMepQB1ACAAaADsAG4AaAAgAFIARwBCACAAQwBoAHUAbgBnAFAAZQByAGYAaQBsACAAUgBHAEIAIABHAGUAbgDpAHIAaQBjAG8EFwQwBDMEMAQ7BEwEPQQ4BDkAIAQ/BEAEPgREBDAEOQQ7ACAAUgBHAEIAUAByAG8AZgBpAGwAIABnAOkAbgDpAHIAaQBxAHUAZQAgAFIAVgBCAMEAbAB0AGEAbADhAG4AbwBzACAAUgBHAEIAIABwAHIAbwBmAGkAbJAadSgAIABSAEcAQgAggnJfaWPPj/AARwBlAG4AZQByAGkAcwBrACAAUgBHAEIALQBwAHIAbwBmAGkAbABPAGIAZQBjAG4A/QAgAFIARwBCACAAcAByAG8AZgBpAGwF5AXoBdUF5AXZBdwAIABSAEcAQgAgBdsF3AXcBdkAUAByAG8AZgBpAGwAbwAgAFIARwBCACAAZwBlAG4AZQByAGkAYwBvAFAAcgBvAGYAaQBsACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjAEEAbABsAGcAZQBtAGUAaQBuAGUAcwAgAFIARwBCAC0AUAByAG8AZgBpAGzHfLwYACAAUgBHAEIAINUEuFzTDMd8Zm6QGgAgAFIARwBCACBjz4/wZYdO9k4AgiwAIABSAEcAQgAgMNcw7TDVMKEwpDDrA5MDtQO9A7kDugPMACADwAPBA78DxgOvA7sAIABSAEcAQgBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6QByAGkAYwBvAEEAbABnAGUAbQBlAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGUAbA5CDhsOIw5EDh8OJQ5MACAAUgBHAEIAIA4XDjEOSA4nDkQOGwBHAGUAbgBlAGwAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGkAWQBsAGUAaQBuAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGkAbABpAEcAZQBuAGUAcgBpAQ0AawBpACAAUgBHAEIAIABwAHIAbwBmAGkAbABVAG4AaQB3AGUAcgBzAGEAbABuAHkAIABwAHIAbwBmAGkAbAAgAFIARwBCBB4EMQRJBDgEOQAgBD8EQAQ+BEQEOAQ7BEwAIABSAEcAQgZFBkQGQQAgBioGOQYxBkoGQQAgAFIARwBCACAGJwZEBjkGJwZFAEcAZQBuAGUAcgBpAGMAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGV0ZXh0AAAAAENvcHlyaWdodCAyMDA3IEFwcGxlIEluYy4sIGFsbCByaWdodHMgcmVzZXJ2ZWQuAFhZWiAAAAAAAADzUgABAAAAARbPWFlaIAAAAAAAAHRNAAA97gAAA9BYWVogAAAAAAAAWnUAAKxzAAAXNFhZWiAAAAAAAAAoGgAAFZ8AALg2Y3VydgAAAAAAAAABAc0AAHNmMzIAAAAAAAEMQgAABd7///MmAAAHkgAA/ZH///ui///9owAAA9wAAMBs/8AAEQgCEwSWAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwUDAwMFBgUFBQUGCAYGBgYGCAoICAgICAgKCgoKCgoKCgwMDAwMDA4ODg4ODw8PDw8PDw8PD//bAEMBAgICBAQEBwQEBxALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/dAAQASv/aAAwDAQACEQMRAD8A/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAZyDTgc0EZpvSgrcfRQOaKCQoooo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UhgWNlCqDKPvDKAbckEetfDLwRP8PPB/hbwJ4n1q81u5sLK3tF1OW4uI/tMkEYVtyeawjZmAKLk/LhSSyktq4xUVJPXsLW53Pw28B6T8MPCll4H0Waa4tLIO6SXDBpGMjl3ztCqPmbgAAc+uSdLxh478F/D7TYtY8c63Z6DYzSrAk17MkEbSsCQoZyBnAJPoASeATWhc6XYwRi5dWmEB3ETSPKNv8XDs3Qc/UCvL/jT8Bvhb8cPDNr4c+JGkG+0+wuo7pBDNLaOrD5Hy8DI2xkZgyk4xz1AIlNOV5g9tD2tWV1DKQQRkEdCKWobe3gtLeK1toxFDCqoiKMKqqMAAegFTVkMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//1f38ooooAKKKKACiiigAooooAKKKKACmE0pNNoKSCiiigoKKKKACiiigAooooAK8N/aD+G2sfFnwEvgzQvEsvha7nu4pRcxRNNvRAwaNo1kiLDDb8BxyoPOK6P4h6T4u8U2NrZ+CNUOlvaXIknmDvGJVVWBiVkBY4JBP8ORtJzkDpIHuDe2AmH2hjE829SNzbAsanBwAG8xmx2PHatYNxalF6iavoZXhnwlP4S8PafoOn3pxaQRQyXMsSGWeVECGaQJt+eQrliS3Xp3G+E1vT8+VDb3gbq+54X4/vDExbHrn2ArWa5j2lJonGeCNhcYP+7uFVrTULV5zYrcJLIAWTDhiVHXPfK9/Xg+uIu+oykusamAQ2jzTsDgtbywPH9AZXibPqCgr5z0H9obw/wDEn466x8CbfSb+zl8JQjUb2WWIlZWhaIRxMqZaMb5VkUnIkCcfKTn6K1fV9KtZzZLdwx6oyZjjMirIF5O9lzny1ALMSMYB70miwz6fYpJPCXaf95I4H73LktiRe5GcHHfPyiri0k7oTNCbVNPCMs04tmI484GLnsQH25x7VTfXtHmWGWG+gZwQ2wSoWweG4BzwDn8K24pop03wuHXpx2PofQ+1eH/E747fCT4VvJoHjnVUm1O/5tdGtInv9SvBIM7YrOBXlbLZ5KhRkZYCpir6JAeq+JfEnhXwppjav4x1Sy0jTkYKbi/njt4Qx6DfKVXJ5wM15jr/AMQ9H120t9M+HGuR351GITS32nzR3kdvaMxjVomBdGnndWit1BALB3IZYmU/h1+3f8UvF2o+J/DeueKPBF14F8OnT5I9Ps7+S2F5M6SkS3d1bQMxtWlDIipKcnYSCeQOw/4JwfBTx/8AGKz8XeL7rxd4o8DeC0uLc6e2iXMdnHf3wDrO6GaGYMsSBFZkC5YgbiUwvpTwdKFGNTnvJ7rsYKcnNq2h+vXwp0vxtof2/T/G8Ih0uIrtRFXy4pP7m5fmaFU/ickH7zHJNe+XFrb6jYNbK+IpkGx4yPl7o6HplTgqfUA18rW/7LWmR6m1tqHxP+IV7viV1L+KLuEuVYh8/ZvJ6ZXpjrW7B+yh8M7NA1ve+IrqZSWb7b4o1yeOUnrvT7aBn3AHPJB6Vwz5W73NkrI9+tDa+I9Glsdatorjdvtry3kQPEzr8rqUbOUb7y7hypB71wk+h+LvBs0t14InGr6XEil9I1CYh0UbiRZ3j7mTHJEU+9DwqvAgzXjuofDX4C+B/Edgni3Qrazh1gNBt1O4lu42uIhuWSOS4dw6smVfd8wxHlVBzVK+8I/CvxVr974b8E+FdD07SdMaNtS1SPTbUJEjIrKsZ8vDySA5jXkEESyAxeXHdJRJPJtJ/wCCh/wH1X4nHRteGo6HpN1HFbQXlzDHJC93C0rbZFt5JXwWYLGVDhm54G0n23xN8Z3+I2iXFp4D+H/ibX9LKiX7fNZrolqyL8zOr6q1vKybc4aOCUsei45PzJ4D/YB+Bsf7SmreJwdYGl6Ba2Wr2GjzXZWG3udQlu0Rg8apcJ5P2fzIkMpdCyMzZG0fcmoan8QPhqrSanbXHjnwqo+aa2iD61Zp38y3QBb6MD+KELOAAPKnYl66K8qXMnSTW27Iinb3jjPCXgv416Tor6SP7B8M6bcSNLPEiz6/eNvABIkcafCjAAfL5MoGMDf1rtLT4RWt3brNe+MNd1Q5yoN4tta4HWM2tklvAUzwVZCexaus+GfjLw3458I22r+FtTh1ayheS08+F9/zW7bMSDqkm0AujAMpOCAeK6u6052la80+X7NdHqcbo5MdpEyM/UEMPXGQeWU3fUs8E+Kng7RtP+D/AIx0PV/B+k6roMum3U1xDawRwK7QxGRHe2k+UmNlDBhKXBAKjIFeJfBHW/DOleZoXwB8IQeG7azV5YdOWRVh1C1jC71lGAFutxLxys5BYlJH2ncPYfjH43TUfCc2gTsum21zqek6ZdzO/wC7uFvdSt7SeO2l4DLGkjGZuCoBUqDuK+k6R4T+HHh62bXtHgtNGm1QmVbq3ZI2JclwIzypHPKAbW7qa0jJJe8hM6fwnrei+K9Kh8Q6VO10GZ4281SktvNGSksLxEAxSRsCjoQGBGGzXV18t+LLrxX4T8Rnx54J0qS51O52pqNjj7Laa/FEuFMPnEGHUokAEJYbZkHks7KEeD23wT4s0n4ieG7PxZ4e1NbrTb0NtESGJ0dGKyQzLJ+8SWJwUdCEdGBVgCMDKUeozEj8SaL4t+Icfh/Sb6K7Xw9ay3F7GrA7JrhxDBj+98qXCtjIAODywx31xZWurR3VtexiW3kAiKnoQvJIIwQQx6jkEZByK8I+G3g3wxouveLfiBbQtNBe6hcafCZSHMUFgRA6KMDj7ZHPjOTgr6mverXTbWG3RHgj34yxCjBY8senc052T0BHJwa/J4ZuxoPiuctG6u1jfOOLlI1LtDJgYFwiKWxj96gLpyJFTivBPxg8LePPDWrHTmks/sELhRdFEZ4mD+Wwwzc4X5h1B+td5quhaN4506fSr62WTRpsAsuUeZ0IZXidMMgRgGSRSGLAMpAALebeD7ay8EaxcfC7WbSCxl1uKX7BqEEKQRamI1JYMsYVUu44yTJEoCMqmWIBTJHC42s77geuax4u8M6DZHUdW1KGC3DBd27ect0AC5J/AVrQaha3UMdxbs0kUqhkZUYqysMgg45BFYUun6X408P2kWt2y3EFxHDOyEkYdlDDBUgjr69PrWsLPStLtUVNtlbQqqgK/lIoHAHBA9qhpAQ63rlvoei3+tzQzTR6fby3DRxRsZHESlyqg4yxxge9Y3gHxna+PvDNv4ls7aS1jnLLskIJBQ4OGHBHv+FbiX8Lc2tw1yD3WMyJn03IAoP1P1rx/wCPHjf4n/D74Y6t4r+FnhUeJdetPKEVkwMhYM4DOsMTq0m1c/IrhjxjOMG4RTfL3E2e70V5H8D/AB94m+JHw50zxN4z0E+G9dkRUvbEsSIrgIpkUbgGADMVwc4I6kcn1ys2rOwwooopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9b9/KKKKACiiigAooooAKKKKACiikNA0NNJRRQWFFFFABRRRQAUUUhIUZJwBQApIAyeAKz2D3/yglLbuRw0n0PUL79T2wME2DGZzmUYjHRfX3b+g/P0HL+IvHfhzwyZYLydri9iTzDaWqGe4C9mZEz5anoHkKpnqwppdgOkmRNsdjEoVXGCAMARrjIA/JeOmcjpXH+E/EugeJtZ1uTQNTtdRTT2gs5BbTJLsZQ8mTsJ2j94UGe6NXJWzeMviVpst5Bex+GtE1FWjxbhLrU3iG5CrSMDb27ZzkBZyM8OpHHl/wAEP2bPD3wsutZ1lNUutZl1aZrRHutqG1htZZEjCmHYd7H7z5GcgALznVKPK7vUGfXNc/4gn00aZcyXaif7IrTbFQSurRgkHb+nOAQcE4NZM3gLRrhGWa81Rt3/AFFL0Af8BE20/iDVQ+Db6xtmS28XataW0aklcWUwVQOfmmtZGx9SazSXcD5m0fSvD/iv4h3XjC3ml0u6+0Q/btNVVk8m3SHY06yKQREVAV1KDBbqQQD7RrPxUtYp5tO8BPf+NdXgYxvbWFtHPbQuM5W4uv8AR4IWB6q03mY6Rt0r8+NG/Zu+MN5+0Dpb6vpUX9maNeRajqt68sLxX1hI75iMIYvIbkRvGY2TA53YGM/qd4WNpp8H/CNWqpHDp8aG1CAKrWb58oqBx8uCh7/LuP3hXZieRNKL5kkRC/VHzxq3g/49fEApL4w8Qw+E9PcYk0/ww1zbXjr2WbVJbeWTHqIIoSD0kPWvJ/GHjfwF+x7YWUfg/wCGon8TeJXmt7RYJAbvVLjAbdPd3G66lCEBpJHyFXJOCQD9dfGD4ueEPgl4FvfHnjOdltrbEcFvEN1xeXMnEVvAnV5JDwB2GWOFBI8L+Cvwt8Ua54iX47/Hi0jl8eeIlIs9MceZB4d0hQWjs4Qwx5xZka4kxlnwBgA5zhLS8timeW+CfE6+Ddc1nTPFlude8ceL1tG8QazcxGNYJJlDJbWdpKjMbS1jdRCjFd5Bdss5Ne1fstatJpXg3xB8K4rKRpfhv4g1PREUtGpFl5v2vTywLZA+x3EK5AIJU4zzXsXiP4YeGtY1QeJrWxgi1yFR5NwyZAdOY2IHdW5BII65Br5Q+HnjFdA/ba8TaBdQtYx/FDwzZ6k0MnRNZ8PyPY3MKHoxNuVfcPvKgPHShyUo6LX+v0JtqfXur3HimLWdMktrayi+0Ga1VnmkkwXTzslBGmcCEj7/AHrYWw8VTfJc6xBEvrbWZR/zllmX/wAdqPxYwt7G01HO1rO9tHDdAFklWGQn28uRs15J8YfjDd+GtQg+Gvw88i88d6tAbgGfLWmj2AO19Sv9pBEan5YYgQ9xLiNMDeyYpN2sUzxj9onwddeO/E+n+D/CmvTah4m0+3ebUJLuGCW10vT5vuSSiFIh9omddttCQzSkEnEaFq6v4GfCO/8AhpNYy3RYaGsXmebLKJvtNzLgrcyDccOxJJdhkFsDAPHr3wm+Gtp4M0VTK09zc3MzXk9xekNe3t5KAJL28YYBmcABEACQxhY0ChQB+cv7Yn7Wfjj4c3Ok/Bf4fX39jTW9k51C+CI8zpFcTWkcUfmBggIgLswGTuABGDn0MFQnXksPTtr3OerNQXOz79+C2o/8JJ40+LninO6I+JhpNufSHSbC1gcZ9ro3H519BV/PJ+yL+3zqXwW8Raj8OPiHZaj4t8P61Nd6hanS7VbvVU1K5lM0+RuQzJMzOzFiWVsY+Xiv0cuv2/tMiWAw/BH4lr9rbZAbrQ4bRZ2/uxGW6Bc+ygmsMTg5wqOHYuE1JXR6Z8SPhz4fsPiNc+LPCPi1Phv4z1i2imivkeM2uoSwHyni1GykZYrpCpjCN8sy4by5V5B4u3/ac1C18RW3wq+O1vB8P76a5ayk8Q2szyaDqUqKp+z2N8yj7NcSA/NFcFXiHCM7kMPlTx94g+P3jDx3f+OpPgl4lttP1ZoltVvZbON4o0RY0R0WZjGSwJCkDJPck1794csP2k/H3w4i8EXvw38Kv4aKy209jrt8zh2WRt63KW0U3zI+eNo5GTk4xXslyKTeoJu9j2f4+6bpviSH4XfDXTdttYa74nt44zGBtEWm2F5qAKJwCim2XnOORjOcj3PwH4K0fwbo0djYoss6mQSXBRQ7kucjI5Cg9Bn9a/lf+OI8feAPi9qvwhhaSfXPDV6lnpVjpFzd6otoJiJra1sZpGM+E8wKi7Q4bgqGBr7X8F/FTxBcy23g79sb4sfEP4Y+IHxGYb+0l03SZyQCdl1prwSMCSSzSYXHJc81tXwkVGKhO+l3oTCTbd0fvH4m1DwtYaROfGF1aWmmSKVla9kSKEjryZCF96/KL9oL48W/7MfiKL4l/AbxPYeI9L8ZySW+pwNu1DT/ALVFGDFcvNBIqm6Crs3iTfJGv75XMauPob4d/st+CLqztvGfw78Z6RrSzDMOsRaTY6pO46/LfyvNM3/f010Pxo/Z71rxl8OtYsPiJ44HiHSreF7hbO/0+AQNPEp8rB3HY5Y7VZRuGeOuDzYecITTeq7FSTasjwP9lT9rLxv8XfhnZeG9D8A2urXmnXUtlc3J1qCxW+lj23Ek6wyq0uZTJmQqGUuX2nghfq7SvGP7QPjFGsI/A+gwWVo22ZrjxLOjXichSrQ6VKDGSCHI4cggHbnP5h6Lo6fCVxDpGkPpml2mRqVjHEY2sPKGTeBMAqqAZuM9EHm8FW3/AKu/8LZsdMsrDU/E2jXfhyS1jXEpjFxp9xbuBuWK6t98WCAHTds5AHAJrXEU4pKcba/gKDezOvtb341TKq3Oh+HtPA4xHql3dgD2zYW/9K8j/aQ8P/FbX/gzr9ppN7pY8QRpFPpSQW80c4v4pUMH2e5aceVOz4jicJ99hyoJI+m7HW9J1XTYtX0i7iv7O4AaKW3dZEk3dNrKcHP1rzfw9cN488XXOv5Emh+Gp5bW0YfcutSTdFczKe8drl7ePpmQzkr8sbVxwnZ81ti2j4t/YP0j9oTRfCniK5/aJGrWGg3c9s2gxXt6800ICv8AaZJHikd44XzH5YkYICrthdwLfo3Zabo8fl3tlBEzMNyzgB3YMPveYcs2R3JOazNFf7Dqmo6A/Co32u394blmLD3Kyh+OylBV99Ghika40xzYzOSzeWMxOx5JeM/KST95hhz03CnWqucnN7sUY2VkbFVZI1u1eN/9WMr/AMC7kfTt7/hWXNqN3bFbW+i2NJn9/Flowo6sw+8nryCo4yx5rah8oxIYCDHgbSDkEdsGshnI2EdxLbwavYY+3eTF58ZOFnAXofRu6MexweDXUWd5DewCeHIGSGVhhlYdVYdiO9cxaXUOmxpqNxIsNr59zbyM5CpGFmcRkk4AHyhPxUVuTQEuNT00hndQWUEbJk7c9NwH3W/A8dGwNWiobe4juYhLF0PBB4II6gjsRU1SAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/9f9/KKKKACiiigAooooAKKKKACmGn0w0FREooooKCiiigAooooA4Xxl8S/A/wAPpLBPGWrRaX/aL+XC0uQpPAyxAwq5IyTgDqeASONs7OS68eXfjfRby41WK7jEUNsgxbIEjCZM7MECFvnKKGfnfg5wOT/aC+DHhz43WdgmsX13p0fhxpHe4s2QM0Upj+0R4kVlJCIGDYyrADnJFewWGh3fg7SbHSvD7fadM02GKCG3uG+dIolCKEm5Jwo4Dg5PG5a291JW36iJJdH8Rav/AMh3UDaWx/5d9NZozj/buDiUnoQYxH3BBFaFl4a8O2Omy6VY2cUdq+S8SrtBZhyxUY+c45bG73q7Y61ZXsxszutrxQWa3mGyUAcEgch1B43IWXPetKWNHA3DOCMeo57Vm2xlTT9MstKtFsdNjEEMeSqjJGWJJznJOSeec1ieHd1x4atp5fla+VrrcBkK1yxmHHbaW+nHWtq/mbT7Oe/3ZS2jaRlbn5UGSAevOO+azvDqvp3h3S7O6Qq1vawRlgNy5WMA9OnTnIApXA27adbmBJ1/jGSAc4PcZ9jxWb4gcjSJ4hwbnZbg+huHEQP4Fs1kXGv+HdM1T+zLjUY7a4u8SxAMOd5KnI5XllPJ7nA6V5z8R/HWvaBqtrYQ2Mdza2rw3E3LK8+1twEfJAwQOu7LDtVRg29BXOr0u+DfGLxLppPMeg6HKB/v3WqKf/QRWV8T/Euk/DDSJPiJrVytppmjb5pnY4/dyEedABnky4DxDvMqrn5wK4//AISbStC/aJ8aajrd3HY6fp3g3R57iaZgkcccV7qLszE8AAPXygT4j/by17UtRtw+lfCjwrK66ekwKf2tfoOHl7hQDz12KQoG5nI3hSu7vZFHX/AvQtd/ak+IUP7TvxSiEHh3QpXj8GeHncOLUZ51G6QZHnvgGPPThh8qxsfvdn8zxBFGv/LvauX/AO2zrs/9FtXz/wDAbwZqvhbUdR/tJUsyttCi26kZkjc7o5sL8u3ClRjodw4xz7xYOZ/EWrTD7sKW1sf95A8p/SVaWIa5vdehKOhr8tP270h+FHxb+Cn7QSHFjpviE2epIjFZFt76FYbqZAvzkmCMDI+6yJjBbNfo/wCKPH3gXwPb/a/GniLTtAhA3b9Qu4bVceuZWUV+Av7dnx/0n42/F+w0/wAC63b6p4V8LwLDbSwPvt7m4uQrzygjOSvCD02nHU105XhZVaqitjOtPljc/TD43ftP6No3hUeD/hNqmn/EjxH4uhlt9LgtrlZHsflG66v2hDKsEG4NltkhYBAGJZ15n4M+Ivhf8GfC+sePfjx4stbLWJrtbvUtR1GVRNq2oFSRKqffkEC/JbW0SFYE5UFmLV+HWqeMdU8F2z+JPDmoy6Vq9mjhJ4G2uNwxgY6qwOCuCCMgg8iv1v8A2Zv2APhvP4c8M/H/AONt1dfFDXvEFhaaq1vqIdrW1ju4lnQeQWY3DRhsMshKMPuxggBvQzTA0sP+7Ur/AKmFCs6iu0ezaf8AtefFf9oK6k0v9kL4eyXmkBzG/jDxSJLHRo8HBaCBP39yR6KVZT95Mc18+/Ff/gn9rnxjuPEOs+MPi3JL8SdJlhaXULm0hg0l7K5iEohS1hKvAqTvLtfzHJ6spJyP2BtW0nTtJiey8m20y3hUx+XtSBIVX5duMKEC9McYr4U+HPw0+IXhP4gQeKfF8LQ2UF089xqkjBhMkm752XJkUPn5t6jZnLbcV5NGer5Xym0j8/8AwR+yz4q/YZ1zSv2hvF2qw+KNCuHfQtevH011TSbHVGjiW/toJJfMkEbjy5WlRfllwkbjJP6hweKPD3wm10j7PJ4tM8MUsetTTia8+zTLuSMSMCrIBgr5ZRSpHBIJP0b440Lwv4s8Gaz4b8YwJd6DrFpLa3cTciSGdSjKMc7jn5dvOcbecV+Xv7JOuHwJ8Sta/Yu+N2ZvEnhFPO8G6jd8m80fBmghIB2PJAp3BcsAoeMYEPJF86bluO3Y/VGy0ydp11LWXWe8GdiLnyYAeMRg8k44LkZPOAqnaPlb9qX4vXn7NHhq7+IXh22TUb/xWw0qy0wsAZtcljK2c6qSNy4XE4BGUVSDkc/WWmX66hZLcuvlSKWSVCf9XIh2upPsRwe4wehr4p8A+GbP9qD4s6h8e/FluL3wD4bjvND8F2kozFdeZmHUdY29/PIMFu3/ADyUvgFlNYU97y2KaLPwn/ZMm8B/s5a34IvtRFx8SPF5Ot6rrrHfI3iMOLq2nD4yyWtyqFOxKs2AXavY/hn4r8N/HnwFpmu+ItHtrm38Racq3+mXkSTxQX1hM8F9bSRyBlJhnJjORztzWj8NdcvvD+sXfwh8UTtLf6Qgl0y5kPN7ppOEOe8kX3H9cZ55NfF+oeMPFPwF/a08S/DvQFRtH8eq3ijSIGTer384ij1a0UjndI8UdztGCN7N/Fzok5N99xHs+t/sNfB/StTuPGHwe1LVvg9rhBkkuvDV61raPt5Anspd9s8Q7oEQVwHhrVP2tDPZ+INasdO+NHgvRbqT7HNaGPw9q188WAt41rMXs51jIYRKJYNzfPjIXHrOsap4++OHiW6+HGnXdrpPhnTSv9uXVmHneRv+fKOZiikkjEhCdiM44b6IsfA+nWtrDZ3V3d3kNuixpG0xhhVFGAohtxFHtA4AKmk6jS97UD5q8V/tLfCzVNMiTW5Lnwd4p0eeK9XRfEtq2mXlxGmUuIoPO/c3W+3eVR9nklBzWL4V8aQ/s6eNdO+G2oie5+FPjOcR+E7+RGjTSb6fL/2NK82wfZpBlrF8/KMwchUr6z1rwj4DuvDt/pHiDSNOfQ542+1w3MEX2ZowPmMgcbcAcknp1r8Z/jVPpM/7M3iDwd8HF1XXrXw/feTrSWTvf6E2kWc4eO6t0n8yJSp8o7rDbtAZ5MLnOlCEZtR2TFJ2Vz6a8UaT42HxRs/AfgFG0LXvFkl5Is1mXtIrHTY2zcX4eIbX8sOscBdXVpZI1K7c4+y/Cvhr4geA9DsPDOgppl7o+lwR21tBNJJDOkUShVBmih2OQB3iUk8luc1+Df8AwT7+I3xG1L4y+JJvh/o2p+JdGg0df7R/s1rE3Vs6z5tXiOozQowDNKHjV8srN8pOK/a2w+O3gVLGWb4gXuv+FZLMYuotZ064sIIpAAdovYbdIHJyCoSclgRxyBWmNpKM3CDul+JNOV1dnL/Ff41eJvB/jTQ9Ot9EittSht5JpTcybke2nYoY18piDl4g2cggqOOSK9w0Lx/qGuaFZ67DpM4huY1djsiRFJ6gPPPFuGeAQOetcjY+DPhj8W7GLxt4g+z65axgm1xfvcxW0I+YiSRJWVnb7zgsVXhRnBZm+A/iH8Lbi11LSPBmsaTqf9jSpb2kthLDP8k+RDF+6JJeIgoVGWKKr87xWDS5NI6ofUreC9Q+K/8Awlmrajq32S50ycOkUUt4u7csnyeUlvFMwVV3AgnnOcnrXqXm6vGxnMiWbOcsI7VyrMevLyKGJ9dgY9K3LZ7+eGOGyiNnbIoUSTjMrKBwVj7ZHdyCD1StKCyihbzSTLL0MjnLe+OwHsoA9qylK72KR+ftp458V/Ga9+KPw98a+G9Z8G6P4U1GOe11W5tma2uWiJG0xeXGZA4jEw8pnUCRSx+6X+rvhhqOhWHgbSbTR9aivrWGNlDXKtbMzh23hQ+GCq+VAKnGMZ9O6Swtbq81rSb+ITQXvlTOp6FJIxDtPvmEnPuKoeG9JtfDv2nRNEjENtAVmSDJKgTZDYZskMZEdjnIOe2cjSdVNWSt5EpG80m1/taIY3YDcDgpIOx3DIB9CcZ6HtjSilSZBJGcqaow2unSFmigWKUfe2rscE+64PPqDg+4r42b9kSRfix4z+Idr8QtWRvFTwzixYBreFQ5ZlfDq0wUgCHJXy14+brUQjF3u7Ddz7borM0nzIbNLG4dpJ7RVid2OWfaMBz/AL45Pvkdq06yYwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9D9/KKKKACiiigAooooAKKKKACoz1qQ0w9aCoiUUUUFBRRRQAVk3t6WmGmWEi/bHGWxgmGPu7D9FB6n1AOLV9exafbNcSgtyFVF5Z3Y4VVBxyTwM8epAya858M/D6z8I+IdY8ZTX7vda0WkuA5HkxM5DMAxAJQEYXOMD61UUuoHW6tp7P4f1TTNPXLNaSwxjuZHRv1JYZPc1s2lzbarp8N5D89veRLIue6SLkfoaqadfR3Fqb6NlnhmZ2EsTB1ZQSoIx2wBjGawvAN7DN4O0mFWzJZ26WsoAJKyWw8lwQOnzIetHQDfnsrXULRIdQiE6KQefvRyLxuVhypBzhlII6g9xAlvqenkLBKb62B+5KR5yj0WTo+Owfknkua0YXYSSxBCMHcucAYbv3PJzUU0dyZUMR2qvUA8A+p9qQGR4iure58OapBv8uSS1mTY/wArAuhUcH3PUcHsa6ONkIGwgqRlSOhB9K8m+IOtA2heygkvYIco8kMbSIshPTcoI+voeK5n4daV42uvCUt9Lq8mhWU0zz2y+RHJMLcqp3Zm3KisdzAFO+7vVWVtwN3xX8OE8Q+LJdctLpoyIohcwhQTJtJAEbkgK+wfxDH3egJNVPG3xH8AeHtA1zxVruo2Md3YwzfYoLmaKG5aS0RiscaSEOJWm3KABk/LxWLrHwo03VPDs+s+Jtf17Vjdr5otX1B7aGSSXCwo8dqIRnlFOO/TArPb9lT4O6XaQXOjeE7C8v7dfnW/D3Md1xhg5mMhRieVdfunqCOK1jKOikwsj8iPi38Qtb+IA1fXfE2qSTXWrRJDdIjGKJ4oWMkURRcAxxsdyKc4J3dSTX398CfiR8VPFH7OnhC0+HXgfQ9H0q8iOkQXNzqU0SPJHNJbTSR2sVtI+SySSMzyg8MfmPXxHxV+wDoPia9u9Q8N/EC60LSUn8m6028sUnutOeQHyxJN56Bo95UB9hyh3bmAJr6H/Zm8f6Iur+HP2etTsbbw5rnw6s7rFtBOJbXUmAEUd5ZSEkyiRJJ5JASXVic98ejjcXGqlyQskRTg1uz0rxd4P/aW1LTH8QS+OdF8N6jpkUpgTSNIecuHAzC0t7O64YheTEQGAbHFfOnhr9n3xF8YJdUh8W/FHxveXDTLJcxx6nFp2n7WXywZLe2iDPIPLKlBsC7cFhX6Ta7Otto93Kyhz5ZVFYZDO/youP8AaYgfjXD6lo1t4Lu38R6QTaWVwUGoEDeFKjaly4PVV4EvQhPnBXa27gjXdrLf0RR8y+Hf+Ccn7J+kN9r1nwrL4k1Bjue51K/u5Szd/kEqpj6qT7mvgf8A4KC/sxfDjwv4o+Hej/ALTbfQ/F/iWdNMh0GzjWOK9EkhCXJ5AQxkuJZGyCNmSMZr9q9T8a6d4WsbjUPG0kek2VrE8z3zNmyMcalmYyH/AFZwM7Xx6KW61+aX7I0t/wDtW/tMeNP2wvEFu6eG/DW7w/4RglBxGu397MAej+U+W6jdOwB+QVdGpPWbb0Jkk9D8uvF/7Hnxo+HmqeEtT/aZ0pdC8C6nrVtp13JY30E8778yBN8bMkQlCMgkfhSckcV/T54b1zwaPDdo/h68tYtIsrONo1R1VYLVEAXcpOUVFGCGxjGD0rwX9qbwP4f+LHg6f4WeJZ4YLTVtM1O4ieZwgS9hjSKzcZ6us04ZQOSVIwa/Mj9jbWvFGv65L8KvF2kXE3jTwDdrHq1rLHulktLaUZkkWTG7IG07vvkqeS4rdr28VKb1RD93RI/XKC6uXu18VzwyReDDL50VswIZJCci+dCMiEn5hGfuH98RnhPZzPB9nNw7r5JXcWJG3bjOc9MY71zkHi/wzfWUd1bXqXCXG5FjRWeZmXh0MIBk3L0ZSuV/iAr5h1Tw18QbjxzY+HII7238L3N5HmzeQi1Nh5gkljJViv3N3ybsgfKBt4rhjT5r9LFvQ9EiTXrW5Txh4YspNS8IW0heDSVP74joby0VsDaOfLt2IBHzptJVa/NT/go54o+HHiLXvhl46+G2uSWXxM8Pzfa7e8tEG6CxR2KpcBiGSRbhTsRlOB5oYYYZ/alEVFWONQqqAAAMAAdABX8x3/BR/XNL0b9rjxBPoOr210L2DT/tItJEf7NMsPkyQzhchZg0e8g/MA4zya9DKZUvbJ1l7qM6/Mo+7ufQl1/wUL8T+M5X+HfxTtrTwr4d8Zy2thrGtaT5yS2lozBLl0jd5CGmgzC0qvmNcOisygH93dB0rRtD0PT9F8O28VppVhbxQWkMAAijgjULGqAcbQoAGO1fxZ+MtWXU7e00uwlNxd6hIsMSbhlnc4AyxAHOOSQPWv24+D/w3/bOf+xfAelfHy606a1gSBRJZW15bRw2yYPltNGXfCqNoIGe54JrbNsPSVVqjpEzoSk4+8fdH7VXi3TtAi8PXGhytD4xsLwSWVxGARBHgGZZc8MHUj5OeoLfKcN+fP7XXxW8Yaz4E8J+O9MtrbTPFPgLVxe6fdWkskM8sN1G0V7b/vHdmadSGYhtxCngk19JeM/2Pf2ltZ0O1mvvjb/wk9/pLyywW02g2Fn5jXBUzE3EeGZ22LzIO2NwFfmp+1l4D+NHw+isNT8cWV1qGlaeDbXM0UUYWzmlQyL5n2dnVRKgyr5AO0jORUZbCg52qy0HWckvdP2z8C/Gr9mr4Z/BDRvF8XjTTNN8NXEIkNxc3Ea3E1yyK8qPCpaRrlcgPCql04XGAK47Tf2k/i18cCI/2Zfh9ImhS/d8WeLlk07S2XtJaWS/6XdqR0P7pcjDEda/EX9jnw94RtfiTZ+NfjhZ3nhHRPEKrB4W8Q6xpa3OkvqCPuZTJdr5QJXHlyHgEH5lxX9BU+i/tLaMgk0fxJo3iOJRwLu1+yuw7YEIC/8Aj4rkrU4Rk+V39TSLbWpS0z9nvTrjHij4/wDie6+Jeo2n+kGPUVW20K1MfzboNJi/0f5MZEk/nSjGQ4r57+Mmt674N8dpo+lSjRpvjzb2+kQybhCdOihYJPcAnAV7fTjJIPSZ1Xpin+Jv2gP2goPFcXg3xZ8PILzT0u0SaPTmkMs/lncBlWn/AHbEBiNmSoxnBr431z4pa3+0b+0H4h8d6zG9povgpW0HSbFmLpBcHa+oOMhcyFlRGbAJAxwABShTlze8HMfoH8ZdL8OfCHxV8P8A9pTwKtvb6B4XCeGPEa2ZUw/8I5qEipHKdmRiwuvLm458tpCele3JDqfivUrf4oG0caVYYaysGUiS7gXP+lyIf+Wi7i1shHCk5wzjZ8FaDp2lXsieG9eha98P6zJHbajY+Y6RXUDsAyOqkbsZyM96+8P2e9S1i18IXPw08VXDXXiD4eXJ0S4nk+/d2sSK9heH1NxaNEzkceaJFzlTV4vCypJXJp1FLYu/FX4ffDX4g/DnxLdazFaWkOqaRdK2sxW8b3NvC8LZnSTbvOwHdjPOMd6/NH4Hfsv/ABt/ZP8AEVx8Zt0Pj7yre3/tbTbBDa31na7WeVYUkdo7qRY3LPEHQhhGYzIcqfuH4teLrLwX430P4fOJLrQtYlOu39tbhWlt4bKQMIgGZQI7q7MbbScFI7hcENge8+DvE3hy80KDUBqls0+o5uZgZVDCSU5KEMQ3yDCDIzhRWMa04w5b6PoVyq9y74D+IXgz4neHofFPgXVYtV06YlS8eVeKQAFoponCyRSLn5o5FVl7gV2dfEE2n/DrwX4+1XTIfEcfhDXYwl1pOr2jKwmspmY/Yb+HmO4hhk3CNZvnSNv3MkTfNX0Z4f8AiBdwPa6V49ggsLq7KJa6jaOZNK1Av9zyZTkwyPkYglOSTtieYKWrGUOqKO/RfL1qZ2/5b28YX38p33fl5i1m3D/ZdW0+6PAmkntHHTHmZlRifrHtH+/WzIv/ABMIJD08uVc+5KHH5A15ffeOvDOvT6x4a0W9FxrNm32mCIKwEstnskCI5AVvnjwQD0yRkZNSgPWJIUlwxyrL0YdR/n06VipcOmqxNPhUuIpFDjhW8tl2D2PLEeo/S79thvbG3uLGTcl8qmJx3V13bh/wHJFVNYKWv9m3LALBb3SKw9BMrQLj/gci/hmkgL90PIkW+X+AbZPeP1+q9R7ZA5NXqom6tYeFnj2j+EuOPpz+n8q5vTvGHht/EMngyC8D6hDH5qRhWx5eAdofG0lQRwDnbj3p2A7KiiipAKKKKACiiigAooooAKKKKACiiigAoqjqOp6bo9lLqWr3cVjaQDdJNO6xxoPVmYgAfU184eI/2wvgL4eme2XXn1SVDgixt5Jl/CQhYz+DGuihhKtX+HFv0RMppbs+naK+Lj+3f8EwcC31c+/2WP8A+PUf8N4fBP8A59tX/wDAWL/49XZ/YmL/AOfbI9tDufaNFfF3/DeHwT/59tX/APAWL/49R/w3h8E/+fbV/wDwFi/+PU/7Exf/AD7Ye2h3PtGivi7/AIbw+Cf/AD7av/4Cxf8Ax6j/AIbw+Cf/AD7av/4Cxf8Ax6j+xMX/AM+2Htodz7Ror47sv25fgZdSiOeTUrNT/HLaZUf9+3c/pXv3gj4ufDX4jr/xRfiG11OUDcYVYx3AX1MMgWQD3K4rnr5diKSvUg0vQqNSL2Z6NRRRXEWFFFFABRXBePfij8Ovhbpo1b4h+I7Hw/bPnYbuZY3lI6iOM/PIfZAT7V8f67/wUt/Zb0i4aCx1LU9ZVSR5lpp8iocen2gwn9K7cNl1esr0oNryQnJLc+/aK/OD/h6R+zX/AM+fiD/wCh/+SKP+HpH7Nf8Az5+IP/AKH/5Irq/sHG/8+mL2ke5+j9FfnB/w9I/Zr/58/EH/AIBQ/wDyRR/w9I/Zr/58/EH/AIBQ/wDyRR/YON/59MPaR7n6P0V+cH/D0j9mv/nz8Qf+AUP/AMkUf8PSP2a/+fPxB/4BQ/8AyRR/YON/59MPaR7n6P0V+cH/AA9I/Zr/AOfPxB/4BQ//ACRR/wAPSP2a/wDnz8Qf+AUP/wAkUf2Djf8An0w9pHufo/RX5wf8PSP2a/8Anz8Qf+AUP/yRX2l8H/ix4Y+N3w/074k+DkuY9J1Np1iW7jWOYG3leF9yqzgfMhx8x4rnxOWYijHnqwaXmCknsem0V8lfHf8AbO+EX7O/jC08E+PbfVJdQvLGPUENlbxzR+TLLLEoLPKh3bomyMdMc14r/wAPSP2a/wDnz8Qf+AUP/wAkVpRybFVIqcKbaYOaP0for5Z+Af7X3wq/aO17U/Dvw/g1OK60q2F1Mb63jhQxlxGNpSWQk5PTAr6mrjxGGqUpclRWY077BRRRWAwooooAKKKKACiiigAooooAKKKRmVVLMcAcknoBQAtFfKfxC/ba/Zm+G11Lp2teNLe/v4iQ1vpiPfsGHVWeBWiVh0IZwRXh8n/BUb9mlHKrba/IB/EtjFg/ncA/pXpUsmxc1zRpO3oS5rufo5RX5wf8PSP2a/8Anz8Qf+AUP/yRR/w9I/Zr/wCfPxB/4BQ//JFa/wBg43/n0w9pHufo/RX5wf8AD0j9mv8A58/EH/gFD/8AJFH/AA9I/Zr/AOfPxB/4BQ//ACRR/YON/wCfTD2ke5+j9FfnB/w9I/Zr/wCfPxB/4BQ//JFWbT/gqD+zNcyrHMmuWqk8vJYoVH18uZz+QoeQ4z/n0/uD2ke5+i1FfPnwy/ap/Z/+L1xFp/gbxnZ3OozYCWVxvs7pm/upDcLGzkf7AYe9fQdebWoTpvlqRafnoNMKKK5nxp4qsfA3hHWfGepwT3VlodpNezx2qCSZordDI+xWZQzBQTjIzURi20kM6aivzg/4ekfs1/8APn4g/wDAKH/5Io/4ekfs1/8APn4g/wDAKH/5Ir1f7Bxv/Ppk+0j3P0forK0HW9O8S6Hp3iPR5RPYarbQ3dvIOjwzoJEb8VINateS007MoKKKKQBRRXzh8Yf2svgR8Dbo6V478SIurgBv7Ps0a6uwCMjekYIjyOR5jLkdM1tQw9SrLkpxbfkJu259H0V8JeEP+Cjn7L3izU49KuNZvNAeVgqS6naNFCSfWSIyqg93KgdzX3HY31jqlnBqOm3Ed3aXKLJFNC4kjkRhlWRlJDKRyCDg1picFWou1WDXqgUk9i1RRRXKMKKKKACivjT4zft1fBH4GeO7n4deL01S51eyihlm+w20cscfnoJEVmeVDu2EMRjoRzXlf/D0j9mv/nz8Qf8AgFD/APJFepSyXFzipxptpkua7n6P0V83fs//ALUfw7/aSOtH4e2epxRaD5H2iW+t44ULXG/YqFJZNzYjYngYGPUV9I1w18POlNwqKzXQaYUUUViMKKKKACiiigAooooA/9H9/KKKKACiiigAooooAKKKKACo6kphoKiJRRRQUFFFfEv7QH7TWofD/wAd6N8OLPwXf61p2oyol/eRlo4liLKGQuqOFQBgzl9oZMquM7hpTpuTshN2PrKwnTVpx4gmOLJMrZKf4w3Bnx3LjiPHOzkffIF7UdOGvWM+nX4MdncoUZAcSMGGOTyFHtyemT1FZuj6+mp6XZ60bG4T7XCkqiTYuwOucAswA69e/FaSaw0pKwWUsrDkhZICf/RtJppjKXhXQtP8Nad/YdiDi2dmJcgs3mEtu4AAB5HAAyDWR4H8qay1WxmX99YavqSMejDz7h7lcEcj5Jl71p6jqd/bFdSj0i6P2cHzAGt/miP3v+W2cr94cZOMDqa+L/B/7T51P41al4B0CwiK+K9WkjhkkJkltpba2jt2d44yA6bbUsVDLgsfnIHOkKUpKTXTUVz6b8T6jr3hvxXb6nPdM+lSiOOKGNg00rAndEsI+eVznggHA5JABNdPZWWs+JYhdeIP9AsZMkWMT5dh0xcSrxx0MaHb/eZ+gk0jQbOHV5bsu99dwAJPeTkNLJIfmEYwAqRoCG2IoXcQcbgSeluYLiNjd2GDJ/HGThZMe/Zuwb8DxjGbfQZPapFHbpDEiokY2BVAVRt4wAOAPT2rxqyuri31rVPhpDJtlW5WeGN+I30y6DStjuArpJBkcAbeMmvVNP1G3uruRIiVMg3NGww8ckeFdXHY4KY7EHIJBBr5x+I/iOfwr4/0j4uBwmh6XfJ4b1FhkD7Nd8vO5x92G5KD6g+tOEbuwz0DU/GYn8VaZ4fvLJ4rVL9Q7hg2ZxlUUDAyglIbceeBwMV7RXJxaFo2rahcavcWwaVJikUisyEGL5Wb5SMMHDDd1wBWhJaaza/Np12two/5ZXQ7eiyp8w+rK5pSt0EeJftF+DZ/EXhB59Agkk1uUrb+XAWWS8teZJbdgv312qXCt3XC8tg/E1n+z7rfxltJbPTJbjwl4u8IRrd6bqjq9vNFcFj9nB4D7JCjBmA+VlJGSNrfoRZ+Lo5/Et7qWv2k1laaQpso5kUz23nsQ9wxkjU4AAjQF1XBDjqcVT8f6paaOumfFvQ5kvLbRmMGpNbssiy6XcMolOVzkwOEmHPCq4/iNdNCtKF0uomj4y+Df7XXjnxR4ntvgH8YdAjsfiNot6iXMYmS1bURagzK0KyAQmRmRGIEqq4IaMFSQv2tffGnwLozraeNmufC8k/yquq27RRv2IEy74W98PXwD+314G+HfjzRZfi1p+oiz1zwcdMgtL/T2Xfcy3Vw7GB5UOR5Ua+YjA7kbgdTX5oeKte1TxXdTa74m1GfVdRuOZLi6kaWRsdAWck4HYdBXs5dkqxac0+VL8zCtiFC2h92ftwfGDUtX8Oy/sv/AAi1aHV7LVpLaSa4tpfNZLSY7otNDrkMN+1twbiLZGc/NX1L+z74Q8ffD34QeHfAfwVsRb2WlWQW+utZwLa41BvmupLJE/eEtMXwXIiGACOCa/HP9l+90iX9pnwpoeo3AtV1u5NnFIY/MVLh42WFvLyuecJ14JDdq/oZXxDH8IbS38Na5Ep024lMOlXoOyOSedywt7knIifcSRJ9xlBOFYbTjjoQhFUYK8lv5jpyk3foeIeGvFMmi/FaDWvEGjahrF9cWzaek88yXF7Hc7y0gjgVUhhRj8m2JgoA3MTliPi/9uPQ/iJ8AvjR4Q/bd8F2H9lrcyx6P4hs7abfJPCV2oZ3C7A00KmLcNwjeOJgS2K/WzRvD2l2Pi27uZYUn1FLSCU3DL8xkmecSsgJOzO0DA6DAz6/Nv7evjLwn4c/Z51nw54osU1M+Lium20DsV2y/wCtFxkYOYNgdf8Ab2g8E1y0GqleMIreyHJ8sW5HoXh/TNC+IPhTR/jP8BdVWxvNbtY7pJpi0sGoxkf6nUFLMxkQ5QuD5kZBXJAxXgN/+11rq3B13XNJsdJ0fQp1kuQ8rNKojBinIlJVMFWfYCmeQM5r8RJfGmv+DdDgsfC2t32k2tjk28VpdTRCN3bd8gVxhmY5JHJPJrpP2fPBni/9sX44ad8JfiH46nsNKjguNRuMANPdeQwLpFhdrTsHJ8yXdtUM3zH5W9bMMlWFknVd4/ic1LF+0Xu6H6dax+0h8Zf23PF178Jf2SjceEPh/Yv5Ou+OLiNo5yh+9FZL8pR2X7oBEpyCTCuSfsPSv2Uf2evh78Dr34XT+ErPWvD0Ecl9etqUa3FxeXccZLXc0xAbzjzh1K7AdqbV4roP2frbwp8OvC9l8E9O0q38PXPhxZbeKGBdkN8kDFXuoySWaSTh5QxLgtkkghj03x+8SL4d+E/iRohvu7yyltoYx1JnxEWJ7Ku8ZPuAPmIB+cnK75Y6I6z4f1//AIJ6/sw+JvhLYeBPDHg+LR/F+vWNrdDV4ZZprmxlEYL3LtNI/wC6LEgwjCyE4AUqHTyb9l74heLP2XvivF+zH+0zCsOtkeV4T8RyuTZalbMdq2vmvgBn4WJzhlbET4yA367+E/Dsfh3Sord38+8kSP7RORgyMihQAOcIoGEXsPU5J84+Pv7P/wAOv2jvANz4C+Idl5sRzJZ3kWFurG5xhZoHIO1h3B+Vh8rAinCvvF7MTR7HZXsGoWy3VsSVbIIIwyspwysOzKQQQehr48/aF1JvDuveIWzsh1fwpqE/sZrCzvk/PZOPyrxn4KfFn4nfADx7a/s6ftITNf6hKuzw94iAbyPEdlEAqqWYnGowLhWRiWmXCktIImm6v9vrVoNK+GGn+PrCQS262WtWYkQ5V01DTZlU5HUfLkURp2nbuM+jvhv4Y8K/E79mzwT4f8a6Xb63o2teGdJ+0Wt1GJYpFe0iYEg9CDyrDBU4IIIBrxTT9C+Jf7KU66B4LkvPiF8LyhePTZN93rnhqAHG+3Iy99ZJyFgJ+0KABEZArAekfs5+JzD+zJ8H4LCMXerX/hTRUghzgEx2UKvJIRnbGh5Y/RRliAfX9Y13wr8KvC1/4u8c6vFZWsOJb2/uDt8yQ/KqqoySScJFEgLHhVDMeYbabQHxt+0n+1p8Hvhn8KdX8SeCNfsPEPiu+0WZtKS3K3FxLcXbpHDNKUB2CI7pGV9hAQqADgV4d4R/Y68b/CvwH4WstLkTUdSvLKK41FZZVV31OdfOuVWVyFY72YDcwLAZXPKr8K/tR/AP9pXV/G3jz4oeH/AGoXXhjW2vNfWSU28dzaWUjSz7bq3EvmRSLGN3l4L4wCPMyg/fz4O+Hbez/Z98D+Gb/UV8QxW3hvTIGvRu23fl2kYE6E4YBiA6k/MODnPNduJVOEYeyld9fUzg5O/Mj5c+D/wJ1Lx/pdv4k8TXJsdDu42aFbaQfaZcErkHDKgBHfJ9h1HU+LP2efCXw98UaT48g8Sa3p+kXhTStZn/ALQEXlRuxNjOz7B8sVwxiIPAFwXJAQ5739mLxHNafCvw5omtnCSNcxWd0fuystxIfJkPRZQOR2cdOQRXiP8AwUP8PfEr4h+AtD+H3weifXNfa8N7eaLBIsck9jHFIBM7OyxhY5MbUdh5jfcDMmBEajnVUakrLv5Da5V7qE+DXwM0v4xabqHxX1jxL4jS38Rzs2myG/8A339kQsy6ehaSNuGiZrlh0D3DIMFGz9Qaf8CND0i2jtrTxBqoihXA802UvA9TJasT7k1+fn7EPwV8baR4e1H4TfH3XfFXhDxBBM+p6Z4etNaksbV9ImWMNLDPYShmZbguJ0SYGIshZVMgLfoLbfs2fBCMhtS8KQa+45D65LPrT59d+oyXDZ985rGtPVq+nQpH5u/FJPCngz4q61Y+IdSsLyS7n8y2meS2LzRNgICIwq71GFKhV5HAAIz9b/DSN4/BNppT+H7TUoLhZMW9zoF9JmOVidjXPkm3ZSD0PABwTxXd/Evxv8Lvh1p9v4Y0mG20h7LVNIlkS0tlht4gt7AxDmNVUfIT9O+K2NS8aeIvil4iuPAXw8ll0nSrPb/bGtKNs8Mcihlt7UMPkuZkIZSw3RRsJWC7oRLbrydNQtoJRV7n5ifEv47/ALSXgv8AaW0n4dfD7wulv4fXVtOsLa0a1ivNOkN0YkmjmvzG5TEkjJtE4MPCADAB/S2z+H2seC7u88bLYi+vrCC4mgtoEVovMMbZVMzK/wAwJVRhiAehNe0/8IJ4SHg9/AKabHHoLwG2NspZRsbqd4O/fn5vM3b9/wA+7dzWX4I1XVYHuPBXimc3Gs6OqlLlgFOoWbHEN18oC+ZxsnUAbZQSFWN48zUxLkrJJaW9QUD56+A/xO1zxJbS2fiC1D2WnQqkUthZSyGBWbiJ1BlOMABTtOAvPc1sftB/DPxP8dPCOmaB8JviMfCF/aajHPPc2yl2KKjHa4geGRXRsOqs2CygMAcMv0bpqQ2mvapY26LGsiQXZ2gDLy7426e0IP1NYfiq/wDBNnqds3i2a0tikZET3LKj7pGwDG5+Zdu05YEYyOaj21pc0dA5dLM39M1CSCOLTdYzFexoBuOCs+0cvGwABJ6lcBgf4cYJedC03+0jr6WcS6mV2+dtG/aONpb3HBP+ArL/ALBe7hD2t9KbXhoo7gm5TPaTexEwbuhEvy9R6C3Dda3pg8rU7cXkA4E8DDcB6yI+3A91Le/TccfQo6NHDqHXoadXnPij4oeDPBVxZW+vXjQSakWMUYikL4XG5yu3ITkc45OcZ5r0RHSRFkjYMrgEEcgg9CKHF2uA6iiipAKKKKACiiigAooooAK8o+Mfxd8OfBnwhL4o179/M58qztEbElzORkKDzhR1ZsYUepIB9Xr8Ov2rvidc/Ef4uanDDMW0nw876fZoDlf3TYmkHYmSQE57qFHavayLLPrVbll8K1f+RjXq8sbnnnxS+Mvjz4vau2peLb9mt0Ym3soiVtbceiR5646s2WPc15XRWhpmk6rrd6mnaNZzX93L9yG3jaWRvoqAk/lX6rTpwpx5YqyR5Tbb1M+ivUl+B/xmYBh4F1vB9dOuB/7JTv8AhRvxn/6EXW//AAX3H/xFR9bpfzr70PkfY8ror1T/AIUb8Z/+hF1v/wAF9x/8RR/wo34z/wDQi63/AOC+4/8AiKPrdL+dfeg5H2PK6K9U/wCFG/Gf/oRdb/8ABfcf/EUf8KN+M/8A0Iut/wDgvuP/AIij63S/nX3oOR9jyurFpeXen3UV9YTvbXMDB45YmKOjDkMrLggjsRXW698NviJ4WtTfeJfDGp6VbDrNdWc0MeT/ALbqF/WuKrWM4yV4u6E00fp/+zB+1xe63qFp8OfipciS7uCsVhqb4Bkc8LDcHoWbosnc8Nkncf0dr+aRWZGDKSCDkEdQa/df9mL4nT/FP4S6bq+pS+bq2ms1hesTy8sAG2Q+8kbKxP8AeJr8/wCJ8mjStXpKye6O/C1m/dZ9CV+d/wC2x+2zb/AG3/4V/wDD/wAq+8eX0Qkd5AHh0yGQfLJIvR5nHMcZ4Aw7grtV/tP4pePtN+Fvw58R/EPVhvtvD9jNdlM4MrxqfLiB7GR9qD3Ir+STxj4t17x54q1Xxn4nuTd6rrVzJdXMp/iklbJAHZR0UDgAADgVnwrkscTUdWqrxj07s3qztohfFvjHxV491658T+M9Vuda1W7OZbm6kaSQ+gBPRR0VRgAcAAVzVFdp4S+HHxC8fNKngXwxqniIwHEn9nWU13sJ/veUjbfxr9UbjCPZI5dzi6K9y/4Zj/aN/wCiYeJf/BTd/wDxuj/hmP8AaN/6Jh4l/wDBTd//ABusfrtH+dfeh8rPDaK9y/4Zj/aN/wCiYeJf/BTd/wDxuj/hmP8AaN/6Jh4l/wDBTd//ABuj67R/nX3oOVnhtFe5f8Mx/tG/9Ew8S/8Agpu//jdH/DMf7Rv/AETDxL/4Kbv/AON0fXaP86+9Bys8Nor3L/hmP9o3/omHiX/wU3f/AMbo/wCGY/2jf+iYeJf/AAU3f/xuj67R/nX3oOVnhtf0v/8ABOv/AJNH8Hf9dtT/APS+evwS/wCGY/2jf+iYeJf/AAU3f/xuv6C/2EfCvibwX+zD4V8OeL9KutF1W2l1Ey2l5C8E6CS9mdS0cgDDcpBGRyCDXyXGWIpzwsVGSfvLr5M1op3Py2/4Ksf8nE6B/wBivaf+lt7X5l1+mn/BVj/k4nQP+xXtP/S29r8y697h/wD3Kl6GdT4mfq7/AMEmv+Sq+Nf+wLH/AOlKV+79fhB/wSa/5Kr41/7Asf8A6UpX7v1+dcX/AO/S9F+R00fhCiiivmDQKKKKACiiigAooooAKKKKAOa8Y+MPDfgDwvqXjPxdfJpuj6RC09zPJ0RF7ADlmY4VVGSzEAAkgV/OV+1L+2/8RPj/AKld6BoM83hzwKrFItPifZLdoOj3jofnLdfKB8teBhmG8/R//BUn46XmqeLNN+A2iXJTT9Gjj1DVVQ4827mXdBE+O0URD46EyA4yoNfkdX6bwpkMI01iaqvJ7eS/zZzVamtkFFSQwy3EqQQI0ksjBVVQSzMTgAAckk9BXstp+zd+0Jf26Xdp8M/EksMgBRxpN3hgehB8vkH1r7OpWhD42kYpHi1Fe5f8Mx/tG/8ARMPEv/gpu/8A43R/wzH+0b/0TDxL/wCCm7/+N1l9do/zr70PlZ4bRXuX/DMf7Rv/AETDxL/4Kbv/AON0f8Mx/tG/9Ew8S/8Agpu//jdH12j/ADr70HKzw2ivcv8AhmP9o3/omHiX/wAFN3/8brH1z4CfHHwzYS6t4h+H3iDTrGAFpJ59Luo4kUdSztHtUfU01i6TdlNfehcrPJlZkYMpIIOQR1Br9SP2P/8AgoJ4m8B6pY/Dz43ahLrPhS4ZYYNTnYyXenE8L5jnLSwDuGy6DlSQNlfltRWWPy+liabp1Vf9PQcZNPQ/s3gnguoI7m2kWWGZQ6OhDKysMggjggjkEUy7tLa/tJrG9jWa3uUaOSNhlXRxhlI9CDg1+an/AATJ+OF58QPhVf8Awx8QXBn1PwM8SWzOcs+m3G7yV55PkurJ7IYxX6Z1+K5hg5YatKjLdf0jsjK6ufyGfGHwBc/Cz4p+Kvh5dBs6DqFxbRs3V4VcmGT/AIHGVb8a82r9RP8Agqf8Nf8AhHfjDonxItIttt4usPKnYDreafiNiT7wvCB/un8Py7r9nyrF+3w8Kvdfj1/E45qzsf0mf8E5viX/AMJ/+zZpekXUvmah4Onl0mXJ+byUxLbnH90RSLGP9w194V+Av/BLH4mf8I58Yta+G15LttfGFgZIFJ63mn7pFAHvC0xPrtH4fv1X5TxLg/Y4yaWz1Xz/AODc66bugooorwSz5C/bZ+P95+z98FbrW/D8ip4l1yYadpjEBvKkkVmkn2nIPlRqSMjG8pkEHFfzF6hqF/q19capqlzJeXl3I0s00zmSSSRzuZ3ZslmYnJJOSa/TP/gqZ8TP+El+M2j/AA4s5d1r4OsA8yg9LzUNsrg/SFYcemTX5g1+vcKYBUcLGbXvS1+XT8Dkqyuwr9WP+CaP7R+teHvHkfwF8S3j3Hh/xAJX0sSsSLO+RTIUQn7sc6hsr08zaQMs2fynrp/BPivUvAnjHQ/GujnbfaDe299DzgF7eRZAD7HGD7V6+Z4GOJoSpSW+3r0IjKzuf2K0Vh+GfEOm+LfDeleKtGk82w1m0gvLd/70NwgkQ/irCtyvwuUWnZncFV7y7trC0nvr2VYbe2RpJJGOFREGWYn0AGTVivjj9vT4mf8ACtP2ZvFEtvL5WoeI1XRbXnBJvcibHfIt1lIx3ArfCYd1qsaUd27Cbsrn86nxj+IFz8Vfip4q+Il0W/4n2oT3Mat1SAsRDH/wCIKv4V5rRXVeBvCWo+PfGmheCNIGb3Xr63sYuMgPcSCMMfZc5PsK/d4xjThZaJL8EcO5/RB/wTl+Gv8AwgP7Nel6xdReXf8AjC4m1aXI+byWxFbjP90xRiQf75r7yrH8O6Fp3hfQNM8M6PH5NhpFrDaW6f3YYEEaL+CqBWxX4XjsU61adV9Xc7oqysFFFFcgwooooAKKKKACiiigD//S/fyiiigAooooAKKKKACiiigAprU6kNA0MooooLGuwRGduigk/hWPdKsN9p0hUCSaVkYgcn91I/X0GDitKY7pI4fU7j9Ex/XH4VjeKJRb6WtzjmG5tWHr/r0Bx6ZBI/GmgNmBtpe3PWMjH+6en5cj8KS7Wz8h5b4R+TEC7NJjaoAySS3AAHU1na1qVnocA1m/lENtEQkrYJ4kIVMKMlm3kKoAJO4gAk1yMuk3XjEpe+L4jaaKrBoNKflpyOVe8xndzyluMqOsm9sLG0uoHK6npt38WLO40zQZZvD/AISuYnjkv7fMF1qIdSuLYcbLfn/XMN0g/wBUFUiVvn/+wvBP7PniKyks7eKTXImjtJtSgsoYVjsrtBFGjlt75WcxM5XdiPockivupTLLzjy09/vH/D+f0rxj4m/DjQfHUWrwXscnmJYoGMJO9ll81X4HLOqgMgyMuFzxW1OotU9gPTrLQ7mwtI7WHVLglMksywnc7EszH93nLMSTz3qU23iIcRahbEeslqzH/wAdmUfpXmvwn1648ceBNO122v3tNVhDWuoQgieBL+0Yw3ChXyRH5ittEbKNuK76TUfEmnZN7pq6hEM/vLJwJMDuYZSMfRZHPtWTTTsB4X8b4vHOnQ6Xrtmd9tbyMt3Pp6SxSiLHy+aA7HyxluckAn/a586+K/i7Q/D37N2p+H/Flu083iE3NlZ2+7bKJGPm+dJnJBikPmcjJO0Hhsj37xz8dvhL4A0O41Px3rcekxhSDa3Ubx3UxI+5HbsokkJ6fKpHcnHNflR+0P49+J3xj0zTfFui+BLzTPDfhCGZjdXIA1G7t/3X+kzWoO9YlXy2B+YDezByudvbhErrnWlxST3R19h+1n8X/AGn6fbx3lrqdlpsMcRguYF/fBAFJaSPbJvbqWyfmOcHpX16P26fgO3w2g8ZXGvQWWsXVs7Lo7bp7qO6QlPKdYVYhd44chdyYYDnFfg94j+KiXlmYY8u7/KAmScngY7/AKV+rn7Afgq0n8E+GTcfZLuVZbrxJeSw7JHSWci2srV5F5DRLG0zJnCuwUgMDXdmiw7mnSWnkZ0VK3vHoGkftoWlloFnoXwq+GHi/wAfXkKFpbiPT3t7eaaQl5ZfM2yuN8jMx3RjGa8Y8Z+K/wBuD4rzzWHhD4L6f4M/tWOVHnubgRXbQsNsglL3EAdSGw2+BgcgcZxX60avqtpothJf3hJVMKqKMvI7HCIg7sxIAHrXEW/i/wAIeH0m1HxV4h0611K6wZle7iHlKudkKAtkhMnoPmYs2BnA8yNZLWMTU/DmP9lf9sr4gad4m0/UvEtjMfC0scdzoS3LJJPJDEWgZUihWGTILBHaTO7Pfmvzx8QeNNS8P3l1oGvQS6dqNk7Qz21whjmilXgq6NgqR71/Qh4g+MmnaN8ZtR1n4ZTQajJcLsu5H3NbSxSRQGNQBtO9JEkbdnGGx616nq2mfCb4v2Fr4x8SeEIbnxLbZQvJoL6zCXT+Bz9nkRlIxj5lkUcBh39Cni68I80dEzKUYt2e5+Hf/BOT4Wan8aP2ldM8czSx2/h/4c7dWu3eRVkknIZbZEUncR5o3s2NqqhBILLn+jmx0+x8fxXera9aJd6NeRvbWVvMmUktX+/OynvNgbeMiMKRgs1fgv8AtDeJde/Z/wD2rbb4x+HPD8vh/QdfgistX0qOKWyt7yGFYkuoUDJGUSaNY5FG0Ybrnkn9n9J+Nni3xPothrvw9+GuoarpOowRz2c8t5ZWkcsEiho2X944ClSMc1hiMLUVqnfroioW2Rxl9resfs8eONNt/ENxPrPgC/tZ4be6Iaa70lUlh2xznky26F8Rty6htvOFB+av+Cpa6JrfwD8P+N9J16x87RdRjuYYDdRq97a3iGJjbru3SsrbGwoPyBz2rpP2nP2pPHnwasdG8UfEHwJp2kRzG6tYLC61SC/lvVnhIkUww4JjBC7mxtGQGOSAfy/+D2lzfF3x7N8UfiPFHb2FnPJLpGkIW+zQB2LIyLIWYonAUsSzEZJwoB76eEqPkrtpW6prf5dTOrJWaPgvUPHazj7RPINsQPlL792P4cCvdP2UdW/aA8CePov2n/hV8PLzxlonhF57O7dbeaWBvtULJKoMPzgpGxYuFZYyVLjBAP7c6d+wp8CPHHh3SviB4v8ADmg6dc3aeaHXTmEkodiY2lCXCQzO4wRmEk5AO45J+ofDvwT1yy0a08O6H4s1Hw14esU8u3tdNtrPSwkfXEUEEIWJec/MN2c5UHmuXGZhKpK03exFOklsfD/gP9vr4E/HrV5PD+qW914N1vUpreWBbmZIrix1RE8kyW0x2pIp2opBaN2AOU549m+JfxV1ibRdQ+GHi2zS78UxXVul9e28im0lt4GSeMRgDKl+Cy4GGJJ5O1dDxR/wTp/Z3+KN/qGveNTrGp39zNKpu5LxRcsyHYzvKIgzNvDEbiR6g1+dXx1+BfxV/Yplu9S8J+KZdd8CTlIrNNVjWa4h875FEcibfnjY527VTGDg5ArnpRpymopmkm0rn7f+APjN4R8dWoVriPStTDKjWVxMgkJb7pjyQZAcEZAzkcgcZ9cr+PrxBql7rUEuq3V2WuZcs7T5keQnuxJyK+5f2Sv+ClHir4X+FL34Z/EDw7rHxEOnyI2lTWDedcQW7AgwSs+WaNWA8o8kAlfuhQO/NslVBp05XuYYfEc+6P3S+Lvwg8C/G/wVdeBfH9j9qsZyJYZoz5dzZ3Kf6u5tpRzHNGeVYe4YFSQfxq/a+1/4kfDT4Qa7+z/8XdR/tOVQ93omtRx5j1ePa0B8wLu+z3aicG4jb5WP71GIdq+htG/bw+O/xT1CPS/h98Ef7Mt3ODJrXiS00qVs9BsniV8eojy/oRXwN/wUIvPjVpvjjw9q/wAadG0vSItV0jytOttFu5L22gEczswleVIyJmZ9zMAQ4xhiVYLy4CjH2ijWdka1JNLQ+3P2XP2vvgr8LP2WPCz61qUmu+PrS2tdFi0GzRptWu5o18u1t7eDA/dEY/eDKbieS5Cn65+FXwl+IPj3xFY/HD9poRN4gtm8/QfC8D+bpvhxWHyue1zqG0/PcMCEJKxbRg1+B/7Ddh8Q9e/aI0XWfAWq6boNxottODqGq2bX1pE9zG0McZjR4iHk3EKRIuME5xkH+h7T9L/a9tsLqPiPwPfqO6aPqVux+p/tCQfktY4unGMmoP5jg7rU9o0hIr7UfEa3CLLE10luVYblZBawkgg8EZdgRXl3wH0mXwX4L1P4TTlivgS8uNNsixJLaU4Fzp2M8kR20qW5boXhfHTAq+Abn44G0vr2+tPDt6txqF5uMdxeW2TFM0JxmGfA/d8deK/GH9sP9r74veFvj34r03S9fl8KXeg+RYR22l3JaF0tlaRWlkKIJx5kshxImFyU25BysJhPayceZKyvr5CqT5Vex+ifwg+IMd78KT8KPDFvDqniW4nuGl88MbTS7aQhku7ooQ2S277PCjCSV1O0oiSSx9v8FPB/jTwv4/guL6S/uZb1Zm1S81Es0l0xj+8zsAC25U2qmAqKFUCNQB5B/wAE5vsF7+zrJqZQS6t4gv0a6nZvMlle7jiSZ93PO1GbHYKF6KAP0o1SzkvbQpbuIrmMiSFz0WRemcc7T0YDqpI71lUmleNi7HKeP/AVh460+1/0h9M1nSJvtelanCAZ7G6AKh1B4ZHUlJYm+WWMsjcHibwZ4mv9Zgn0nxJbJp/iPS9qX1uhJibdnZcW7Ny9vNtJjY8gho3xIjgdJpGpx6tYpeIpjfLJJGfvRyodrofdWBGeh6jg1+Xv7dtx+0R411Lw1P8As0W+o6ja2Ul1pslzo9ylnMdQZg7ospkjeSKIQ/vCp8pJFw53oQk0KanLlk7LuKTsrpG9+1bZ2/ia58SeFfh7O0+qQ+Te6zOqB4dJtxKmJHcnH2ieRSsEBBJAeVsRqA3294Q+Dfwy8K+HrLR/D+jotrEm4SSO8k0zyfO8sshO55JGJZ3JyzEk1+d3gLxfe+Hv2XJ/BTQaE3im+iK+IIbnUr2DXP7d+Rrs3tvJZTOZd4AVmkWMxhPLPlbBX3N8Mvid4j1/wjpk0fhtNTe3tbeOcaZqNvPJHIIwCHS6+yFTkHr+BPWrqyk0vIaSR6wngfwrH9ywVfo7j/2asHxJ8OtLvYrfUtDhFvrGmMZLV2lkVXBx5kEhBJ8qYDa3B2kLIAWRa0o/F+qj5r3wlq1pH3Zvsc2P+A291K5/BaLr4h+GbG1mvb77bbQ24zI0mnXihfQHMPU9h37Zrn1Gc5bvoEut6RrMfm2dteWd7FMJZpEaKe3eNvLk+fAaPEwbkjIOCRzXMa98MofiRNJraXcllEJXgiE4eZzDF+7Y4dwU+dWKr6HJAJIHk3xs+LvhL4ZQaL8YfGEj2+kR6vBH/Y6IPts00lvNFHcSRSMmJAn8DEABELNvUKPd/hF47t/il8N9A8Z+DZFXR9VtxIt1KN00kgYpPiIHCt5ofLMxIYHKEc1tyzilNCdnoei2FhF4c0i1sIrsC1sYY4VNwR92NQi/MNuCcdTmkn1p4kVjbum87UJBJduu1I8CRj65CjAJzjmqcz21jeLa2iNqesFdwMrZMStkb3bG2JDyMKoLYO1Tg417HTvs7m7u5PtN5IMNKRtAHXbGvOxM9sknjcSeawGfINx+yb4Q1f486p8ffEesX2oT38VvaLpPmBbSBm8lG+ePDsuyNSIydqszctxj7QRFjRY0AVVAAA4AA7CuM1eFNT064gDtEby6EJdDho8OIsq3r8u4emfzn8E+E4vBehjRYbqS7USPJufjbv8A4VGTgd8Z6knvWlSbkveYkrbHXUUUViMKKKKACiiigAooooAytd1A6TomoaooybO3lmGf+maFv6V/N5NLLcSvPMxeSRizMeSWJySfrX9F/jr/AJEnxB/2Drv/ANEtX85lfe8FpctV+n6nBjOgV+3v7JXw30TwR8IdF1m2tk/tXxHbpfXVzgeY6zfNFHu6hEQrhemcnqa/EKv6Cfgb/wAkY8C/9gTT/wD0nSunjCrJUIxT0bJwa95nqdFFFfnJ6IUUUUAFFFFAEU8EF1BJbXUazQyqUdHAZWVhggg8EEdQa/Cv9p/4eaV8NPjDq2h6DEINMukivbaIdIknGWQf7KuGCjsuBX7s1+OH7dn/ACW6L/sE2v8A6HLX1XCNWSxLino0cuLXu3PjKv0s/wCCeerTb/GuhOxMWLG5Qdg371HP4jb+VfmnX6Jf8E9f+Rl8Y/8AXpa/+jHr6/iOKeCqX8vzRyYb40el/wDBS/XbjSP2W9RsYGKrrOp6faSYPVFc3GPzhFfzhV/Q3/wVK/5Ntsf+xhsv/RFzX88lLgyKWDv5v9Drrbna/Dbwi3xA+InhfwIkpgPiLVLLT/MHJQXUyxFv+Ahs1/W94L8F+F/h54Y0/wAG+DdPi0vSNMiWKCCJcAAdWY9WdjyzHJYkkkkmv5Yf2YP+Tjvhh/2Mmlf+lUdf1j14nHNWXPThfSzZdBaBRRRXwRuFFFFABRRRQAUUUUAFFFFAH8+//BVj/k4nQP8AsV7T/wBLb2vzLr9NP+CrH/JxOgf9ivaf+lt7X5l1+2cP/wC5UvQ4qnxM/V3/AIJNf8lV8a/9gWP/ANKUr936/CD/AIJNf8lV8a/9gWP/ANKUr936/OuL/wDfpei/I6aPwhRRRXzBoFFFFABRRRQAUUUUAFFFFAH8mv7TXiG58U/tDfEbWbpy5fXtQiQnn91bzNDEPwjRRXhtel/Gj/ksXjv/ALD2qf8ApVJXmlfvmFilSgl2X5HBLc/cT/gl38CfC6+Db74665Zx3muXV5LZaa8qh/slvAqiSSPP3ZJHZlLdQq4BAZgf14r4H/4Jrf8AJq2j/wDYQ1H/ANHGvvivxziCtKeMqcz2dvkjsprRBRRRXjFhRRRQAUUUUAfz3/8ABTP4K+Gfhn8UtE8Z+ErOPTrTxtb3EtxbwqEiF7aMgmkRRgL5iyxlgB97c3Vq/NOv2e/4K79fhR/3Hf8A2wr8Ya/aOGq0qmBpym7vX8G0cdVWkfov/wAEwNfuNK/aVfSo2Pk61o17buvYmJo51OPUeWQPqa/olr+bX/gm1/ydZoP/AF46l/6TtX9JVfCcaRSxi/wr9TejsfBf/BRv4a/8J7+zZqes2sXmX/g65h1WPA+YwrmG4Gf7oikMh/3BX829f2R+I9B07xT4f1PwxrEfnWGr2s1ncJ/ehuEMbj8VY1/IL448J6j4D8Z674J1cYvdBvrixm4wC9vI0ZI9jjI9jXvcEYzmpToPo7r0f9fiZ11rc2/hJ49u/hd8TvC/xCstxfQNQt7plXrJEjjzY/o8e5T7Gv67bC+tNUsbfU9PlWe1u40mikXlXjkAZWHsQQRX8Z1f02fsB/Ez/hZP7M3hsXMvm3/hjfolzk5I+x48j3/492i/HNRxxg7whXXTR/Pb+vMKD6H2hVPUdQstJ0+61XUZVgtLKJ5ppG+6kcalmY+wAJNXK+Kf+CgXxM/4Vx+zP4hitpfK1DxU0ei2+DyRdZNx74+zpIM+pFfAYPDOtVjSXV2Ohuyufzs/Fbx5e/E/4leJviFf7hLr+oXF2FbkxxyOTHH9ETao9hXn9FbPh3QNU8VeINM8L6HCbjUdXuYbO2iHBeadxHGufdmAr94jGMIpLRI4TGor6N/aK/Zh+If7M+raPpnjqayvY9dgea2uLB5JIS0JUSxnzY42DJuUnjBDAg9QPnKooV4VYKpTd0watuf0e/8ABNv4mf8ACd/s42fh67l8zUPBl1LpjgnLG3b99bt/uhHMa/8AXOvv+v59/wDglz8TP+EW+N2pfD27l2WnjOwYRqTwbyw3TR/+QTMPc4r+givyDibB+xxk0tnqvn/wbnXSd0Ffhd/wVc+Jf9qeOfCnwospcw6FaPqV2qng3F4dkSsP7yRxlh7SV+57ukaNJIwVVBJJOAAOpJr+Sn9oT4kP8XPjX4w+IQcyW+q6hKbUnqLSHENsPwhRM+9ejwZg+fEuq9or8Xp/mTWeljxuv0W/4JlfDX/hMv2hD4wu4t9j4KsZbvJGV+1XINvAp99rSOPdK/Omv6Gv+CYXw1/4RH4B3Pje7i2XnjW/knViME2lmTbwg/8AbQTMPUMPrX2nE+M9jg523lp9+/4XMaUbs/SKiiivxs7AooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAYRSU8iqt1I0ULFPvnCr6bmOBn2yeaC0yvDPC1y+6RRJJkIhI3FYzgnHX7xPPpivmr9rX492n7Pnw6sfFV1pZ1L7bqVtboGkMMCNETc/vJAr43CIqoxzkntg+ka/8PdHPjWy+IYupReaZbCHyHYfZzHGrnLnGU4Zs4OD12nBB3bTw9pfisNqfibT4bmMkpDZTxKyQKDnMkbAhpWOCS2doACgfMW3puMWpNXXYTvseQfBT4naN8a/BGmeObq2exlubWJo7e+ZVjtEnhBzGA2ZJGRsGQhTgkDYrYbtvh58XfCHjjU20nTpJ576NX23EsYWK4EfDNDg/KCPmAKqSOuTXTaGI/D2or4bwsFvcobiwcAAbODLCQOP3TEFRxmNgF/1bGuN0b4M+DfB2pXOteHtPaWdi7mxnYSweUx+dbcMOD/d3E4+6dobIfu63+Qanulc5ocguL/W7heR9sEan2jgiUj8H3VnQ+FvBGtWkd7aabb+XKMq8KeQ/BwQSm1gQRgg8ggg4NeL6m3w/wDAPwq1D4keJ9V1TSdMt2urtjbaleB5BLcP5EUUXmlHkkyiINuWYis4xvoUfHlj+1r4E+DfxV8YJpNrcar4Pv8AUhciSAopRGjWO58mI43okqb4vmXhn4+cEfXt78U/H3xN0uC9+EMVt4X8MXyK6eKtfXYJYnGQ9hp7FZJcqQySXBiQ9lcV+Nus/sk/tD+FLSz8Q69o0GmeHNemsohcXV4ssmmLqEywQR3saqJA6F1EhSNlBPJByB+2fwX8GeH/AIT6DoHw2s5I9Rt7Oxji0/UWiVZp2t0C3Mch6q4cFwpPCkr/AMszXoYz2PuypL1IhzdTivCnwa+CuhanL4p8Rvd/EzxXMo87V9Rhl1aTOPuwrFG9vbqD9wIFKjjdiqPhLwl4w0zxZbeMPC3hyaWzTzWjae4htPtEMqkIGG6RwMENgoeQMc8j6a8U3LSRWvh6A4n1mQwnHBW3Ubp39vkBUHszLXUqqooRAFVRgAcAAVxe2dtepbPhT4ifC7T9U0nVXh8BeE/CGuXQDxzrZxi9mdHWTZHqAhhiDyY2/eJ5wcZzXxxpt9rH7LHjbS/GXjDSdU0j4b+I7sW2otF51q9lczKf3sTIUcxEgMwQ4IGBzsB/a+WKKeJoZ0WSNwQysAVIPUEHqK+Rvjj8ANJ+IEU3hjT9Min07VbORJbRXWNYjvGZYw/yoclSNo4Zc4rfC17Nx2TJkjsvDnwz+HvxDkXxrdWT6nolwgbS/tF3c3QuI2GftZMsrkiQH93/ALHzdW49Js/hN8MLH/j38KaZkd3tYnP5upNflD+zV8avFv7HPxOuf2VPj/dF/CxlJ0PVTueO2805Vc4z9nlJ9P3bnONjEj9Hof2q/wBnefVF0hPHmnLOzBAzs6Qbjx/r2URD678UqmHq/ZTaByS3Mzxd8AfBfi/xdeXFmp0K7trO1aN7JI40PmNOpEke3DAbARjaeTzXY+Ab/TdA8D2+h6TbeVq9rcPp81q7F2/tEfNIztwTGV/fbh/yywQOi16LHJCdbjvYJFkgvbPcHUgqVhcFWBHBBEpINfGXxT+Ofw5+CPjK0+OHjPW7PTtK1pW002G4NfXNmn+q1CG3X95ITIpQkLjydnSs4NyXKOy3Plf/AIKP+PPA2q/2V8Djp0Op6vpUsOp32oSDE8UskbbIQy4P7xJPMcZ2AFABx8v59+D/ABt8RPCT2aeEvE2paZBYDbbwW95NCkS5yVQKwABycjGDXnHxk+O+hfFX4zeL/iDoS3X9na5qDzWqXKqs6w8JGHAZkU7QMAMcdKzNK8Uko00siwoq7sD5mx7Z4yfoa/Rsn+rRw0abV5Hh4v2jk2jb1vUNd+Pvx+t7z4la1e6/fMkey3m5kmWFlC28eMJHHtLO23GcMerFh+/P7P8A4I0Lw74QtbD4c6Hb6nqshSS/1rUIPLtbSYAYhgQgSyGIcBU2rn5i4yBX8xWh/FrUvAnxh0n4g6PAuoT6RLLI0UjEI0bxvEyll5AIcjOMZ7dq/b/9mD/gpx+zxa6L/wAIr8RLe/8ABd9c3DTtcSxm8sWeQKuBJADKuNoGWiC45JHIHyWZVZOUlT+G+3Q9WhdJXP0P0fTY/hN4wtLXX7htQ0nxDIy2d7MoVbDUJSWe3RF+SGG4JLR7QMNlSSCpr3zUr6PTdOutSmGY7WJ5WA6kIpYgflXmNj4j+E/x/wDBd7Z+Gdf0/wAUaNfxBZJNPuY5zETyjHYSY5FYZG4AgjpXyl41/ax8M/BDTpPhf8ari5u/E+l3VsqLZRedLqOmq3mrcfMyopdE2OHdck5GTu2+PChOrLliry7Gs2krs+99ItJLHS7W0nO6WKNRIw/ikx87fi2TX5a/8FDvFsfxH8Q+Fv2TfBenjxH4y8TBriO1WQqli7/LDeXLrkxrAiyS47ryRt4NP4q/8FVfh3pnw81Sf4Y+HdWn8aSkW+n2uo20awLJJkCd2gml3JH/AHAQzsQvAJYVv+CdPw08S6dqPjb4yfEQya98T/FMqQ3l5dHd9ijb97LG7jgE/u/kTH3VRQEXcNPq86Tcqis10IUk1ofjH8af2ef2h/g8dcXXNIj1PRtCkeOTVbG4SS2ZUk8vzFRiswGcfeQY+mTX0f8AsPeIfjl+y74Un/aR0LwHB8RfAPipjbazNY5k1LSjYSSKRwC0Pyv5jEo0ToybnRvu/vj41/Zu8L+PbbU9M129lbTdcjmjvoFjQeYLgES7G6IDuOPlbHrX5rf8EyfEV78Dviz8Wf2Q/HdyIbvS9QN7p5f5I5pIWFtM65/57xm2eMdx7kVvUrqcbt3t3JhGx9yfDvxR+yp+2V4efxJ4Ikgn1FVDXcMeLPVrNm/5+IlPzc8ByHjY/dY4r4v+LPw40/wZ8T9X8HXu7VdIiitkg+2IsgeIp5pBUjadryMOAORnFfY/xg/YW+F3j7xCvxJ+G91c/Cz4iW7GWHXNA/cb5T1NzbKVjlDc78FHfOGYjivnG78ceM/CvhZNK/bR8JPqWjs80+n/ABD8PRtJbbpDhTqEEa77TeFUFihhJK4UBd9c0ddYv5Fs+OvBukaf8O/2jtQ0XTIEtdM8X6WLi2hhUIguICNyqq4HG2RsAcbhX7Jr+0d4R8O+G2s/FYutH8RafaIHttTge386ZVClhJyuxm5ySDjnFfBfiXwX4M8LeD/gh+1FpOoHVLzS/Eli95GJIpo5NJ1CZrG4eBFAz5bNE+SxAweRX1L+0R4y1Hxjqmm/APw5ptlq/j7xTE00NjKouLXQdOPyyarqUi8nZnEMKlRJJhcuOa68XiVV5U1sZ06fLc4Hwv8AHHx5418WW3wL8DapbwjUi0mo6zaxiV9JguC85ELbijXU43eUGDCIHzWBARZPePHPwJ+BVpqXw403VPA+jarJBqM1vFcajZQXlyI4dNvbnc086u7HzY1ckn72D1rxyy/Yo0n4K2lhrPwg8UX2m6hFhLu6vJSxlnlAVrh3iClRI3D5VwA3ZFIr5q/aA8efF2T4i+DfhZ8SL9JJNNuLydvKEYMu6zYIWaIKGGx+AQDz8wz045KLfubGnqeq/sseDbO98TatL4V1d/CuuwlL0PCVe2u3KtEoubJiI5wVL5ddkyjhJUya+3vE3xv0H4S2EEnxzuLfw557GOC9gMlxaXjKMny0VWnjcD5mR0KrkBZZOTX5meHLWNLm81RH8owuqI4O0qIBnO7jGHZvpXP/ALQXhP40/tY6J4cn8IiKOPwfFcQjUrwlILtLwx5eR2O1SoiUIQC0uScY2s3ofUFdTrP3ettzF1b3Udz7P8R/G3TfH+uNceAru8Hw11M+XqWqWIMU+rXFuNskOmuxjZIgNsV1dDByvlwHzFeSP3vwZ44+H88DeKHu7Pw1oGjRJpmnW11JDZpbqqI8p2lgi8bEUA4Cpxwa/N39mX9lr4p638Ln8E6l4ybw/d+DtSvbG9sFEizLPPILnJICGOKWKWOWIkMWV8kKcgfenwu/ZG+F3gW3+2eIbBPE+tyPve6v8zhR2VUb5CB1yVyTXn1YwS0Zsrn5eeINRl8eeNr/AOJWnXZPie7lZnkVHkt7mIN8tvOVG0xqOI2B3R/w5G5W+ifgp8Q/Edh4ttbjwvoskmrofs91pUs6QvJ5gOF3AOpQkbkk4U7fYge2/Gv9nzS7LxXpWqeCbtLCfxTqC2v9nsmIUkdWd5kK8rGoXLLtOCeMDgeleA/2Zk8LXcPiu81j/iq7IEWV1BHmG33cOjoxBnjkHyup28HKFJAsi9dHGQjScJLcylTblc67/hPPivc20sV74Fv7SR0YI1rLaOVYjgkyTHIB9AK+bPCg8UeEPFdp4q8R+DNVW2tp3WRZPs8rXVyVdUWFVmdpZQ/zKACcqehqrd/8FBtAufivJ8D9L8Nu2vS3s2jw3hvY47QajbuY5i5kQOlupVyJdrPwP3JJxX2J4TsNE06VNa1nV4vEGveX5QktlMkNrEcZhtIEMhjQ4G5iWkkwPMdgqBeapCVP3Zxtexomnqj5F/ao8V2fj3wXZ+BviH4QntbLW7gyxWupRbVhFoVYSmeCQr5x3hcJIFRWYEuSpHqXwD1G41nwlF4T8EWVl4ZXQY4YBcWKKLZbbaVjX7MSVklOwjecYxkn+FvTPivZeFPHC+HvCes2VxMb6/3K4trhJYYoInlldG2AjdtWM9fvjI4yNjRPhv8AD3QNOSy8P6XcWlxESy3caTRXm4jBP2hwpwcDKM2w4wVI4qFOPI01qDTudzo8VvokIsbiH7PJI25pyxkWeQ8F2kPzbzwMPj0XIFbXmtcErAcRjgv6+y/1P5c5x86+JPD/AMSL/wASaZqkN3czaHa7FZ0Yb/LDEv5ltGxEwdflLD739xUwaj+PvxF8a/Dn4Raj4o+G/hmfxhdvtgitLFXndElyjSxw2/mSsI+m1M44OFAJrNUrtJPcbZ7ErqPD2izDg3M9rK3u8ziRj+LMTXbV5No/ia88TeBPCHiLU9Jk0O81I6dLc2D4Z7K4cAzWz7ed0L7o2yo5UggHivT5720tYJLq6mWGKFS7s52hVUZJOegArNoZaorO0rVtM1yxj1LSLlLu1lztkjOVJBwR9QeCK0akAooooAKKKKACiiigDlvHX/Ik+IP+wdd/+iWr+cyv6M/HX/Ik+IP+wdd/+iWr+cyvvuDPgqeq/U4MZugr+gn4G/8AJGPAv/YE0/8A9J0r+fav6Cfgb/yRjwL/ANgTT/8A0nStOMv4UPX9BYPdnqdFFFfnp6AUUUUAFFFFABX44ft2f8lui/7BNr/6HLX7H1+OH7dn/Jbov+wTa/8AoctfT8Jf738mc2K+A+Mq/RL/AIJ6/wDIy+Mf+vS1/wDRj1+dtfol/wAE9f8AkZfGP/Xpa/8Aox6+z4i/3Kp8vzRx4f40dT/wVK/5Ntsf+xhsv/RFzX88lf0N/wDBUr/k22x/7GGy/wDRFzX88lHBv+5fNnXW3LFpd3dhdQ31jM9tc27iSOWNijo6nIZWGCCDyCOldl/wtH4mf9Dbq/8A4H3H/wAXXC0V9PKnF7oyud1/wtH4mf8AQ26v/wCB9x/8XR/wtH4mf9Dbq/8A4H3H/wAXXC0UvYw7ILs7r/haPxM/6G3V/wDwPuP/AIuj/haPxM/6G3V//A+4/wDi64Wij2MOyC7O6/4Wj8TP+ht1f/wPuP8A4uj/AIWj8TP+ht1f/wAD7j/4uuFoo9jDsguzuv8AhaPxM/6G3V//AAPuP/i6P+Fo/Ez/AKG3V/8AwPuP/i64Wij2MOyC7O6/4Wj8TP8AobdX/wDA+4/+Lr+jT/gn9quqa3+yp4R1LWbya/u5ZdSDzXEjSyNtvpwMu5JOAABz0r+ZGv6X/wDgnX/yaP4O/wCu2p/+l89fIcaU4rCRaX2l+TNqL1PzU/4Ksf8AJxOgf9ivaf8Apbe1+Zdfpp/wVY/5OJ0D/sV7T/0tva/Muvb4f/3Kl6GdT4mfq7/wSa/5Kr41/wCwLH/6UpX7v1+EH/BJr/kqvjX/ALAsf/pSlfu/X51xf/v0vRfkdNH4Qooor5g0CiiigAooooAKKKKACiiigD+Q740f8li8d/8AYe1T/wBKpK80r0v40f8AJYvHf/Ye1T/0qkrzSv37D/w4+iOB7n9In/BNb/k1bR/+whqP/o4198V8D/8ABNb/AJNW0f8A7CGo/wDo4198V+K53/vlX/E/zO2GyCiiivLKCiiigAooooA/GH/grv1+FH/cd/8AbCvxhr9nv+Cu/X4Uf9x3/wBsK/GGv2PhX/cKfz/9KZyVviPvL/gm1/ydZoP/AF46l/6TtX9JVfza/wDBNr/k6zQf+vHUv/Sdq/pKr4vjX/e1/hX5s2o7BX86/wDwU0+Gv/CGftCf8JfaRbLHxrYxXmQML9qtx9nnUe+Fjc+71/RRX5t/8FPvhr/wlvwEtfHFpFvvPBV/HOzAZItLwiCYDv8A6wwsfQKa4uFsZ7HGRvtLT79vxsOqro/nnr9Y/wDglL8S/wCyPiF4o+Fd7LiDxDZpf2qsePtNicOqj1eKQsfaOvycr134CfEeT4SfGXwh8RFcpDo2oRPc7eptJD5Vyo92hdx+NfqGb4P2+GnS6taeu6/E5YOzuf1v1+D/APwVX+Jn9tfEnw18LbKXdb+GrJr26UHj7VfEbVYeqQxqw9pDX7sNd2qWhv2mQWwTzTLuGzZjdu3dMY5z6V/JF8c/iLN8Wvi/4t+IsrM0et6hNLAG6raqfLt0P+7CqL+Ffn3BeD58S6r2ivxen5XOis9LHlFff3/BNz4Z/wDCd/tHWXiG7i8zT/BlrLqbkj5TcH9zbr/vB3Mi/wDXOvgGv6CP+CXHwz/4Rb4I6l8QruLZd+M79jGxHJs7DdDH/wCRjMfcYr7TibGexwc2t3ovn/wLmNJXkdR/wUt+Gf8Awm/7O8viq0i33/gq8ivwQMsbaY+RcKPYb0kb2jr+c+v7GvF/hjTPGvhTWfB+spvsNcs7iynHX91cRmNse+G4r+Qbxb4a1PwZ4p1jwhrKeXf6JeT2VwvpLbyGN8e2VOK8fgjGc1GVB/Zd/k/+D+Zdda3Nj4ZeOL74afEPw34/03Jn8P39veBQcb1hcM8Z9nXKn2Nf156TqlhrmlWetaXKJ7LUIY7iCRejxSqHRh7FSDX8adf0t/8ABPT4mf8ACxP2aNCsrqXzNQ8JSSaNPk87LfD2/HoIHjUH1U/QZ8cYO9OFddNH8/6/EKD6HdftpfEv/hVn7N3jHXLeXytQ1G2/sqzwcN59/wDuSyn+9HGXkH+7X8tVfsZ/wVi+Jfn6r4M+ENlLlLSOTWbxAcjfKWgts+hVVmOPRh+P4516PB+D9nhOd7yd/lsv68yazuzT0TR9Q8Q6zYaBpMRnvtTuIrWCMdXlmcIij6sQK/r4+Hng3T/h34D8PeBNKx9l0Cwt7JCBjf5EYQufdiCx9zX87X/BO/4a/wDCwf2l9E1C5i8yw8IxS6xNkceZDiO359RPIjj2U1/StXz/ABxjL1IUF0V38/6/E0oLS4UUUV8KbhRRRQAUUUUAFFFFABRRRQB//9T9/KKKKACiiigAooooAKKKKACiiigANcBqtl4zm8aaZd2V3FH4fiU+fCQu4uVcZzjdk5GMMAOcj17+vnqf9oj4eXfx3f8AZtSS6XxQLb7TIfKH2cr5K3BiEgbcGMTBi2zbjgNv4GlODd7LYLo9knjF+6PjFpBKhUf89ZFcfMf9lT09W56AE6M0DrJ9qtv9YBhl6B1HY+47H+lRTMIraa2xjy4mKY4yoHb6dPy9a0ahlnIa3o7eJPDsSWEwttQttk9nOwyIbmMEKWHUoclJVBBaNnXIzmk8La9b+LdFS4kia1uoHaK4gZsy21zCSkkZYYyyMCNw4dcOMo4z0FrGVt4ZoupjTcv97gc/Ufr0PYjwHV/HnhTw746fxRoOrW9zYXjxWevRI4xbTgiG3vSeBtB221w3OAYXcqkLZuKvogN74ieMI/hPDN4jm3SQXwfzYYk3F5FTi4RR91k480dHXDL842N4V8MDo/xuvvDXj3xFewxeAfBccK+HLGeRU/tLUYE8uXV50Yj5I2DJZqw5+ab+JK9C+JOjaT+0aU8GeHrtLnw3pwaTVdStZQyzPImU0yF1JX94NrXR6pFtQfNKWj7Lw/Z6T8K9M02PTIdngi8SMpuAP9myzYIYntBKzZbtG5zwjfJqrKPmFzd+JFv4D+IfgPX/AAHrOtWUdtrtlPaM/wBoj3RtIhCyL833o2w6nsQK+bPhx8SdL+JvwRtvEOqa7baX8QvDplstTiEyFpdY0gmIsYiwLGbaGR152SBSWXKn7e+yWjcmGM5/2RX51Q3emfDX9tvVfAJkSHwl8aLVbxMJiNde0qPbdW0bnAUzwlHlIJJYhBhjkFGzTXzBntnwp+MF74w+JUmneMLGPT9TlsTHaJGxEaKr75Nu4nf5p2/Op42KpUE19ZV53cfCjwDcQzxjSUikm6TIzCaI9jE5JKfRcA9CCOK808QeJNU+EECt4p1GZdOdvLtL6GIXEU0mCywT2hKmOQgHDQOkbYyQnSoqcsn7gK/U+j65qB/M8YXsZ/5d7C1I/wC20s+f/RYrx/Qfj9p19oN9r2paZKlrpyb5poSu1Ac7WlSRlaMNjG4F0H8TCvz1+In/AAVB0Dwn4l1ew+H/AIaXxb4j1NLe0skt7h5bSN4Wk2hmSMNOSZCQsXB6bgauOFqO6sLmRJ/wUh8UaVY/EzwloclnELiDTTeSXBQGTFxM8KBWP3QPKYNgjcCN2dq4/Mfxfq2irbNPdOqSEfKQcOfy5NfRnjn9nr/goN+0xbal8bviBoax3NvaqlnpM7RWN49qrFvJtbTGV27mbE7JI3OCzEA/nbL4e+LuseNj8LNM8HavN4yLGFtKNnN9vRgu8mSJlDqAuGLMAoX5idvNfVYPN4UMP7CybOGrh3KfMfUHwY8f/tM/FbTrz4U/C/XI7ex0HDJe3sredY21yxAggHz7VZlYgLGSCeGUYFfpR8KP+CUPgbUBa+Nf2jPFer+Ntfvo45ri181rSFWZR+7lkLSXEhUcZEkf0r0T9hP9kzXv2WPhkPEfxEMf/CceLdWsJdQijZZEsrf57a3tfMGQzqbh2kZTt3MFBIQM36H+MvHXhfwFpv8Aafia9W3VztiiHzzTP/dijHzMfpwO5Ar5mriG37p2Rjbc/GX40/sf/Au/8PXHwoiji8CeMvB9y/8AZmr2FkJYtRs7kCWNdSWMh3ZQR+8yXTPG8blP5K+IPg38SNA+KGk/ByfUrCW5127gtbPUonn+wTpdXBtUnRpIUlMYkVgx8vPynANftj45tvGPirxlqfjb+w72x8Oa/qBjjmmx5ksrcLbjacqcDB+m1ScEj5J/ar8Nr4S+N3wW1O5BtdVtryOzu7R12Pam01COeJcdCjJcbkZcq2TgnBr1MvhGW8nfXQye+x+lv7Iv7D3gn9lVIILm6XxP4w8QxTSarqMkQSLyYkCfZbeNt22ANLlsnMhAZsAKq+4/EL9jH9lz4nRTjxV8N9IFxODuubKAafc7j/EZbTynLDtuJ/LivamkM3xAhh7Wmlyt/wCBE6D/ANo12deE5yve5s0fjun/AATK+GOjeK/sngPxr4g+Hfiq3zLY3dtOJre4hU5Dw/6qdZE/5aJ55x94cdPy/wDGl7rXi7WbrUta1WfVvEWl7knvLti9xPLGfKPmFiTnCYwScdOlf07/ABhtrdvA93qJXbeae8UtpMrbJIZjIqh0b1API7jiv56P2kv2aPiFb+M9U+Ifw7u4b+116aS7v9PlmjtZBcNl5GiZysbLIcnZuUhjhQQQB9Jkuayp3dRXW3ocWKo89knqfC3irXW1RglghiKfekzjDjsvrj1r+k3/AIJ7ePdHvvgb4a8L3qPb6/dW7XszuBi8duGkB6lyqqWB5PUZGcfzwfBf4W6v8X9RurK6u49JtNOcC6dvnly+doSMYyflOckAe/SvtfwD4g/aC/ZS1yy8QaZpcvxA8IaAwuZILXe7Q2qHDnKq8luu04JKvEM+pzVY2H1nmqTdmOmuT3Uf0mV+QH7Y3hax+Cn7ZHwl/aae3X/hG/GE6+GfEm4fusyoYEllPc/Z33L6fZgRzivrD4L/ALfH7N/xssI5NF159G1PaDNp+pxGG4iPfJTfGy/7Qcj6HirX7X/hPwV8f/2bvFPgvTtTtdR1C7hFxo32aRbiR9Ttj5tukYjLHMjDymwDhXbNfO0k4StJHUeg+LvGevfCu1l0S7D61b3sMv8AZlwXAuIiuAUnJ+8E3Aq45PQ88159q/xK1HxB8Gdc0Xwhpf2FNJ0aS2vLm8ZWjhBgaJFiRTmRnA43BQO+axvgDf3/AO1B+z34H+Imu6gtrqQsRayKieYwu7U/Zrtp921t0ksJYKMbQRy2c15B8Xviz8P/AIUfDTUvA+iainiLxh4vgi3aVaAtdxSRuC5dl3RxwRruDtIVKnkbshRaprRdbiu7nw9+014J0z4F/B34d6x4KivNK0Xx7Fdr4g8m4lFjd3lvIktsHtwfJjYr5jAIqh9mSCUzWJ/wTj+MPijwf8YPGk/hjwbqni/wtdaXCdWOiWsVxc2s0cwFpLh3jd12tMDHGWdvvBG2HH62fAP4a+DviP8AB/Sz8U/7O8dzS2ohk0+4ijudO06MsWEMNvIGG88M07jzJDyCsYSNMn4UeC/DX7N/7S+u/C7wlpdvofgv4oaZHrej21tGIreDVdIVLbULeNV/56wPDPj/AGXxXbPMJOi8O1onfzIVJc/OfQHhH43fCP4lzSeGtL1qJdVmjZZtG1KKTTtTCMMMHsbxIrjHUE7NvvX5E/to674e8FftLeDf7U1u3eTS7PUFvmeZN0cfkRCzaZiflkeMmPaeSU39HFftx4k8I+FfGVj/AGX4u0ay1uzB3CG+t47mMN6hZFYZ96/l4/bH+AHxd8B/GzxD4Wk0ZtS0/Vft+tafewnzo10hJd0k8yoWkjW2V1E25eApZcrgnmwcKcubmdtNPUqbfRH094K8Q6h46i06xgspru3uvnttNiUtcajLId5mmXBKW+45RDzIPmYbcIf2B+BPwlvvCHh2HU/GpE+uXUhufIBzBZkgKqovQyBR8znkEkLgdfkv9hW98W/D/wCEFw8vg2bxJC984k1HTJLY3rgW8BVWgmeMsg5bIlP3uEzmvuXR/jh8MNW1OPQZtaXRtZlxt07V4pdKvX/65wXiRPIB03RhlPYmqxOKqSj7PoKNNJ3Oe8ZWf/CvviXpnxWsx5ela8tvoXiFRwo3SEabekesM0jW8h/55zhmO2EV7zWVq+k6T4m0W90PV4EvdN1SCS3niblJYZlKOpx2ZSRxXLfD6+1NNMm8L+IrhrnV/Dri1mnk+/dQgZt7s9MmaLBkIAUTCVF4SuBu6NDzjVrv/hJf2jdD0VDvg8I6Vc30noJ7vEIB9wjKR9TXVav4ok8WX+oaD4euzZaJo5dNa1eNtuxo+ZLO1kH/AC1A4nlH+pHyKfOJMPyJ8Kte8UfGj4ofEWXwRcSafpF3fJaanr8RxJb20OcWNi3e7lj8vfKOLZBn/Wsm37HtNG0dLix+Hvhq0js/D/h1ImuIohiPcvzQW/v/AM9ZM5J+Xdnea0nG2gHgM/7GHwU1/Wrj4q6PoTeC/Hl063OnatpkkkE+mvGAInW23fZmdlH79XiIkDujkg5r2j4d/EDXbnUn+HXxPtodM8a2MRlDQAiy1e2QhTe2JYk7ckedAxMkDEBtyNHJJ7LXzl+0L4++FXhfwvayeObp/tQufM06Swdft9rdxLxPA3JRkDYOQVZWKOrRs6mVJvRgdhDeprHxkvyzj7L4S0lI3LHCpcai4lY/hFCvPoxr0OIvrBErqUseqKRhpv8AaYdk9B/F344PwN+z18d/AupQeJdf+LfijT9Eu9Q1NrhPt0sVlHeRRqscDMHcgMgGfIDHBO4FgBt+3V8W2+st9n8OGWaM8PdrBI0Se0ZK7Xc9udq9WJwEaqlNp6oVzqLi82y/ZLVfNuCASv8ACinoznsD2HU844BIyLzR4of9OgkMV7NLD5kqjAkO9QAydCAOncDo2SScnxFd61ofhe8n8L6bJLfoAy+aFlLMxAZ2CuWdgvOPYDoMVkeFdX8Q6zpOi3HjCE2N9NcSL5ao0IdRHLtY5JILY+7keuMEVCi7XGee/F74jaf8OtY0Rb22knk1C6W4uUt9pQx2hQNMNxGJMMoKd1x83ygN9AyQWmuaa0V0BPZ3sWCgyA0cg9eDyD7Vi32haD4mvY01TTre9ttJf9150SSATkfMV3A42DAOOCSc8rVmC3l0GcW9sN2nSnEcZP8AqGP8CE9EP8KngH5QQNq021ZW3EWvD+h6X4c05dK0eAW9vEznbkscsckkkkknNbVVYJUklkEZyCFb0IJyCCD06VaqHuMKKKKQBRRRQAUUUUAct46/5EnxB/2Drv8A9EtX85lf0Z+Ov+RJ8Qf9g67/APRLV/OZX33BnwVPVfqcGM3QV9I+H/2s/jh4Y0LT/DmjazDFYaXbxW0CGzt3KxQqEQFmQk4A6k5r5uor6+vhqdVWqRT9Vc5Iya2Pqn/htD9oL/oOwf8AgDbf/G6P+G0P2gv+g7B/4A23/wAbr5Worm/snC/8+o/civay7n1T/wANoftBf9B2D/wBtv8A43R/w2h+0F/0HYP/AABtv/jdfK1FH9k4X/n1H7kHtZdz6p/4bQ/aC/6DsH/gDbf/ABuj/htD9oL/AKDsH/gDbf8Axuvlaij+ycL/AM+o/cg9rLufVP8Aw2h+0F/0HYP/AABtv/jdeH/EL4jeLPijr48TeM7pbvUFhSAOkSRDy4ySo2oAOrHnFcNRWtHAUKb5qcEn5ITqSejYV+iX/BPX/kZfGP8A16Wv/ox6/O2v0S/4J6/8jL4x/wCvS1/9GPXBxF/uVT5fmjTD/Gjqf+CpX/Jttj/2MNl/6Iua/nkr+hv/AIKlf8m22P8A2MNl/wCiLmv55KODf9y+bOutueqfAzwvo3jb4zeBvB3iKE3Gl63rVhZ3Uau0ZeGedEdQykMpKk8ggiv6Af8Ah3H+yb/0K91/4Mrz/wCO1+D/AOzB/wAnHfDD/sZNK/8ASqOv6x68njHHVqVWCpTa06O3UqjFNanwx/w7j/ZN/wChXuv/AAZXn/x2j/h3H+yb/wBCvdf+DK8/+O19z0V8d/bOL/5+y+9m3Iux8Mf8O4/2Tf8AoV7r/wAGV5/8do/4dx/sm/8AQr3X/gyvP/jtfc9FH9s4v/n7L72HIux8Mf8ADuP9k3/oV7r/AMGV5/8AHaP+Hcf7Jv8A0K91/wCDK8/+O19z0Uf2zi/+fsvvYci7Hwx/w7j/AGTf+hXuv/Blef8Ax2j/AIdx/sm/9Cvdf+DK8/8Ajtfc9FH9s4v/AJ+y+9hyLsfDH/DuP9k3/oV7r/wZXn/x2vqn4ZfDPwf8IPBlj4A8CWj2Wi6c0rQxPK8zKZ5GlfLyFmOXYnk8dK76isMRmFerHlqzbXm2xqKWx/Pv/wAFWP8Ak4nQP+xXtP8A0tva/Muv09/4Kt2sqfH7w3eEHypvDNuintujvbssPwDD86/MKv1/h7/cqXocdT4mfq7/AMEmv+Sq+Nf+wLH/AOlKV+79fgT/AMEpdasbL42+JtFuZBHcaloTmAE43tBcRMyj1O1i2PQE9q/favzvi9f7dL0X5HRR+EKKKK+YNQooooAKKKKACiiigAooooA/kO+NH/JYvHf/AGHtU/8ASqSvNK9V+OtpLY/G74hWU4KyQeIdWRgfVbuQV5VX79hv4cfRHA9z+kT/AIJrf8mraP8A9hDUf/Rxr74r88P+CY2tWGpfsyxabbSBrjSdXvoZ0z8ytIUmUkehWQYP19DX6H1+LZ4rYyrf+ZnZDZBRRRXlFhRRRQAUUUUAfjD/AMFd+vwo/wC47/7YV+MNfsV/wVy1azm1r4ZaEkgN3Z2+rXMiZ5Edy9skZI9CYXA+hr8da/ZOFlbAU7+f5s46vxH3l/wTa/5Os0H/AK8dS/8ASdq/pKr+b7/gmnay3H7U+lTRglbbTdRkf2UxbP5sK/pBr4rjV/7Yv8K/Nm9HYK434i+DNP8AiL4C8Q+A9Ux9l1+wuLJ2Izs8+MoHHupIYe4FdlRXyUJuLUlujU/jW1rSNQ8P6xf6Dq0RgvtNnltp4z1SWFyjqfowIrMr7k/4KH/DX/hXv7TGt39tF5dh4tii1mHA48yfKXHPqZ43c+zCvhuv3jBYlVqMKq6q5wSVnY/YWf8Ab18FSfsUf8K+XULj/hZTaQNAa38iXHl4+zG6+0bfL5tvm+9v8z+HHzV+PVFFZYDLaWG5vZ/ad3/XYcpN7mhpOl32uapZ6LpcRnvdQmjt4I16vLKwRFHuWIFf15/DLwPY/DT4d+G/AGm4MGgWFvZhgMeY0KBXkPu7ZY+5r+dz/gnp8M/+FiftL6FeXUXmaf4Sjk1qfI432+Et+fUTvGwHopr+lyvheOMZepCgumr+f9fib0FpcK/nM/4KV/DP/hB/2ip/FFpFssPGlnFqCkDCi5iHkXCj3JRZG95K/ozr81v+CoPwz/4S34E2Xj20i33ngq/SV2AyRZ3pWCUDv/rPJY+gU143C2M9jjI32lp9+34l1Y3R/PZX6H/8E+f2nPBvwA8U+JtI+Jd/Jp/hvxDbRSLOsMtwIry1Y7Mxwq7gSJI4JVTyFzxyPzwor9Xx2ChiKUqNTZnJGVnc92/aX+LKfG343+KviLal/wCz9QuRHYrINrLZ26iGDK/wlkUMw7MxrwmipYIJrqeO2tkMssrBERRlmZjgAAdSTW1GlGnBQjslYG7n7y/8Eqvhr/YXwr8RfE68i23Him+FrbsR1tNPBG5T6NNJIp/3BX6pV5Z8EPh5D8J/hF4S+HcShX0TT4IZyvRrkrvuHH+/Kzt+Nep1+I5tjPb4mdXo3p6dPwO2CsrBRRRXnFBRRRQAUUUUAFFFFABRRRQB/9X9/KKKKACiiigAooooAKKKKACiiigArnrrQNEi1ZvFsWm2/wDbKwiBrtYU+0vbA7jCZQN5TPzBM43AGuhooApTxLdQgxsAeGRhyM44PuCOD6g1naPfi40SC5bh44V8wHqrBATn+Y9QQe9WLI+RPNpjceVh4veJugH+4crgdBt9a8F+LOo+ItN8PxL4UuJLaae6nguTAoeQoZXMUYBBwTzjGDj2zWtOm5PlRTlpc9/80WlpEu0u5VVRB1ZsdP8AE9hzX5d/tAfs8eJ4fCWs/D74TajLr/iS7hW7Nig+zpa6ekm9vtVz5nJmKGKFNoaUhjt2JIV+yPD3jrxw3hnStJl05tR8a6lbNIjt5XkW1p5hVbq4RZEZVwAQg2tNINqlVDNH6F4Xt9B8F6fLamO/kvLuQ3F9e3FrLJNd3LABpppIozHnACqq4REVURVRVUa0as6UuaL1JlFNWZ+Z37BXwX/ab+G+geLPFV5eaZo8evXiw22h3sgvInm09pYppXuLOSRIS5+UNGJd6oCeNhP1jbfGXx54L0q80L4mfD24m06xkmtJ7zThJf2ZQncE8uCOeVYxE65e4SFcdeM42PAPj3wxoHibx/olzq1tDo0XiRo0DSrHJaS3djZXvmBXIPktLcEE4xG4yflLFJNV+N1lomva7b6NCZW1BoEjunwLVLlB5EkpwSxiCqhBAydvpzVVakpycp6t6gkkrI8S0v8Aau0xJZfh/wDDyUa1YhUeK7W9t5ptMtWJV4GaF50kkQgrFuYMo4cfLz5z+3v4q8Dw/CTwVqHga8/s3xv4T1Kx1/w4HwJ32t+9DqW8wK+d7Oy7HePG8nNfSvjL9m79mXxtNa6z47ns5vEUWWuNXhvls724dzuYvNE6uAD90AjaOM4r+fnxp4xtn8deILDUNSmvZNPvZ7KN7u5e7mWC0cwwxtM5Zn2Roqgk9BXsZNg6NepacuW2vqYYirKCulc/oh+C3x7039ozQ0vfCPiuw0i/it4pr/S4ITLqNkzgbwzXO1Cqsdu9YXjJ6Oe/x9+1L8bPhQ8lv4K+Gusax8TviDZXaP5NlI19aRA5jZJnj228RJYcwozBgFYKDX48eFNe8NyfE/wrpuoTSy6fq+q2NjfwW800D3Fhc3CJcxF4SrhWjLA4PvzX7g6l4p0HwcLDwJ8DPC2m+GvClvcJeiS3gK3Fz9iIMU0hbBciV0dBKGYlRuPUVlXwdOjVaV5Jf1qzSnU5o3eh4bp37IXx7+O+oQaF8Z/Eg8JaPhJbzRNJdZZIYjyguXUtAJD1jUmZu5CLzX1V8Lv2LPCvwG8TRXXwyuLUX6xPLbXOoWgkvGwdkoa6DHGA64HlbfmJCgjNfavg3StJ0rw7aLo5eSG6QXLTSndNPJMAzSyseS7dz+A4AFU/Hl9b6Hof/CVXEqQLoci3bM7BQYhlZlye7Rs20f3tveuDEZhUqOzehcaaitDzq58XfGvwzltW8HReILZODJpl0plx67ZAhY+wjFfj14x+KJ8Jf8FOofihDo91pb3ukI1xZ6nE1vJn7A1oc7d3GIgVbpxz3r9tx4l8R+Ko1/4QayFvYzAEapqCMkZVhw0FtlZZeOQXMaHqCwr8vv2hfg9Pd/8ABQD4NR3muTyyeKNC1SK6v7kIcf2dFc3D7EUIiKEcBVGAOpJOSYw0kpe8gntofX/jv49J4w+HkL+CLVUvLyWLdPM6yR281vKkpCKhDSkbQcnYvIyd2VpPANno/wAR9baOD7S2rCPzNV1TUHR71oi2BBZKnyQxtnBZFUqpxzkZgu/h74YbQJJ/hzZD+y/D0M73epy4QX0i/M5jCr+8KAN83C/wjOBXo/wq+FmveHLu48VXFzHZ3lzAIoYsecvluVdvNAK9Sq4CsCO57UVIwUbwfyIUnezJfjxpdlZeEfCemafCsFtbeINMSONBhVXcygD86+Ef+Cp9h4cvtK+Hms6Xe2n/AAl2g63EWgVka7SwlQyGV0HzeUkkaYyMZY46mvqL9sX4m33w7+D8vibVtONteaNf2l1bS586zmmiYmNTIAGXLYyHVeMhS1fgnrnjW81uK98WeI719V1PUpDNNPI255pZOSSf8gDoO1e5w7lqrSdSUrKP4nNjMS6aSSvc/ff9nT9ofwv8YvF+uQzahZf27aWlla+XbTCSGcxmeR3hOc87g2w/MOeoBI+s9c13TPDmmy6rq8wht4sDplmY/dRFHLMx4AHJr+MfR/ix4j+GfxAtfHOiTm2kgnRpVjZl3xZAK5BzkAZU9mAI5Ffs98KP2i7nx5e2vjjVvH5vNkmyK2e5SVrRX+VpRFMGCS45Vtgxwcdq8utgL1ZRpvRG6q6Js/S3XPGssOoxfbtMk1rxNcoW03w/CQ32WJxjzrx+UjZgcMzcKDtUH5ied0L9mzR9c1B/FPxYit9R1GX5obC0Uw2NlnoI9uGdh/eJx9cA10Wi/Ej4I+BrSS20O/8AOluG8yeZYpp57iQ9XlmZcux9S3HbArfg+MltqnHh7wxrOpA9HW2CRf8AfbNgfiK4byWkTU/F79ln4X+EtK/aB/aH8IeMdDvdV0zwzrarHdWMrJdWluLm9CSGJMCRHQoX4O3AIHWv0a+EvxL+Evwqv/Fvh37XHMiXcdxp1xAjTT3NhcIGSMnGf3DBlbftwTjr18R+B0fjTRf2+/jvFpegw2M3iPStG1PyL252iNPLRGcmFH3FpC5wMYzzzTP2iPCV/wDD34s6B461eztLO018tZXP2FWS2+fG373O5XG9zgZ6969GC9tJwk90hN2Vyf44/syfs4ftG30WufCLTLnw/wDEa4bzl1PRkNikLA8y30RURvyclkCyMePM6A/OupfDD4s/sx3M+qfH7TLzXNJjwlp418MFZ0ty+FjivbGUwvDvchfNR0TcQvzk5H2h8JZPF/hnxLc+KPDGhz6zYQRG3u44jg7ZCGG3qWYFc4AP4ZzWr+15dD49fs1eKvC/w8Mp8U2X2e/TSZVMd3P9jmWWWFI/+Wj+WGKqm4swUdTWMW4TUJ7X1E3pdH4taJ+1V8f/AIJaT4ktfhnq6aboOvX93fm3lRbkwTX2BI0bOAUJI3Db0bmvWv2StQ8N+JPDN/q6b5/EzXBGq3Fw3mTyMxLRndgYiIyFUAAEHjPJ/OjXfHFteaZNpk7bXPysp4YMp7jrkEd6+mv2NdF+M9jBr3jXwn4MvfE2jTNbw3MVlFI90VTeyywKF2PjLDaWUt/D3z7GPeGVVOhtY5aXO4+9ufrf8Lta1f4cePdO1fw4klzZX8yW97YR8mRJm2lol/vgkMF6EjjBJz9W/tCrF4j+GemfGXwJ/wATDV/hrfxeJLMQ/wCtmgtVZNRtMcMGnsnnj2dd+3I4FfOX7O/gfQ/jlZahqtzqjWdrprNbXFnE4h1S1ux/DcQODJbshBO2RAW7Dbye28R/BT9of4VXd14n+DHic+IIJctdaZebS1yg6jbNujLgfxKyk9MckHzMdVpzqJx0N6MWlqfd2k6pp+uaXZ63pM63VjqEMdxbyocrJFKodHU+jKQRXwv8Unt5v2s9bv7hVki8PfCXU3G7BAlv9QCqDnuywEAd814p+z9+1jrnw58NzfCnxd4YbHg+Z7W3jLPbXENg5MlrGY5A4Kwofs68jiLv1PzUvjnXvjB8f/HPjfxBINy2emWcEScRwxRyXR8tR3C+p5JJJ61xwotSaNGz7l/YV1Q+DdK1T4YXqGPTby9mutDnY5UhIYvPsSezQrteEE5eLcAP3LmvvfxF4Z8N+L9Kl0LxXpVrrOmz48y2vYEuIXx0zHIGU4+lfkbaW2pWBhvtDvH07ULOWO5tZ4+TFPEco5Xow7Mp4ZSynKsQftzwt+2B8LNZ8MWDzXy3/jOf/R5PDulD7ZqL3iFldYYlI/dZUt50jLEikGR1Fb4rBVI+/YiNVN2Ni9/Zui0KR734OeLtU8ETk7jaGRtR0tz6NbzuJo09EtriBfavyx/a9/a5+Pfwo1268Dy6pptte3WnPZHVdFEjR6lBLJtcQSTqzQy27b0xvmaF2fEmWwP1G8Z3HjSXwPq/xA+Kxj03SbGAyQeGbCcukrsQsS6leptafczKHgh2wAFlc3C4NfnndXNz44nN94pKXo2GNY3RfIiixt8qKP7iRhflCKAoHGKWDl79mk/Uc9jr/AuifHnw5+z94a0Xw94J0XSPDFzNPcu767cF5WkIWMyxRWDjohOTM28ncSDivdfgto37RF14d1No/FGheFdEt7jJb7PNfDzNg8z5ne2ZVA2dGX2718qeAfEPxO+F5EnwvuZ77wx5jJZaXIPtL2cr/IbixjcMGXBZViIJCk+Xn5Y6+rvB3wXj8Ya7pfjP4ieL5PFOkeLNxCWUrJapfwjGxyQpVmVXRlCRsrptPPFa4ug6ekkKEr6o6a58YTwXw0ZfGVr421U9LfRtDubxyfUPeajdQKM9SvA64r5y/aU8DfEbWtS8PeIfiBLf2GmrC9vZx7rKQQOW3OH8i2REMi7SEJY4X7xxx+pvhzwn4a8IWI07wzpsGm2/GVhQKWI7u33mPuxJrlfi08c3gybQiqvL4gnt9LiDAH5ruRY2YZ6FELOD225rgjVtJNFtH4ea1+z74p+Ntjp/hb4eaokXiDS/tIkiuim2ZG2s7xjKDftAZR3HBI25r9S/2fvGGmfCbwX4a+B/jmaazufD9nDY2t/extbC6WMbV86OQt5D54GHkgPyhJi7CMU/2gfBMPw5v/Dnxu8BafDYv4amjt9Qgto1iSS0kfCMQgA+VnMbHGdspJOFr6ma28LfELw3a3N7aQatpWpQpPGs8ayKVkXIODnDYPbkGurGY2VZR5tl+BFOmo7HU1xviS/a01OxtoFWW6vIbiG3jcZUys0XLD+6i7nbvtDY5rgtW0LxB8J/DWpax4BupNQ0nS7Wa4Gi3zNOEWGMsEs5yfNQcYEcjSJjCp5YHPyB+yl+1na/HX4l6n/ac7Xctpp37hfs4RokaUlmhjhLlg/yg7gXGB23Z5qdCUk5R2RTklofo1YaaNKtIrSzkLpGOfMOS7HlmLddzHJPbJ6VbYxTo1vcJjeMFW7/AEPes9dXefmzsLmZOm5kEIB9CsxR/wAQpFTltRdCbhYLdFGSdzSgj3yI8Y9eawKMvU5NQsoZHsoxcX8cMwtw52rM4Teiueg5XaT75GMkDK+HOqeM9Y8NR3vjzT003VDI4MUY2goMYYqWcg5yMZ6DPevnb9p34XfFH4pWvhK4+F/i678PXHhzVUu544RgXS8NxiSPDJtwu8sMSHI9fr63MzQRtcqFmKguF5AbHIHtmtZJKK8/wF1JqKKKxGFFFFABRRRQBy3jr/kSfEH/AGDrv/0S1fzmV/Rn46/5EnxB/wBg67/9EtX85lffcGfBU9V+pwYzdBX6F+Bf2Fbbxn4K0Hxc3jR7Q61Y294YRp4fy/PjD7N32hd2M4zgZ9K/PSv6Cfgb/wAkY8C/9gTT/wD0nSvQ4mzCth6cJUZWbfl+pnhqak3c+LP+Hd9r/wBD4/8A4LR/8k0f8O77X/ofH/8ABaP/AJJr9JqK+O/1kxv/AD8/Bf5Hb9Xh2PzZ/wCHd9r/AND4/wD4LR/8k0f8O77X/ofH/wDBaP8A5Jr9JqKP9ZMb/wA/PwX+QfV4dj82f+Hd9r/0Pj/+C0f/ACTR/wAO77X/AKHx/wDwWj/5Jr9JqKP9ZMb/AM/PwX+QfV4dj82f+Hd9r/0Pj/8AgtH/AMk18ZfHn4Rp8FfHC+DY9UOrhrSK688w+R/rWcbdu9+m3rnv0r986/HD9uz/AJLdF/2CbX/0OWvd4dzjE18RyVZ3Vn0RhiKMYxukfGVfol/wT1/5GXxj/wBelr/6Mevztr9Ev+Cev/Iy+Mf+vS1/9GPX0HEX+5VPl+aOfD/Gjqf+CpX/ACbbY/8AYw2X/oi5r+eSv6G/+CpX/Jttj/2MNl/6Iua/nko4N/3L5s66257r+zB/ycd8MP8AsZNK/wDSqOv6x6/k4/Zg/wCTjvhh/wBjJpX/AKVR1/WPXz3HP8an6fqaUNgooor4Y2CiiigAooooAKKKKACiiigD8jv+CrvwzutV8HeEfitp8JddBuJdOvSoyRDebWhdvRVkjK/WQV+Glf2HePfA/h34leDNY8B+LLf7VpOt2721wnRgrdGQ84dGwyN2YA9q/lu/aI/Z58bfs6eO7jwn4ohabT5md9N1FVIgvbcHhlPQSKCBJHnKn1Uqx/TuDc0jKl9Wk/ejt5r/AIBzVoa3PK/BPjXxR8OvFWm+NfBl++mazpMomt7iPBKtggggghlZSVZSCGUkEEGv1L8Of8FavGlnpsUHiv4f2OqXqKA89pfSWaOR38t4p8Z74bFfkXRX02OyrD4mzrQvb+uhlGbWx+yn/D3S9/6JbH/4OT/8h0f8PdL3/olsf/g5P/yHX410V5/+q2A/59/i/wDMr2sj9lP+Hul7/wBEtj/8HJ/+Q6P+Hul7/wBEtj/8HJ/+Q6/Guij/AFWwH/Pv8X/mHtZH7Kf8PdL3/olsf/g5P/yHR/w90vf+iWx/+Dk//IdfjXRR/qtgP+ff4v8AzD2sj9lP+Hul7/0S2P8A8HJ/+Q6P+Hul7/0S2P8A8HJ/+Q6/Guij/VbAf8+/xf8AmHtZH7Mwf8FcL2eeOH/hV0Y8xguf7ZPGTj/nzr9o6/jOsP8Aj+t/+uifzFf2Y18bxbldDDez9hG1731fS3ds2pSb3P5pv+Chnwzuvh9+0truprCU03xcser2z4+UtKNlwM9NwnV2I6gMp7ivhyv6hv2xf2aLP9pP4ZnS7Ax23irQ2e50i4k4UyMAJLeRu0cwABP8LBW5AIP8y3ibwz4g8G69feF/FWnzaXq2mymG4tp1KSRuvYg9j1BHBGCCQQa+u4ZzSOIw8YN+9HR/o/66mVWNmeyfs+/tK/Er9m/xFca14EnimtNQCLfafdqz2tyqZ2lgrKyuuTtdSCMkHIJB/Qy3/wCCuWrLCq3fwwgklA+Zk1dkUn2U2rEfma/HKiu/GZJhcRLnqwu/mvyaJU2tj9lP+Hul7/0S2P8A8HJ/+Q6P+Hul7/0S2P8A8HJ/+Q6/GuiuT/VbAf8APv8AF/5j9rI/ZT/h7pe/9Etj/wDByf8A5Do/4e6Xv/RLY/8Awcn/AOQ6/Guij/VbAf8APv8AF/5h7WR+yn/D3S9/6JbH/wCDk/8AyHWbqv8AwVv8SzWciaH8NrS0uiDskuNSkuIwexKJBCSPbePrX4+0U1wtgF/y7/F/5h7WR6T8Wfiz43+Nfja88feP737bql2FQBF2QwQpnZDCnO2NcnA5JJLMSxJPm1Feo/B/4P8Ajj44eN7LwJ4DsjdXlyQ0srAiC1gBAeedwDtRc/UnCqCxAPs/u6NPtFfckRqz9M/+CTvw2upvEHjL4uXURW1tLdNGtXI4eWZkuLjb7oqRZ9n+tftxXlfwV+Evhz4H/DXRvht4YG+20uL97OwAe5uHO6aZ8d3Yk4ydowo4Ar1SvxbOsw+s4mVVbdPRHbCNlYKKKK8oo/Kv/gqr8Nf7c+Fvhz4nWcW648L3xtbhgOlpfgAMx9FmjjUf75r8F6/rp+N3w6g+LXwk8WfDmYLv1zT5oYGf7qXIG+3c+ySqjfhX8kmqaZqGi6ld6Nq1u9pfWE0kE8Mg2vFLExV0YHoVYEEetfqXBeM58M6L3i/wf/BuctaOtyjRRWlo+kan4g1ay0HRbZ7zUNRmjt7eCMbnlmlYIiKO5ZiAK+xbtqzE/dj/AIJV/DP+wfhX4h+J97FtufFV8LW3YjraaeCu5T6NM8in/cFfqlXmXwY+Hlt8J/hT4V+HNttP9g2ENvKyfdkuNu6eQf78pZvxr02vw3NsZ7fEzq93p6dPwO6CsrBXGfEXwXp/xG8BeIfAeq4Frr9hcWTsRnZ58ZQOPdCQw9wK7OiuCE3FqS3RR/Gtrej6h4e1m/8AD+rRGC+0y4ltbiM9Ulhco6n6MCKzK+9/+CjHwkuvhz+0NqPia3tjHo3jdBqdvIB8n2nAS7TPd/N/eEeki18EV+8YHFKvRhVXVHBJWdgr62/Yd+Gv/Cz/ANpfwjp1xF5thosx1i74yBHYYkQMO6tN5aH2avkmv3F/4JTfCe50rwx4o+MeqWxjOuOmmac7DBa3tmL3Dqe6PLsTP96JhXBxBjPYYSc+rVl6v+rlU43Z+u9FFFfih2hRRRQAUUUUAFFFFABRRRQAUUUUAf/W/fyiiigAooooAKKKKACiiigAooooAKY8ipx1J6AdTWH4p0I+JdAvNDFy9n9rUL5qfeXDBugIyDjBGRkEipPDmlf2Holpo7XD3bWcYiaWT77le569unJwMU7aAVtdWWCBdaYlF0/LyKpwzQH/AFoJHPCjeAOrKBmvC/DUXxBj8Vaimsz22pMJXutJhQBYovPDIssoRVKJHCw3KSWJcYO5sn0L4sW2v+JvB+veDPBupf2RrF7YTqt/khbJnRgkrsvzDB5AX5jjjgMR86/si/B/42fAn4d6np3xTvIPE2p6nfm8hjsbl5zZw+Ukawh7tICynaSw3YQt8qklmO8LKDd9ewru59IeD9Ct/BWsXujzym7uddLagbyRVWS4uBhZ0OOAFyrRoOFViqjCE16aDivONV1nSfFNoLfw/drHr9g32y0trgNbXHmQ5BDQyhJBHIC0TNtxhjg5Fdlomr2uvaTa6xZZEN0gcKwwynoyMOzKcqw7EEVlO71ZpueD+DG01/jR8ZvDurxxTWbroWqSpMqtGUurFrViwbjBFlg57CvCdB+HLvren6JqE4sfD/iL7TPojz7mkMMcgEdpM38LsjKYnOcqcYLj5uq1kXdx+2P4i8C2hKW/jDwTolzeOvBW303UtRjm59XWdIx/v+1X/wBon4v+FvD13o3gfwtpZ8ceLNdtL6x0vQtOceY8oMLrI8y/LbRW7Rh3lJHlgZHOK6YOSdo9V+hm4m18dv2kPh78DPC8f2vRjqvjXUpBZ6R4at4w99fXbcIqKqsfJyRmYAjHABchK/N/Vv8Agmb8avjJZ6j8Y/G/i7TPC3xE8VXb311o8dgG062SUDbEZIXBWVR94hZAT94s25z7H+zX8NfHvjPxjq3xS8Y3j638UhAsZ1q7aSBNHeE7BZQReW6LGQzLJEyB5PmYspzn718PeJPiLrGpy+FPFWo2Hh3XIPm8qCyeRbmIf8tbWeWcq6nqVMW5ehHBrepB0VaL1CLUtz8Zf+Cd3wZ+HXh/4wfFLxd8cz9q8VfB6ZLWGGZQ1pC0jz2806xFS0koaMLGScDeCFLFSv6j+D7L4V/Ffxz4g1ix82wsLG3tZJbdysCsHaQlj12qTndtYdV6V8faz8Jrbwh/wUYvPB+u6nePo3xu8Myz+dGY4N+o2OJWBWNFQlPsnmY28mQEknNfY/7Mvww0eHTvEPiu7uZb+ebWL2ytJgTEBb6bMbZJFVT952jLck46DuSVaqvKd2rpCtsj2Wez8Z22P+FXzg2aDAj1je1pgDgW5GLj6ZPlY+6e1Yun+I/DdlqsKfFG2uLLXMnypdT2y2YJ6/ZnQCBBjjdtV8cMxNesy6Vr0fz6frblv7t3BFNH+UQgf/x+vBPiV8Sr60srvwf9h07xhf3kbxLBZNIsqSFSFYxNHOm5TzjzQwrhjroUWNE+NngLwFpt94e8Ran/AKPoUs6Q3MatNE1nH88RMi5Hyqdh7fLye9fih8f/ANrzVvjd8b/DnxU8IaPDaaL8P1vLfS4r0uxvlvk8ud7gRPGyq6bcKrgr6k5r0H9qn4wW3gbwrffDvV9Nk0fW9ds7m3aGcxvKEkUxZRY5CQCSQWcLjGACTx+XieJV8MacumXLEOASQwIZcnv9K+jynCUIzlPEbHJXqSt7h+7Hg3/go58JPF3wT8U6V8RvsvgLxDo9qkC2kbM9vexTHy91kgBkJXnfFhiow25gTt6zV/2uv2mvjNGNI/ZC+Dl8mmSAInibxUgsbQp08yCCR0VwOqnzHPrF2r8lv2EvA+s/EH4uT/ESbTfO8MaH5dibqWMNC2oXciNFFGWGC6xpI5K8qMZxvGf6ra8XEOnGb5FodEL21PxH8X/8E/vjr8TLjSfGP7V3xiuNevbnU7K2XTtMUtbWou5ljZoWlWOGMqG+7HbAE/xV+X37Q3wN+MX7M2r3WgeOvD92dMilZLTWLaJ5NMvE/hkSUAqjkEExsQ69CO5/qO+Oni3SPCPhnTdQ1Ft8yarp8kNup/eTNFcIxCj+Z6D64B+YPjb4K1/4ifDbxRaeMrQ6p4y8Y6Pf2+jaQhIi0q2MRzcyDnDIdvJ5LELyxwu2GxdRap2Q5U09z+cz4DfArxV8ffF1vJNbNbeGrSTzLu5kBCuqn7ijgknpxjvzX6r23/BL7wvqt1pH/CN+LNU8DX+uwXM2nOwF1GHtdh2su6GVTIjM6nzOFUnB6V6J/wAEe7DRdf8AhT4tfUbGC5m0nV0SMyRq5UyRCTcM557D6V+n3xv+0aZ4VtPGtihe58J39vqIVfvPCG8qdM+jRSNn6VFau1Oy3BI/Lrwp8L/+Ch37J1153hvStE+LfhuE5aK0McV2Ix6JKsMgb2iEhPcnmvfJP+CmHw40bwrqsXxB8K614H+IGn25aHw/rNpLbm6mJCKI5ymAgY7mZwpCgkBjxX6S2l1b31rDe2jiWC4RZI3HRkcZUj6g1+bX/BU/xJ8OtM/Zrm0bxXqUVv4gu762n0S0KiSa4mgkAmwvVY1hd90nABKjOWUHOjUjOaVSP3BK9tD8vNf/AGqvjdL8UL/45aTr8ej+Jb+zjsXe1tofI+wxSGVIDHKrhlVjnc+5z3bGK/QP4F/F6T9uP4K+Pdd8VwQL4w8IwQWwtbdSIlVQbhLiNWLbTdGJ0IzwUI+7iv55Nd8T32kvJoc/2iymOBJbTI6Om8Bl+VgCNwIPTkHPSv2c/wCCRniPwH4A8PeONc8W6wtpfeL7uzto0cfuIodPSUqJXBOx3a4YncAu0Kd2SRXs5xiKE+V4eFrdjnw8Jr4nc/Y34GeKoPF/wv0PVECJPFF9muVQAATw/K5IHGXwH/4FXYeKPCnhHxBavP4nsoJEt1Lm4f8AdvEqjJYSghlA6nkCvib4X/FLwn8FfGHjPwnq96JfDrXhms57YiaNDnAGVOOYyoJ7FMda8g/bQ/aji8RfCrxXpvwyuLh/D9hp5+36jHC6LJcXWIoIAXC4QSOu89zx0+94kMPKc/dOzmR8AfAf9mDU/wBszx38XPibY2kL6FqmqXsNnfX4bzI97NJH5UuCWmVHiySCOpYjIz+gH7K/xputC8F6NfHw/HBdaLYp4d1m0RwjC/0p/Jnm4BG9yu/BznfnIzx9AfsXfB7xz8Nv2cPBfg+8uofDsctoNQuVtoxLfSz35Nw/mySAxoyhwgARiAoGeK89tfgb/wAIf+0xr3gHS79YNE8f6cPEdq0q5Md5ZPHZ30YUYDPJG1vIPu7sSHsa2lKMnKLehm7o9u8eP+z/AOOr208cx65N4X8Y28Ki21zSVkh1OFCARFMVjeO4iHQwXCSxdflzzUPh/wDaN1Twuj2XxJsLjXtNt1yniXRdPuFtWjX+K+tZMvaNjlnR5YMAszxDCV9LeH/BPhjw1Y21npmnQI1uip5vlJ5rlRjc7gZLHqTXVVxc6tYo/Lf9sLRote06w+LHgvR7zTn1q3/su8vCsSxXUcn+kWMgMcjsWEitFGQoz9o68Cvzj+Eeu3Gh+K9XmZZbq3uGijlRF3yZjiDhh34MnP19a/Rz/goX8SfDfwD+GB0jwJcQWGueL7xY5tNRo2giiw8zagtqwYQzLMqlZYxGWkbc5dlGPyX/AGVrnw98TPHet+Ffil43h8LaP5BvHvLtBHa3NwzxRR2t3cgoIo3TcwDMquUKtuHy16NGnamqv/Dmbd3Y+34fiXoHiWCXS9GvBbxTI0cl5KCiJnKkRZwHceudinqSQVryD4Yfsc/EDRfHvhP4ueO9csbTwDNe/wBmC/sGa4mie9WWC2muYWEaxW7zMkZfzG2u6Egplx9feIvBFn8MfE3hm11uW01/wte/Z7hJ7Tm2ntVcLKkZUkfKv909CMV+lGtfCH4XeJtFudE1Lw3Yyaff27W0qQxiESQSLtK5h2nBU44P0roxOaScORaJkQoJO585Xv7GPhpdEvVtddvJdSML/Zy4jjg84DKeYArNt3Yzhs4r889V/tnTvEk/w71GGSwu7I41EMNrIg/gB6Hf2I4K8jIr7l8RWfibStOX4YeJdTvdQn8Ottea4uJJjqFk+TY3jbyfmKK8c3QCeKQhVRo89n8KdFTSNGu5PEvgl9c0q6nDwXAtIbmRCqgN+7k/eFOmCoIznHOa4IucLVLmrs9DxH4IeHG8Z+OdN0+02R2mklLucZAxFAy4VV6nc2F46A5r7a8a/DU3Yv8AX/BdzHo2sXJS4nV8izu54MNFLOqglJk2gCdBv2gLIJUVUHxZ8WJfDnwa8WW3xk+HOpQ2dmk6i602QNBLFJKcGJbdgsjRzfdCqpKtgL1XH2L4F8T6h8atBtfFcZfRPDV0Dss1kH2+dlOGFzIh/cKDn91GfMYbS7qC0VPFV51GpsUIKOx4B8Jf+CgfwZ+KviIeErax1ix1R7czQIthJffaTHjzlhjsftE3yct8yAFBkkHivRte+IWqeLfin4X0TQPCOr3dvo0Fzq8n2lIbBWZ1NrbuyXUscyhS7nmLd6KcHHjHw+/ZG+E3w4/aA8Y6z8N4LnwnrclrZXml3lvO8sVmLvzxcW4tpmeF4J2hYmMrlVQiNoyFK+m/CPx1dy/EHxp4i+IqR2jT3kOiWepwKw0uY2I2Oqu7MbdpZHDLHK2CzBI5JWBqKvI5N01ZDje2p7lqen+PvFuk3mga3p2j6dYahDJBOGnuNS8yKVSrI0Yjs9uQcEiQ47V4b+z9aeKfD13r/wAFvE/iO5W+8JTbrQwRW8aXOnznfHKBLHM+fmBbD4UttHKmvsCvnH43wp4H1jQfjpakRDw862erdvN0u5baSf7xhdtyj/aY9hWEHf3Sj2uXRNLtIWllWa7xgBLi4lmRnY4UbZGZQSSMHHHtXl/wr+EPwy+Heq+MW8BeG7Dw/c32pRNczWNukDyOLWGQZ2jhA0rkIPkG9sDk59C0vxNoniiWG/0G8j1KyhTej27CQPLICByOm1c53cfMO4rndA1KVvEnjCxRTLdDU4cQRtjAOnWZDSSYyq+4GTyAG6VKuB3suqxWw8q4GbgHaFQZ3ntt/qOo+nNQSJcyBJr7HmSMBDbjlFbqC5/iIAyewxwCQCbFrpaRET3DCS5xgOBtCA/wxrztX16k/wARPFedfD3xT4r1u21bVfHmjjRJtPJWNBu/1A3MzAEkt90fOPlfHyjg0JdUB6HCirM6qcrbbI8nqXch3J+oK/jmtesq1ilg0+IXA2zOyvIOoDyOGYD2BJA9q1algFFFFIAooooAKKKKAMLxRYXGq+GdX0uzAae8s7iGME4BeSNlXJ7cmvx4/wCGJPj1/wA+Fl/4GR1+0lFetluc1sKpKlbXuZVKKlufi3/wxJ8ev+fCy/8AAyOv1q+GGg6j4W+G/hfw1q6ql9pWmWlrOqsGUSwxKjAMOCMjrXdUU8yzqtioqNS2nYKdFR2CiiivINQooooAKKKKACvzp/ak/Zu+KPxW+JqeKPB9rbTWC2EFuWluEibzI2csNrc4ww5r9FqK7cvx88NU9pT38yKkFJWZ+Lf/AAxJ8ev+fCy/8DI6+vv2RvgP8Q/g/rPiK98bW8EEWpW8EcJhnWUlo3YtkL04Ir7mor0sZxJiK9N0ppWfl/wTOGHjF3R8a/tzfBbx18ePgza+Cvh5BDcapFq9teMs8ywJ5MUUyMdzcZy44r8iP+Haf7U//QK03/wYw1/SDRRl3EmIwtP2VNK3mv8Aglyppu7PwP8Agh/wT9/aQ8C/GPwR408QabYR6Zoes2F7dMl9E7rDbzpI5VRyTtBwB1r98KKK5M0zeri5KVW2nYqMEtgoooryygooooAKKKKACiiigAooooAK4j4g/DfwP8VfDVx4Q+IOjwa3pVxyYp15RxwHjdSHjcZOHQhh2NdvRVQm4tSi7NAfjT8Uf+CT8M91Nf8Awc8YLbROSUsdZRmVM84F1ApbHYAwk46sTXzDe/8ABMn9qC0maOC20i8UHh4r8BT7jzEQ/mK/o0or6WhxdjYKzafqv+GMnSifzff8O0/2p/8AoFab/wCDGGj/AIdp/tT/APQK03/wYw1/SDRW/wDrrjO0fuf+Yexifzff8O0/2p/+gVpv/gxho/4dp/tT/wDQK03/AMGMNf0g0Uf664ztH7n/AJh7GJ/N9/w7T/an/wCgVpv/AIMYaP8Ah2n+1P8A9ArTf/BjDX9INFH+uuM7R+5/5h7GJ/N9/wAO0/2p/wDoFab/AODGGj/h2n+1P/0CtN/8GMNf0g0Uf664ztH7n/mHsYn84tr/AME1/wBqWK6hlfStO2o6sf8AiYxdAc1/R1RRXkZrnVbGcvtbaX28/wDhiowS2CvnX48fstfCD9oexVPHelmLVYE2W+qWbCG9hXsu/DLIg5wkisoySACc19FUV51DETpSU6bs12KaufhJ47/4JQfErT7mSX4c+LtM1m0ySqagktlOB2H7tZ0Yj1JXPXA6V45J/wAE0f2pkYqum6Y4HddQjwfzANf0fUV9JS4xxsVZtP1X+VjN0Yn833/DtP8Aan/6BWm/+DGGj/h2n+1P/wBArTf/AAYw1/SDRWn+uuM7R+5/5h7GJ/N9/wAO0/2p/wDoFab/AODGGj/h2n+1P/0CtN/8GMNf0g0Uf664ztH7n/mHsYn833/DtP8Aan/6BWm/+DGGrNr/AMEzP2o7iURy2WlWyk/fk1BCo/74Vj+lf0cUUf66YztH7n/mHsYn4m/Df/gk5rMl1FdfFzxpBBbKQXtdFjaWRx3AuLhUCH/ti9frB8Jvgv8ADb4I+HB4Y+G2ixaVathppBl7i5cDG+aZsu7emTheigDivUqK8bH51icTpVlp22RcYJbBRRRXlFBRRRQAV+ef7Vf7AXhL496rN488GX6eF/GEwH2hmjL2V8VGA0yr8ySYABkQHI+8jHkfoZRXXgsdVw8/aUZWYmk9Gfzrj/gmB+00dS+wk6IId2PtX25/Jx648rzcf8Az7V+kn7KX7BHhH4AalF468W3yeJ/GUakQSrGUtLHcMMYFb5mkIJHmtg44VV5J/QSivWxvE+Lrw9nJ2T3t1IjTS1CiiivnjQKKKKAPH/jd8DvAXx+8ET+B/Htq0kBbzba5hIW5tJwCFlhcggEA4IIKsOCCK/Fzxz/wSy+OOi6pIvgbV9K8R6YWPlPJK1lchf8AppE6sg/4DI34V/QHRXsZbnuJwq5aT07PYiVNPc/EH4N/8ErPE82r2+qfHDXrW10uFg7afpTvLcTgfwPO6IsQPcoHJHQqeR+0vh3w9onhLQrDwz4aso9O0vTIUt7a3hXbHFFGMKoH9Tyep5rZorLMs3r4pp1pbdOg4wS2CiiivMKCiiigAooooAKKKKACiiigAooooA//1/38ooooAQ+1NyafRQNMZk0lPwKNooK5hlFP2ik20BcbRTttG00Bcbk1zmtapcWU8VtpwWS6ucJh87It5wksmOcZyAo5c9CArMtrxI2uxeHdUl8LxRT6ylrObKOc7YnuhGfJVz2UvgMfSvkH9mnw/wDH/VLW98e/HW4j0vVPEPmRrpu5Z18jCLG7/Z5jCjEKSFjbIBGcHIranBNOTZLlrY+tDYx2kdvo8DGR7uQy3Ej8vIqYMjv0B3HahAwArYUBVAHSZNeBaD4ybXPGeoeF7i71KOe2R41njSDbKIH2v8qwl49zHIOemASCBnubnwxFeRiKezvr185LXeoyxxH32xSMAfTEYpShZ2kUmjzj4pfE3wj4b8XWXgHxLoX9uQ6lFHeusiIyQBpGiV0VwdzkqTgbSuM5y3HC+JbrVvg54gn+weLk8JaBrCS3drDrmdUtvta4WeM4cXStIWWVCtyyA7/3bdB7JL8LNKvmElzomiqyZ2Nd2z6pKu7g7JZmjZOg4AxXkPj34dDTrvRNCikSe/1O6NvZFba3t4nXyy8nmGKMODGqZJdn3L0+bcK7KCpNqN/UiV1dn5Yax+0X431z4mt8fLR7S91GOxbS47S+jFxaPpyyiYROiiIHMi78gKyk+tfob8Gbfw1P4d+F/wC0J58mo+IfHd2v9q6ldhUcebaXMYtIVX5IbS2dWWGNPlwN7FnZmP5e/F79m7U9E8IePfidpGrXP/COeF/FctjqWiWSrHINKilW2uLu0unG4J9sjlhC+UQgBJOFYV+hnxh+CPgrQ/gz4S8T/APxPrnh7RrqfTBpdrDqU97pnl3qFIJVtb4zqjFZFH7spwTkZJNfSZisPN0401y7r8OvVb3OTCQqxcud3PuH4LWsifD2w1e5Tbc+IJLnV5j3ZtRme4XPphHVcdgMV1vivwnpfi7ThZ3+6KaFvMt7mI7ZreUdHjYcg+o6HvXyf5H7bfwpsrew0W18LfFnRbAJFHGDJ4e1Z4UACr8zS2YwBgHI+h7cnd/8FA/DfgFxa/tB/DbxX8Mpt203FzY/bdNPb93dwH95z/djNfL1cPKUnKDT9P8ALc7bnhv7bPifxT4D1j4WfETxBbeZ4i+GHiO3mGoxALFdaNqRFvcs/dXLJGuMY5bp/F9c/s3/ABJ0sfDDT/C2i6dd6jrdk91JLbxoFX/SbmWYStMxCKhL4yx3ZBwpr4w+K3xZ+FX7UHwu8d+Ip/HmgW8Mti9tp+lSXQXUEjTc0LmDHmsxmKtgJ69ABnZ/Y+/aX+AHhXw61z438SNoviVNMtYZre5hfbI0KBpBA0e/zpZHPyRgb24CKxJA7amBfsOda230MfaLm5WfpBdeE/Fvi4H/AITHV/7O09uun6YxUMvpLcMA7+hCqor4A+NH7YOkeDX1P4T/ALG2g2viHxPaAxajroUSaVpROeGnO77VcDB2xgsMjAEjBo67PxnF8df2r7qXwy0F78PPh5J9/TVf7PrWpQt0OqTLuFhbuvItkD3Eg4dQpDJ3B+B/gX4cyeDvgz4K0+GKTU7j7RetDH5SQ2MGHkSNCW2iUpy7M0jlB5jucVyxpRj8b17f5mtjwD9nz/gnXpmoz/8AC4v2ktVuvFfjfXR9skaaQMYpJhuyQQygqCAFwduBgqPkHD/tn/s6fCbw78D/AB9o8/haz/4SbRLOPU/D+utEPt7WsNxG89vJOMNJsiWRQHyAudoX5a/Z4AAYHAFfHv7cHh3RPEfwG16wvSRqk9rcwWIQZZ3mhZXU+i7fmJ7EL64ONOs5TVwcT5t+CHhbSX/Zt/Z6t/DF1c6HNq6WcsotZMwtPGyRySm3lDw72ZyWIQFiSSSa+wfiJ8RviD8JbVHubjS/FckwPk2xWTT7xh/eYqZotoPfame3t+Xn7M3xQ8Vj4EfC28FvA9v4ThuFtcBvmKXchzJ8xBwVA428DHvX2r8ItN8V/ErU2+IZgXWZ5pCYby+JFhE6HG8hfmnKEYSOPCAj5nXAB0qQ1d+hJ5Rq3xC+IF544t9Y8a6QLLW7dre8jt7394sAVxLD5aowULgDrk8nOG5r7q+DWuaL4m0648U3FxFL4l1WRheqXXfGsTERRRpkssKryo7kliSxJrzT4wfCHSZbLSfEmtXt1qviC71TTrKe8ZvKBt7mdYmjSFPkRF3HbgFgTyzHNe/f8K3+H0OjQaRcaFZzWdjHtj86FZXQDkne4LZzkk5znmplUg6drajUXc/Mj/gl9o0Pgrx3+0h8NbbAg8NeKIoogOB5PmXkUbAejLCCPav1h13SLbX9E1DQrwZg1G3lt5O/yyqUP6Gvx1/ZI8Gxj9rL4waDpWraj4di1zStM1qD7BcFM+W7QPvVw6yASOxG4HGSARmvqL9o74n/ABN+APhy3stK8Yf8Jh4l8TF7LQ9BXT0/tW8nZcFoTb87Ygd7ysoVfckKZrQvPRgYOoftk+DP2efgatp4x36p410eWbSdP0SDJub6aFtsWMA7IkBCu5BxtwAWKqfgzwP8LPib8V/iP/w0n+0jOt94nmdZdN0iSNZLTTYUJaFDDJuQeXnKREHacu5aQkjjvhv4U07TdVk8dfFO4Gv+Or4FY7aIeYlgrZxFCDkBhnlzz1xklmb7D0rwB4qu/Dmmv4k1rUNNtrmAPDBbeXDmLop88KzPkYzg8dOor1KeDjycylqzCVV3tY+Zvgn8TdC0L/gov8T/AIn/ABWmF49pogjimZYgTdtFYQoAGKKv7lXHy844AryD4p6vovwb+KPiD4j/AAh0j7L8N/GYMd9ZPG7R6VeSE+Xc2x2KVjDksFUFAGaLkGPHsX7LnwTvfGn7S/xm1bQdMh1dPCFxYRxrfssis84k+UiX5XZvJJO7pjqDiv1Xh8W+B00S++HPxb8CQaHp+rwSWl1HHZhbO4hkG1wyKN20g9VL+oIrjnJRlZamx+ZHgfwfpepQW+qazfvrHmqrxnf+5KsMgqAeQQexwfSrnxOttH1zW/h58GLu6j0zw74s8QWtxqyfdibT9KzcTBgOAeQAT3PvXceA/gZpvwr+KL/B7UPGcdt4I1lJ73wdrc4WeGSGIGS40y4l8yMR3Nsnzpu4kjyRtK7K96+Gfhv4P6J8cfG/xJ1rxFp2oeC/h54cs9Ik1O9mgewkv9VkN3dsrZMQCQR20YXLHLsMknA66eL5KbjYydP3rn6MaNr+g+ILYXXh/ULbUIAB89tKkqjPTlCcV+Qv7a/7U2ufDX9omx0vwdb2seqeCba0vBdXas4MlzBcK0IRXQGN4bg78k5O0rtZA1eqQ+AB+0frkfiX9nXTrz4beD1JP/CWXCyQvqXodK01yr+WeP8ASJTGn92J+SPjD4tfsc+MfGVt44126juPE99octzb/wBsxXDyXkksCNh7kufMmXKg5bfsXhSo4rnwKpwnzzV/JmlVOSstD7m+E37Yfx3+O/w9sPFfgjwHoPhmzdntbrxD4j1nydKN3AdsotbSEG6lXuNzxgHK7zgtXr174bu5vCl546+M3xgvfFOnWi7msPDMiaHpjO33YVayka9lLHCgSXhUj7ygZr8hfhNYajY+C/D3iPwHEZtFls4nm0BpXZIWYZmayeZyUk8zcXRm2ytliVclj9aeFdS0DWLa11i0jTULOCdGmtpgyfPC2WhmjOGRhyrKQCM1VHAyqJyhoRKqo7nvPwd/Zk8IfEttQ8a/EDwrY2/hnViTbaOIAsVwv8MkvAZwvVXY75H/AHhPdtf9kL4e+BvhR49+Lfwx8L6JbadYvrFwwjVNxeBCskUTu+WdUhukChicL9TX3tptxbXenWt1ZqEt5okeNQMAIygqMDpxXx7ar/win7SWu6j9yPWNbt3k91vdHsrSP8PMtGP1zXBzuV0zUd8df2T/AIc694P1PWPh7o48LeIrTdeRtozGyjndRmQSW0eLeV3UcNJEzFgOcZq18GPG3xOh+Emn+JrvU9M8TadpkRtrhLxX06+i+zfIN08Inhnd12lVEEOSwBYnmvq7XNb0vw3o95r2tXC2tjYRNNNI3RUQZPuT6Ack8Dmvyb8NfGrUf+Ew1nUfAVhDH4NfU2v7SzvlZw9zjBkxE6AKpHyLkgEDk7adO81y7ibsfbOq+JGtQvxX8WWN34X1zREllWG/QLarpDANPavdRs9qHmVBL80qsJ0iDYRcGtD+1V4P8fXJ8M/s+wv8QPErj50VJrPT9PQnAn1C7miAij4O1Y1klkIIRCAzLY8P+PPD/wC0J4Q174W+L7d9Kudb0+4tJhbyY8yGZCjvAzA7XQNkKwPr8wyB8cfsa/ss+Pvhh4Esvjt8O/Ga6n4q8UWqm60jVLdYdKuLNHJW382LzLiGYMCy3ALqM4aBhWrpxUWppqWluxN23psffOh/BbTr+V/EPxemh8c+JLiN42kubdRYWUcow8On2bF1gQjhnLPPIP8AWSsAqr4RZeGbz9mj4gLb2OoXVr8PfE0wVHD+bHY3J+6siyhwF7EjaWTnOUNfRXhL4x+G9da60nxLFJ4Q8SaZF519pWqskU0UYO0zQyBjFc25Y4E8LMmSFba+UHJ/FHxloOvfD7X5LxYf7CS0kY+eyrc3bKMxi3jbmPLYxK4yOqp0audN31LPk/43eJ/Fvhv4oeM/Ed7qctrPpmj6c1mYGaFGEUt6YioDH7zSDnJ5YjpxX0p+zx8N7gfBTw9/wlGoX8s+tWpvLu3Mojjc3mXwyoqk5RlBBJ9DX5sJFe+JtQtLTW7ya8iaweFRJIz7FgePy9uSeV3Eg9c89a+9v2evjOLKyl8F/EXVobb+zkRbW5upFiUqvyhN7EAgrgpk8YZcnAx3VMNJ0ueK2MlNc1j322+HEHhcqfDPmX2mxgD+y765mmjjVegtZJWfy8DpG26PgKvlDJrnfigfhbeeBL6w8WXln4cilxGY7rybaRpSGxBsdkEhkAYKFYh+qEjmvV5/Fvh6K3iuLe9jvTckrBHbMJ5J2HJEaoSWwOSeij5mIUE18gftgfswan+0z4Itrw6pcaFrPhqG9m0+ztgk32kXEal7eZmO0SSGJFR1ysRLf60GuOg1zpzdkXK9tDq/2dNA1XwLoOr/AAltL1Z9V0G9Zrq8YB4GhnUeS8S8MzhU8rG7ahjO/kBG9a+HG201vx1G6Ox/tpN8hJlLMNPtBlj97PHoABwMAAVx0Hh/QfDGj+C/H/gTULtNDgsLSxmkaUzNJpNwieRK3niTHkvsc4AwjSHiug+GiXiax4/mF+zCPXpAxmRCuFtLcEnYIyDx649qmTvdlHsjypNtiiYN5mckHOFHX/D/APVWHr8TXE9hZ2wzNJJvYdM28OHdT22s2xD/AL2eRkVbtba8bde3DR+ZLg8I0bBR91SdxxjqQQec183/AAt8S/tA6n8dfG+m/Evw5a6f4Mt4nHh29SSNpLmGOcDcoSRm+eN0aXekeHCquQDhRhdN32Fc+npZkmtklTozx9eoO8AgjsQeCKu1x3ivxHovhOzTU9auPslvNNErZVm+YMDuAQMeFB3dsc8d+wVldQ6EFWGQR0INZtDFooopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/0P38ooooAKKKKACiiigAooooAKKKKACud0S3jm0qa3lGUN1eAdsYuZMY9McYx07V0VZGmDbdaoo4UXIIHYZhiJ/Mkn6mmBzlrFDo95fau1qjN5my4nSMebsCrkuVGWAPzA88ZBGctXbxyRyxrLEwdHAZWU5BB5BBHUGsrd9lH27ogeRZf9ze2G/4CTz6Ak9hXMTNe+HNTS10xBJaXpZ4bckKhcAvJFEx4RyAXRT8jYYfJjdVbjSO8JzXhnii90ie88XeOPEMZn0TwTps8SANg+dHGLy7ljYco6BIkR15VlbBBr0ufxVp66Dea3BudrJWD27jy5lmA+WFlPKuxIAz1yCMggnzTxXpNnH4A0zwDNdRXE/iG+tre8beNtwss32vUsnsJYEuPzArSn7pR5v4H+F1xZ/BvQ/h34wsI59eGlz/AGqOQkQ6quphptTtZM9GeSV9wPRgsi8bgvxD8Otf1TQfg/4m/Zl1S4lub74Va/a3mmyzDbLc+HrmR5rKRv8AbhnPlSgZCMAnav171dNH1iyazlmLEEPG9uS0sUi/dkQqGIZT04wehBBIP4e/HXx9rdn8SdM+NpsobN1hl0nxDb28bRPJpcsse6WdWZvmguFSYgbQCrk9Sa68NVnKTfzM3Kx+6Umo2MGntq08yxWiRec0rnaqxgbixJ6ADmvJ7PSh8WbqHXvEVsf+EWgO6wsZ14vD0FzOjdUI/wBWh6jkjBwfGdA8a6l8T9N07RdVl0rQ9P0dYVltL+8LG+ljA8t3iVUEkK43eWJcF/vHAAP0NB4f8T6on2nUPGDm2ccJpdtBbRED/bl+0yY/3ZB9a43BRW+ppuj8nf8Agpr8E/hl8LfCPhn4ueAPC+leHr2fVW06/NjDHaSXQuYmljPlx7Ucq0LbiF3c5PANfj74D8TT3nxt8AQw3p0VI9c0fzr92KR2ai6jAuHkH3FQZOc9q/d3wh8ItE/bD+M2rfFfWbrUJfhj4Dkl0rwtJJdyzyanqsbgXmqKZzIvkxsvlQhV2Nt3ABlYH6q+IX7NvwqufgD4p+Fs1jDHpupW8k09xKI0la4T5o5WkVVAZWUBSBx6Z6+nHMZwo/V29DmdJOXOfQljeeFtLtVtLG6tbeFMnasqDk8lic5JJ5JPJPJOa8L+Guu6J4v+IHif4iXF7bi3iK6dYFpE/wBUnLMMnvhW/wCBGvkX4QfH2Fvg/qXwc8f2oufiJ4RiTTWvHt123+nyfLaagHOTueEFX6nzkYk8190/C34a+ENL+H+jW9xo9jcyzwLcSO1vFJuaf5+pU5wCF+grzHHlvc2ubnjL4s+BPA9vbzaxqKyyXbFIobbE0r7cbjtU8AZGSSByO9eMfGzU9N8aeGtD8S+Gt2q2kRl8xI1P7sTbQDNu4jAKFfmwT/CDWZ8Sfhv4Z+Icj6x4NtbbQdN8LRXTz6nBboI7uRVy0MUabPMCFPmlLYU5VQx3Y8t/ae8Ya5+zn+ylYXvhLUJbHWNcltbGWU7HCSXsbyzyKkitghVZF24IyCSSM104SnFyil8TfyIqSdn2PjL9mfwhbw/Bq20DV2MqaFqWrWP2Y/6oGG/mzvHBk5P8Xy9PlzzX6YfC3xlbfC/whBpPi3R9RsbeeVriK5Fvut9koG0ZByPXGM81/Nfonx28YfB3x7beOPC+p+bPZzC7mgmZpLe7Zn3SrPE5YP5hJyx+YE7lIYA1+/GoePf2yvFcEcN5qPgX4WW98ilVv7fU7+5QSDhfOuY7WzducEKG5rtzXDqFTkumRQndXPo3xj8RPAHijRdLGm63bO8es6PJskbyXwt/Dn5ZAp4HXivlf9tD9sbU/hV4C1ez+HEULahcyf2bFfzfOqyyhg8kMeQG8tVYqzZUtj5SvX5R+On7OnxNOt2eneNfjjd65qGpRLePBoWlW2iWscO8hDvtpCJGLIcEpkY3Env4Xb/sM+CvFvhS+1nTPEmsv4qKPHFLqU8csMdynO2ULEHKHoSGyAc4yMVjhsEpWktUip1baHwovxB12xvpNav7+6bU3bzFvkmcXKP1BD7tw59CMV+qv/BPfVvHX7R2p+MfFWsanLdeLdKNpp974gvZWnvE0uWIi3tYGJyilopWkEe3zGO6VmJFfkA/wq+MWv8AivWPAOgeHJtW1TQrg2l41oySW8Mu4qA84byxkqcAsDwcgEED9g/2Wo/it/wTUsb+x/aD8CPeeDPGctpd3finRGe+/syURBFt7yIAERxFjkhV+Yt5ZmyAOnMMU6toxW2xFKnbU/RPx58A/hv8PvDtp4x0HSIzqen6np9xe3cg3SXMTXCpKsi/cKtuyw2845zzXqvivwZrfhV7vxD8O7VL6zuC0l/oT4EU5YfNNaZyIp+5AG1/Td12tS1vwp8ZPhDqeqeBNVttd0rW9Pn+yXVpIJY2k2EpyvRlcDKnDKRggGvR9GvhqmkWOpr0u4Iph/20UN/WvF5n1Nz8wf8Agmc0Gr6l8dPF8eUfUvE8VvsfiVUtISVDr1GPNI+oNfqLfWFjqds9nqNvHdQP96OVA6H6hgRX5M/sgfDTXL/QPih44+Huotpni2y8f+IDGGb/AEe8tVlSNYJVPy43RNg9Mnnsy/VWsftmeAPAHg7UdS+KtvPovibSyLf+xo42kutQu2IWOGyTq7yMRhSflB3ElBurStBuWgH56f8ABUDS7PwLr/gjSNEik0bQ9ViurtvLZjBNeQMqYKsSAY45MgDH3zxX56/s0XNl4k/al+Hmhav4ej8Y6c+oNLc6esBuEmihglZpXg6P5AzIAcrkYIIJB/ZTw9+yZ40/a28RH4y/trwzWmnSQyR+H/BFpcywR6VbTDiS6mhaOQ3LDDMFIOQN+ABCnN/A74TfB39jT9sjxx4V0yzFppPiDwhY6to9xdFru7iENyba7toZn3SHzZCsjIDyApPCjHpLMJKh9XRj7Fc/OfXPjv4+39tc/wBk+ALaNIYFCvPcRMGDY5RIjt27eh3A85AGBk/Ntt+0rpHww0jXvB2v2Ueo3/iNp5gQ+wLJcIEbz/7sZHIxgk8dDuXh/iN491XUPEt/4a+Heny3GqXkssrTzKAlrHI5ILnJXeM85OFPHLcVJ8IfgZpB8daMviCdNW1a8ulknmnOUAQ+ZIqBuSzAEBjyTjGOlc8sKow5ilPWx8sfCqO88Fy614S1GJoYtP1F5LYkjb9nv1F3GAe2DKy46jaR2r6D8O+C7zx74ysbTwZdxaZ4gv8A5DJMSLe5iiUuVuFHLYUHYyjep6ZXcp+5NS+BXw0svjjbSXGhRHTvFehSxOgeVEW80m4V4sbXHzSxXkufaH2rivj78AtD8M6Zp3xO+H0V1Yah4YlR5VgupgTbBs5B3Ejy264/hZielOljHHSL3HKknqfV3gbxZaatAfDl5ZPoeuaTEi3OmTsHeNB8qywyDCz274+SVRg8q4SRXjXwL43WTWniXXvEEBEUtnZ+HbmI9N0kVzqcbEepAdM+wFej2Xw+0Xx5oWi+KdN8Ta1C5jS7sbpbmKS4tmlUE7Xmik6/dkRsq4BV1K5FfnF+0d+1H4a8DfFO28GeOr651t/DolsdSv4IoY4BJKYpI5BEoVj5QLiRRu2EkKz8isMNhpVJNQ6avyCc1Fan07+1V45m+I3wvuvC/gGRrixxa3esXMWcRW3mriHP94uV3egHpux8h+Fls7O0it4VEcUShVGOABXSeDvC3jL9ozxLfeHvA09zpXgiHal9fozRRXDqwKhgP9YAMlI+ucM20dPbvGH7C/hvw1o9/r3hbVp74afbPObW+UzPK0SbmCyKyqN2DgFD6ZNaUpqlNXFJcyPN9Aj/ALd12z0XS9Zj0e8uSyrdGbyvJAUlnLBgQNue/PSuM8KfD7XbH4feF7TTfGE93HJYJLII9xjjLOw8tT5rA4AyTgdcYr7V/ZG8GeCF8FyeLrHTYf7ZeeW1mlKKfLEeGVY8AbQVZSx6k98YA6DTfBun694a+HnhqRDFNJZzPNNH/rFtoU+7zkYMsiYyPXHU1tiMbGpUvJaChTcVZHzd4K/Z6+A/jjSl1b4s6teXWpQyuIYpbk2sdqy9JIZIwrbyP4i/HK4x19Ltfhp8JvDWj3nh3VRp+u6XdwyQwa/ayrNf2hcFVe8t1cglCQfPgUL13xRIpc/QOj+PPAHw30mDwh4n1Oy0TVLJjCtn5n+kXjH5hLbQAtNN5o+bCKxB3L1U10EXiS/8T/NofhKeW3bkXOsKNOicdwIpEkuw3oJLdAf71cDnLrsan5W674J8U/D7XtOGqwrc2F3HMllf2ria1uw7RMpikQkHcoyAcHHavX/hV4dfxdr2o6emi2+oXNvbRym4vUE9iLNnZJWt1jbddTxyKABG6ohDo0gfMZ+Sv26PgP8AGvTfjVpXjM29jD4A1jVtKtob638qOysZrspFLFPYM+9hJIHd22skgb52UkqP0x+IOh/ErwNBpvjSHTtKvIfD6vb3Fxo0k2lymxulEbBbGVpYsQvslBN4ANh4AJx2zq8sFCMrp/1YzUbu7R2Wj/sx/BuyH23SYLldTZR5moQ3sqXD55H+rYRoO4VEVR1C812Nt8L9c0jB8P8AjzW4QOiXjwX8YHpieItj/gVfOvw1tvEHgvxj/a2t6fceGkjjdbn+0w0VpNvHyq17CJ7bO7DA+YeRjqa+wtP8Rm+tY71bRpraUZW4tJI7qBh6oUO9h9ErhqqUXa9y0z4s+Kc3xL+H3w31fwWdWgudLttSSBpIbRra4Gm6gHnj+YSuiwCXfagKg4j29DisT9nHUNSi8bWmjadNI9jqCyPeQgkoVjQsHYdAQwUZ7g7e9fU/xT8QaPoej3niF4Y7trqzk057OeLH2iWXmzEkUoyyiUmNQV5Mp+h5/wAKeE9C+F0Gj6RZSQ2bXEMFjrF1uVHe5f54xG5Od7OxUheVR1bjCmtaVbljJNXuKUbtHvYk/tGVkT/j1iJVj/z0ccFR/sqfvep46Ag09VbyNS026iGXWR4XPYRTKcAntulSMA9c8Dqa0ImDItvp6iOCMBAygBQBxtQdOPyHvyKr6rAqaXO0Y+aDE477nhIkGe5yVAPtXIUR6voOk69bpZ63bJexBt+2QcAgY49Ov4jrXHeBLrx/cax4iTxXBDFpMN0U0podvzQKzr2JbhQudwHzZxxXfRuLuRpFP7hQAD/fPXP+70+v06mmj/QopD1lBlPsZDvI/M1XNpYLF6iiioAKKKKACiiigAr8sf21fiV400/4qWHhnwdrd/psVhpayzpZXMsAaR2kkYsI2GdsSqcnoM1+p1flLDpI+L/7YXjm2I86K1s9VtMdQPKszpw/8ffP15r6HhxRVWdWa0jFs58ReyS6n2J+yT4x1Dxn8ENIvdYvJb/ULKa5tbieaRpJHZJS6bmYkkiN1HJr6UDqTtDDPpX54/8ABPjXzL4a8XeFZGwbK8gvFU/9PMZjbH08kZ+orivhB/yfL4r/AOvnWP5mrxuVc2IxGtuW8v1sEKvux8z9Q967tuRn0718NftA/Hb4hfD/AOOPhLwN4YvIYdI1aCxe4R4EkYtPeSwvh25HyKOnTrXkL/8AKQr/ALeR/wCmqvGv2hfg3pngz47aX4UtdRmuYvFjw3ssjqoaFr+8ljZVA4IULkZrsyzKKUa0VVlfmhzWt3/yIqVXbTuftSCGGVORVJNT02W7awju4Xuk6xCRTIMeq5zXwj8cbW+/Zo/Zos/AvgzVZ3lv9QazF4cRTrFcebcS7Sn3SduzI5wT3r5q8Tfs4W3hD9nvSfjpp+u3Q1x0sr6SMELGqXjqI/LZQHWRC6ksWOecAcV5+FyanUipSq2UpcsdN/x0LlWa6H7IEgDJOBVa6vrKyg+03txHbwg43yOEXJ9yQK+D/E/jfVPiH+wpeeJtbkM2oyW0MFxIesj22oJDvPu4QMfcmvmnwj8E38bfsz6j8Rta8SXnleG472TTdNQKLWIxMZJSwOSzSknkYI4ySAAChkcXFyq1OW0uXa+o5Vuy6XP2HmvbO2tjeXE8cVuAD5jMFTB6HceMGpYpop4lmgdZI3GVZSCpB7gjrX5AfCT4Saj8ZfgXreu+JvFl+mm+Dftsemaam0wRyxQLcl33ZyGMm0AAEDOGxxXvP7Beva1L8O/FumqXvY9LuUktLcvgb5YmLIpY4UOyD0AJJ7mjGZJGlTnKNS7i0mrW321CFa7Stufft7qWnacFbULqK1DnCmV1TJ9txGatq6OgkRgysMgg5BHrmvy90L9lnx98TNT8TeN/2kdTuPDs+Fe3l+0W0qfNuLEkPIscMXygJleDwRij9irU9Y8SWXjz4RajqLzaPNYOISG3rAZS0EjQ54AYMGx0yAe5yVclpqlKcKvM42vZaa9n1sCrO6TW567o/wAdviDeftbzfCSe8gPhpJ7lBGIUD7Y7Jp1/efe++AevtXov7Qnwp+KvxIvtFufhx4v/AOEZhsopluFF3c23nM7KUOIAQ20A9fXivzi0v4DaRf8A7SkvwMfVJ1sY5Z4/tgRfNxFaNcA7fu8kY+levftyaHF4Yg+GvhuCVp4tJ0uW0WRgAzrAIYwxA4yQuTXtSwFNYqhGhJJuP8vk9fVmPtHyy5kfrDVG21TTbyZ7e0u4Z5Yvvokisy/UA5FfDv7d3xB13wt4M0Hwnol09mviSW4Ny8TFXaC1WPMWRztdpQW9QMdCQfAviF+yz4k+FXhDwt8Qfhde6tq3iQywfaY7KFpHieSJpPNhEC71RWXYd27O4cjofDweTwqU4TqVOVyvbTt3fQ2nWabSWx+ttFcj4A1fWNf8EaDrXiG0ksNVvLKCS7gljMTx3DIPMUowBXDZ4I6V11eHODi3F9DdMK/C/wD4KI+Pvino37S+i+EvA/i/VdBt9Q0jT1WG01C4tbfzp7mePeywsBk8ZOCcD2r90K/n8/4KWamNE/av8Pay0fnCw0fTLgoDt3eVd3D7c84zjGcV9LwjBSxdmr6Mzq7Hqn/DEX7fv/RZYv8Awo9Z/wDketj/AIKeeP8A4h+A9e+Hdn4S8T6nof2iwvTcDT72e2WV0eIBn8pl3EZOCeea9w+AH/BRTTPjv8WtC+FVv4Fm0aTW/tWLt9QWcR/ZraW55jECZ3eVt+8MZz2xXzP/AMFbv+Rs+HP/AF5ah/6Nhr2MDLEyzClSxkEmk3ay6p9vQiVuVtH7K+BJ57rwR4eubmRppptOtHd3JZmZoVJJJ5JJ5JNfl7/wUg/aT+I/gXXvD3wV+GOoz6LdaxZrf3t3aOYrqRJpngggilGGjBaNy5UhjlRkDIP6e/D3/kQfDX/YMs//AESlfiB/wUk/5O58G/8AYH0r/wBL7mvG4boQnjvfV0rsuo/dOQ+KvgL9rf8AYqHhv4k3nxEkvRqtx5TpBfXNzCLhU8ww3MNwAkqMobBwfun7p2k/Sf7b/wAVfHXij9m/4RfHnwLrepeFxrDeVexabez2q+be24l2P5TrvEb28ioW6Anpmu7/AOCsP/JGfCH/AGHx/wCkk9c5418Jf8JX/wAEsNFaNN9xounWepRe3kXeJT+ELyV7lHEqrDDYqrFcznyvTo7ozatdI9U/aG+NetWf7AGk/EHRdVuLHXvE2maHDHeQTPHcJcz+U9ztkUhg22OUEg561n/8E8PjNrXiP9nbxZqfjnV7rWr/AMI6hdzST3s73ExtDbJOgaSQs2AyyAc8AV+eHxB8f3XjH9if4IfCuyfztQn1/U4CgPJazkKQg/8AAL9APpXXfCjWD8AtP/ax+D7TtttNJuoLZnOGZYrl9OjkHu63sbflVSyiP1SdK3vOba9FJRDn1ufSX/BMDxR8SfiFrnxC8V+OPE+qa3a2MVlbQRXt7PcQrLcvLJIUSR2VSojUcDgNjpX6+EhRknAFfmz/AMEtvC39jfs8X/iGVMS+IdauZVb1ht444FH4Okn519xfFv4dWXxa+G+v/DfUbySwttftjbPPEoZ4wWDZUNwTx3r5nP5Qnj5raKaXpbRmlP4T8VfEA+LH7W37ZvjT4VN8Qb3wppeg3eqQWohaV7eC30yb7OAlvHLCpeQgMzFgTk8nAFfvZJJHDG00zBI0BZmY4AA6kk9BX80vwR/Zh0Lx/wDtXeJ/gZea3c2lj4Uu9VWK8jjRpZf7LuhCm5T8o3jk46dq+vf+ChfizxZ8Rf2gvh/+zHpmqSaZoertpy3AQnZJd6ndmBXlQEb1hQKyqT1Ld8GvfzbLo169LDU52io322Xfzv26ERlZNs/ZDTtX0rV42m0m9hvUQ7WaCRZAD6EqTg1eZ0T77Bc+pxX8+Hxx+GN1/wAE+fjT4D8XfC3xJf3llqUZmuI7llDzJbSoLiCXylRHilRxgFcqeQcgEe4/8FdSGPwnZTkEa4R/5IV5MOHozrUo06l41L2du2+ly/aaM/ZSXUdPgvIdOmuoo7q5BMULOokkCgk7VJycAEnAq5X5ufAP9i3xP4d+KPhf9pb4gfEKfxD4qaKa6vbZ7XMRa+s5IfKjmMuVWHzflwgXC7VRRjH6R14mOoUqclGlPm01dra9tfzLTfU/me/ab+NXxn8P/tHfEGx0DxxrtlY6brVyIbeDUrpIIY0kwqiNZAioDgYxjtX60/tl/Gy80f8AY5Tx94S1CbSr/wAZx6Sthc2srRSx/bdl03lyIQwJgRxkHODX5Z/Efwh/wm/7UP7QOiKnmSRWXiC+jAGSX09ku1A9yYsfjiuj8T+N5PjT8Cf2ZfgbDMZbq81aexvUB5QQXSWVof8AvxMxz2xX6JiMFTqfVpW+Gzfpy31/8BOdN6nt3/BMf4jfEjxh8XfFmmeNvFGra3Ba6KXSDUb2e5SOUXUK7gkzsFYAkZxnqK/aa/1LTtKt/teqXUVnADjzJnWNMntuYgV+Lf8AwTtjjh/aw+LsUShES31BVUDAAGpIAAK6HXv2Rvjn+0x+0H4l8UftINfeF/AloLttJaC9s5tkEcoS3hijWSYRZizJK7RjcwOcFuPCznBUquMm5zUIqKfntslpcuDfKfsTa3VrewJdWUyXEMgyrxsHVh6gjINfmT8f/wBqL4teAP2x/Anwc8M6hbQ+F9duNDju4nto5JGW+vDDPiVhuXKcDB46ivmb9hLWNV+Fv7XviX4HeHfEJ1zwjOdSgVkkD28zWRLw3SBCUEhVSrFTghiOcDHz78ef2Z9D8B/tZeGvgraa1c3Vl4wvNM827eNBLD/at4YX2KPlOwcrnr3rXL8jo0sVKnVlzLlutOj6+TQSm7XR/SuGDDKnI9qzbfW9Gu72TTbW/t5ruHO+FJUaRcdcoDkfiK/Kf9rx9X/ZI/ZA8J/BP4e63ck6hfT2MmocQ3DWbvNdzIDGflLPIqEg8pkd6+LfiT+zJ4W+Ef7PHhD49+DfH0svjSYadd3VtDcRIbc3sfmD7P5REyPCxVWJY55Py9K87B5BTqxU3VspNqOm9ur7FOpbof0eMyqMscD3qne6npum2/2vUbuK1gJC+ZLIqJk9BuYgZr8sPjv8RdV+LH/BMy38fa8wk1PUodMW6kAA8ye21KO3kkwOAXaMsQOBnivnr9mz9i3xP+0d8GfC3jfxT8Qp9L0nSpbmDRNMS1+0wwRRXcjTOwMsYDSTl84GcAZYjCrlRyOCpSq16vKlJxel9gc9bJH6B/Fj4D/Hbxh+0f4V+JvhD4gHRvBmkTaU97o32+8h+0paXPm3C+REphfzY/lwxw3RuK+3HdI0aSRgqqCSScAAdSa/EP8Aax/5SQfCr/r98Lf+nGvpH9uD4T/tLfHXxn4W+Hfw9spoPhwVgbVryO7tolM805SRpoXmSWVLeIK6qFIJY4ywGNa+X+0WHjUqJJxve1rL79WHNvZH6NadrWj6wJDpN/BeiI4fyJUk2n0O0nFfmB/wVG8c+NvBHhbwDP4L8QahoEl1eXyzNp93NatIqxxFQ5iZSwBJxnpXwx8f/htY/sO/G/whqXwc8Y3N/dpGt1cRyzRfaInjlAeGdYQoMM6fwOvI3DnrX19/wVt/5FH4df8AX9qH/oqKu3LcqhRxmHnGXNCd7XVtl2JlO6Z+n3wru7m++F/g++vpnuLi40fT5JZZGLu7vboWZmOSSScknkmussNX0nVDKumXsF2YDtkEMiybD6NtJwfrX5J/tz+PPGvhL9kf4VaH4ZuZrHTvEdpY2+pTwMULxx2KOluzDosp3Mw/iCYPGQfO/h9+x34v0Sx+HPx0/Y58crrN5cxpJqbXtwlvbq4VGkhZYlLGMtujlgcM68c56efHJYSp+2qVOXmbS0007voVz62sfuDX5j/8FP8Axp4x8FfDTwfe+DNev9BuLjV5I5ZLC6ltXdBbudrNEykjPODxmv01iMjRo0yhJCBuAO4A9wDgZ+uBX5S/8FZf+SV+Cf8AsNSf+kz1zcOxTxtNPv8Aox1NmfI03gP9tPwb8DdO/ab0n4rahe6I9tBfPajV76W5ihmcIGkgnBhkVWI3Dc3HOCAcfqn+yL8c9c/aR/Z/fxBrDpb+JrKS50m9mjHlI9zHGrxzqq/c3JKjHbwG3bQBgDxO+/5Rer/2KcX/AKGtee/8Eyif+GcfiSO39pXP/pBFXu5hJYjC1Kk4pShOyaVtCI6NH1H+yL8EPjd8Gz4r/wCFx+Oz42/tf7D9h/067vPs32fz/O/4+gNnmeYn3eu3noK+vbvV9J0+eG1v72C2muTiJJZFRpD6KGIJ/Cvxl/4JMz3FrYfGG5s4ftE8UWivHEP43Vb8qv4nivmr9n74T6T+2n418eXPxa8eXVh8QJYxcaZC+z/SJG8wyZWQEmKAhB5Me0qh44HGOMyb2mJryr1LKHLdqPdLon06jjPRWP6QKzL7W9G0uWKHU7+3tJJv9Ws0qRs/+6GIz+FfFfwHtfjz+z7+zL4rm+OE1vqd74NsL7UNLK3LXUv2W2tmmFvM+BkI6EJhm+U7cgKK/Nb9mf8AZbuf21NJ8dfFT4k+ML9dcS7NtbSjZJvumi80vNvBPlLuRVjj2YGQCAAK8zD5NTftJ1KqUItK6V73Kc+yP6EKz9R1bStIiWfVryGyjc7Q08ixqT6AsQM1+bP/AATZvvjdpHhbxL8Ofi3oWtaXp+jNbTaPJq9pcW+I5vMWaCJ51XKIURlVSdu5ugIr4o+D3w4uv+Cgnx88d+Ifid4jvrPTNLjea2jtWUvDFLMUtoIhKHRI0RSWwuWPJOSWq4ZClUqqpUtCFrtK977aC59Ef0ExSxTxLPC6yRuAyspBUg9CCOCKcro/3GDY9DmvxZ/YE8R+KPhj+0h4+/Zf1PVJNW8O2LalHAkhJjW5064EfmxoSQgmjLF1HU7c5xVf9gq2f4RfthfFH4KzkxW7RXsMAP8Ay0On3YMB/wCBQSOw9qeI4f5Pa2nflSktN0/npb5gqmx+13mJu2bhu9M81S1DVdL0iJZ9WvIbKJjtDzyLGpPoCxAzX4t/sL2n/C2v2zPif8apR51nYNqE9u/UJJqVyUtwD6C3WVR7V4t8PvC9j+3P+0P431v4yeMp9E0bTVmlskWeKNo4mn8u3t4PP3RoiIMvhSWIyeWLVr/q7GNScZ1LKCTbt1fS1w9of0MQzRXESTwOskcgDKykFWB6EEcEU7ehbYGG70zzX4ofsB+K/EPww/aW8afs2/222t+F4jqC2h37ovPsJhsuIhllQTRbt4U4J28nbXi/iPwZ4y+I/wDwUI8afD/wR4gfwte+IL6/tp9RjBaSGzFt5lwEClWLPGhQAMuc4JAyaS4c/fTpyqWUY817br06fiL2mmx/QXb6ppt280dpdwzPbtslCSKxjf8AusATg+xq7uULuJGPXtX4yfHf9iS0+Cf7I3jW10vXZPEsthq1jr8byWwt5I1iU2ky/LI+4eXMznp93vwayvFvxg+1/wDBLPRLdp8X17Pb+GW55X7HdNKq/ja24z7Gs45HCooyoVOZOSjtbpe+4+fuj9r1ZXGVII9uadXx/wDsH+Bf+EE/Zc8GW8sey61qGTV5jjG77c5kiP8A348sfhX2BXiYuiqdWVOLuk2r+haegUUUVzjCiiigAooooAKKKKAP/9H9/KKKKACiiigAooooAKKKKACiiigArNhGzVbsDhWihYj1YmRSfrhQPwFaJOKy5GZdYhC8CWCXd7+Wybfy3t+dNDSMzXNFTxR4V1HQXuJLWPVreeHzYjiSNbgMNy+4DVx3hf4Z6Z4b8FReBri5e7MeXiuioR0kDb1aNeQhjYBguSDjPIJFel2IxZW49I0/kKydc1u308JZQwtfajcDMFrEQHbH8bMeI0Xu7YA6DLEKbjNrRDaW55RPrXhDUvENjo2pXdrpPibTS5nkVMRO9v8AMikkBHjYnzQhfcmCAVfkfD9z/wAFAFuv2rNF+ENz4cgutMt9Vm0eGaC4JlN5IDCl8pcLGYSN230ikL7jwD9qQ/BeK48Tp4v8R3C3t/HOb0WES7bVpd244ZjucqTxvwNwB2qKs33g3wNffHvw943i0KwfU9R8O63BPfNaRfaZRHcaciRySld52o0qbSeAWUjqK6I1IK6avdfcZtNnp94vieeCS4vL630S1iUu5gX7RKqqMk+bKFRcDqPKb6186/ED4O+E774T6he6/ZyX2qa2Abv7TIXaVtRlCtC4+6Aol2jYFI2givUvFPwx01bRLDwbqF54Wl1GVbcx2MimyMRBeZTZTLJbLujVstHGjk/xjOa8++Iur/Gfw7b6NYa7oVl4206bVbQmbRH+w37iFjOU+wXsjQt8sZywvVJI4jGcDKnJppxZTR41+z94S0bwtb+Ivgr8TNJXXtS8C3X2YX7IzXU+lsitY3RRTl0MBRZDHkrKGBDEOwT45fDHwh4i1Dw98G/gv5uma/44Vri/1Gxu5nj03w/GQt3dn94y75iwgtxwGdmP8BI5X49ftQfCzwJ498M/FDS01W18V2MUljq2jXOmXNleyaeN0sTSLdJEjiOUukRVyjCeR1LFAK9m/Zr/ALK+IXhC7/aL+Huq2154g8eTtcalCVK2saQMyw6YRtEkTWikgyqv7yV5JijrIoHU41IJVWmk9uzEpq9keyeDPgtafDjw9p3hXwF4k1TS9K0qFYLa1doLiGONBgALJET7nnk89a4z43Wniu18OWNjqWrDULG5ufnxbiF9yKSgZlYqwPJxtHIB7V7joHi+w1q5l0m4jfTdZtlDTWNxgSqOm9CCVljJ6OhK9jg5FeH/ABD1a++I/j20+GPh2XZZaUwudTuQMrGQMFc9PlVsY7u2DjaTXNTbc7yKmtND8wP2kvEmkfCyfw344s4g/iDfPaxxn5Y7myZQ00UzDnaj+W6EZIccfKz59e/ZP/a08R/GzwRqXw70nwdqmrX+gT5urTSp4FWW1uc+Uj3l1Jbpbws6SeZgtKw+WNTyavftrfs06d4z+FiajZ6pKbpdU07T/D2Its13fatdRWYXO7Bt9rlyduZNm5dqgM/0P8A/2DfAf7Onhq8t/AXiLUz4p1KRZbrWZWVWm8sERwmCPaghTcxC5LEsSzMMAd2Kq0HFckde5jTjLqyfx54Y/av8beD7vSZtZ8PfCfw9cRJZJYaPA+tak0Vyy24ha6uFt7aHIfGYoHK/wt0I84+LH7F/7N3gj4Z+MPir8abnX/iLqWiaRd3Dalr2sXEt0hSIlUthEYooyz7VjHlkA4HTr7/4m+IHxA8DnT9I+JelDUNOkvrZl1OyAAb7O4uBuXhdxMfQ7PbNcN8ffHngT4tnwP8AC2HVI5NC1XUV1vxEjAhhpGhNHOYJIyNx+03r2sQA+8pfbnBxxxctO3kaH4jWX7NNn+zX48+Enxa+NVq/ifwyJdNvPEunTRlV0xr1VeBpFQ5kWAuhdW+VpE2HKyAV/Uqj2WpWayxtHdWt0gZWGHjkjcZBB5DKR07EV+cvjvxF8PfiL4z8Q/8ACY6ZcX3hHxHZPp1zDtQTeU8Cxb1G7CsrqHQ5ypAYfMMV1n7CvxCvYvDes/s6eLNR/tHXfhi6Q6fdsCp1Lw/MT/Z9yobnMagwSKM+WVVWJY0VXzK/VAj074yfATwfqUdt4l8OxroOo/abW0ZbWJRDMLu5jhy8Y2gMpkLblxnnOeCPB/2rPCPg34F/Bf8AtLwolzdeO9auIdH0SGFttxqWr3zbYsqhU/IMvgEDau05JyfvnxNB9rl0WzP3ZNQidv8Atgkk4/8AHoxXyL8PtK/4aI/aGvvjvqg8/wAEfDR7rQvCEbcxXepZ8vVNVUdGCuv2aBhlSEZxggGnRryit9AcUzyz9iv9lvRvCHw5hvptbvI/FMF482pOot5opb9lV2kYTxOzhchVOR93PUk19y32jfFNIJbaDVtH1m3mUo8N/YSRblYYKs8UzKQRwf3VeNfCHxLpnhLxl418O6vcrAn2p3hTBZ3aKV4ysaLlnZgy4VQSccCvd5J/GfiX5NOT/hGtPb/l4nVZb519Y4TmOHPZpN7djGDWdWTcrsaPzD+Lnwr8efs963/wm/wHe1+GGpeIJyl7p+nXv2rQNRO0ks2nSwq1tIMACaHAQcBctk938IP21dF+Hvhy90f49NdaNPpdtGbOAQNdGfYQnl2k0K7JVwQRvKsmDvwOa+1vHHgjwnoHw48W3z2S312+mXTy3V7/AKTcSvHEzJukkyeHAKqMKpxtAr84/wDgo98Orbwr+yX4U8S+H3i0u58NXdobmJVCG7a8gEMjkj70ofaQT/Du56V14WrTk+WqtH16mc094nF/slftofCD4ceG/HWn3stxN4h1HVr6/sdKZBDLezX1/dTRKJmJhiVUlTzZJHVYwpJyMZ9ruvht8NfH8l18cfjN8TNKn+JrIsunSWdyBpWhQR5ZLS0U4eQ8/vLk/vWbBUKvyt+R/wACP2XP2gtT1kfEhbweAHtoC9hJcxR3cl0Z1AIeDcQkZQnJf5s4wvUj7H0WX496ZdQeFviZ4Ms/GmgfvZJp/D1zFBcJEiFpJFtr8xxmTYpJ2uB6Z6VVaCUm4aXHF3Wp6Dc/tN/GXxzJbaL4c1+8ZrZAgmhY2wwP43Me1nPqzn8CTzVi8N+I9d+OPwq1nxn4kup7nUby80K91DO+5EOoW7PDGjvzjzoFRWPI8w8dq8w8IeO/A/hiaHRnS78Oi6Y/ZV1m0k0+W5XOFZWlHlyMR/zzkcZ6EjBr6B8X+HNNuPBWq6346b+yItCtbXxDYpdMbY3zWF7DKsULEqWMwRo1CncxcBeua6cOqfs3Fr3jOXNzeR+rGg/DfwP4b0KPw3pmjW4sYzuKyRiRnfGN7s2SzH1P0HGBXHfEj4XWWr6HFeeELWLTda0dvtFm1uixbmXDFDtAGTgFSejAdia8GvtO/ZFPgt/iJb+PYdJ8OJI0JvYtbKxiZACYQJmdvNwR+7xvORxyK8v0/wAB+KPiXMj/AAMk8TWWhSHjX/E0z6faOh6PaWWxL2545G9LeNhyJTXlqLvqzbQtfHz9tbwx8PrfwU66M+seL7CVtSuLIzfZYoAIZ7JxI5SRh5vmSFAFONuW6AHvPAf7aPhz4x/C++8ZeF/AuqX1rZCa01j7Q9vBptjMqjfDLdyurTBkkQgQQSuVdcxqTivjz9oH/gm94l12+svGV78Ubi5uLh1t9QvZrIhIEdjtbylmZvKDsckuWXcSS2ePMfAfw51r4I/D/Wvhi/idLuO08R6lDe2UM0wNxLbShI7uWHb5QDwpDtJbcQBgcZrrqewdKKgveW77kx5lJ3eh9RfDP9oDxr4O0GTRtQ8vT/DNrPNNAtkwlvbeGRt4i+0XUTRSKCT/AMuyMSeCM4ryjXP2SvA/7SPxPf49+JLbUdG8IT6jax6nA10rSXe/ZGsjoQ5jJZo2uGDqioWZV4IHJaBfQeK9SECEHSNOYF/SeYdB7qv+eox+kv7OOhJrvg7xVZaxD5+i6wRaGNshZFaN0nAxjgq6qSP6VtUoxhS9qnqQptytYofDL9mn4N+HNX8U+FdK0BtF/sy9Sa3fS7280yRbe6jDRqHs5oWO0qRknOc817lb/CmHTF2aB4r8Q6eh4Il1J9TBHcH+1FvCa474Z6vfzeJI7bXZTNrWnw3Ggaq54aW801kmt7hgOAbu0mW4AHRXA7V9D15U5O+5sfmdpnh34zeBvD3xl+GHwj1eS58SWCrdaXDOkCTyxyHDGGVRCkczQFNjEEbyPu8EeafsPeAPjR8VLbxgfjx4l8UaPYeFL2PR7bRxqL2V4HaJbm5S5njAvkiKvbmJVuEUgscFSpr7Q+Kmr2/wq+Luk/EuRB9k1rTLnTrjLBEM8OJId7HpvO1c9gteL+C/iveeHvj1a+LtcW1tdE+IUcelajNCxWJL6Es2mXDlmZeQzWZYYLF4AeErqVWbpuKWm+3X1IaV7n1zpHwr8F/DYDWfhz4ftdMuo8/a/s8Q+0X8LY3iaU5kmlGAyNIzMSNucMa9VtriC7t4rq2cSQzKHRh0ZWGQR9RRBc291GJbaVZkP8SMGH5iuXvdT0vwb5txq1ylnpU7F0eQ4WOZssyfR+WUeu4f3RXE3fcs8P8A2uPCdl43+Eh8N6juW2vdRtIXZOHQTFot6nsy78qexwa9L+GOs3fj34ZWcfjGJJNWWKfStaiAwhvrNmtLwAf883kRmT1RlYcEV4/8e/i94Gfw9a+GtMuv7Wv7uazvYxalXjjjt7hJD5j5wCwRlCjJz1AHNdH8J/iB4e8R+OtcbQ1ktofEkUeoSW0wAeK/tkS2nOQSpWaAQFAp5MUrEAmtVBuF7bCurnqPw6ubqPRJPDWpSGS/8OTHT5Hb70kcYDW8p9TJCyMT/e3DtW9c+FfDtxdSagbGOC8lOXuYM29w3+9NEUcg9wWwe9cJ418TaP8ADzxVpmv3zs3/AAka/wBmfZIFMlzc3MW6W2MUS8sRmRGPQb0LsqKSLklpqutiO88dR+Tbzn/RtCgYSlz2+1SAgTMB95ARAmTuMuFkGduoz4j/AG0NN+NvxB0nRPD37PWrzTQaEzazqDyXSWqFImCWbQ3JAeUI4kfBZg5UFS7LgfQ918I/EGs+AvD+k+NRDeXml2CRX01iAj3c7opupfKl2qpkcM27eWOclcnavo3hHQ5PElhrvizUiouPErSJbAfNHDZxIYLcr03bl3Shj/z0OAMkV6pY3QvbC3vtuwTxpJg9tyg4/DNbOu0lFdP1FymJoOq2v2aPS7iVkurbEWJ1MbygDCuA4G7cOpXI3ZAPFayt/aByv/HoO/8Az1/+w/8AQv8Ad+98/wDjLwj4+8QeNtJ1rQNTKeG7KKOC5gEjKrLHKzOzRAYnV4mUAHIPIA5596ljtrW0ae0kMCEDZsOU+bhdqnKjJI6CspRSSdwILZcaJ5A6lTCD68+Wp/ka3a+YPg54S/aG0P4h+ONQ+LXiOx1bwnqV4snh+ztg3m28CvKwMgMSeVhDEpQPJlgWLdS/0/RUik7J3BMKKKKzGFFFFABRRRQBVvryDTrK41C6bZDaxvK59FQFifyFfh/8Gtb+OjeLvEXjv4QaW+oajd70vpFgScIt3L5235+AWaPPHpX7N/EDQ9U8T+Btf8NaLPHa3urWNxaRSy52RtOhj3HaCeAc8CvFf2ZfgVqvwN8P6zp2t31vqF3qt0ku+2D7RHGm1VO8Kc5LH8a+gyrHU6GHquSTk7Kz7dTCrBykj4y/Yw1DWPDHx917wp4kgaxvtRs7mOa3YbCl1BKkuNo4GF38Cuh+EH/J8viv/r51j+Zr33/hm7xTZ/tLH436TqtnHpj3PnPat5gnKyW3kTDhduSSxHPpmuF8d/sofE+b4y3/AMTPhd4qttETVJnneSR5Y7mB5hiZVCI6yKxJIyy9cHpk+vPH4erUnLnS54W9H2MVTkktNmeeP/ykK/7eR/6aqT9rj/k6L4f/APXrpX/pxnr1zwP+yX4o8GfG7TPibN4nXWrOzYyzvdmRr64mktmikcnBXmRiVBYkLgEk1037TX7M+sfGbVtK8W+EdVg07WtMh+zFbkukbxq7SRsskasyMjM38JzkcjHMQzDDxxNJ8/uqHLfz1G6cuV6dTlf+CgCMfhZoEgHyrrMYJ9zbT4/lVf4pyRn9hDS8MPm0nQlHPUiW3yPwwa9Vi+BHiHxl8BU+Fvxb1w6lrwkknXUklkujFMJGaFg0wRnCo2xgcfKSARwa+av+GO/j3qWl2ngLW/HlofB9nLvjhWW4lKDJOVgaNVyMkhTJgE8GscFWoKnCnKol7Od+uq8hzjK7aW6JdGRl/wCCe1+zDAcyEe4/tRR/MVsfCL/kxnxX/wBe+rfyr6d8Y/BOC++Ac/wT8HTpZoLaC3gmuckZinSZ3k2Anc5VicD7x7CuW8E/AbxB4X/Z41n4OXWo2s2o6lFeolwm/wAhTdfdzlQ3HfioeY0pU5a6upzfLuP2buvQ8L/ZH/5Ng+IX/Xxqn/puhqn+wfq1noPgT4ga5qDFbXTnhuZSBkiOGGR2I/AGvoD4J/AbxB8MPhF4n+Heq6ja3d5rkt5JHNDv8pBc2scChtyg8FCTgdKzfgF+zhqfww8G+L/B/i7UbfUIPFKCJjabwViaJ4nBLqOSH461WLx1CUcQub4pRt5rqEYSXKfNngLRvGn7aPi7U/EPjvV5tM8E6LOqx6bavgFnyUjXjbuCjMkrAtyAoAPyt/YOhitvid40t4BiKKz2Lzn5VuABz9K6Lwt+x38bvCd7qOg6H8QYdJ8Mao225e0edbiaIZAzBtVA20kHEvQ4yRXsv7Of7NWvfA/xjrus3uq22oadqNubeBY94mULKHQvlQudo5wevTiuvG46gqFWnTqLlaXKktu/zZEIS5k2j5+8O/8AKQa4/wCvm8/9Nj0v/BQv/kPeC/8Ar2vP/Q4q9N+NP7KHjvxP8UJvin8K/EcGkX94UkkE0s1tJDMsYiLwywo5w6jkEDqeSDgbfxz/AGZfHPxf0nwTCNdtI9Q8O6cLW9muWlc3Fwyxh5FYISQWQnLAE56VNHHYf6xh67mrKNn5WT/zCUJcso26nl3/AAUQRivgCTHyj+1AT7n7Lj+VfX3xD+MXh34L/DrRPFniC2uL61vGtrREtAjPvkgaQN87INuIz37imfHz4Jab8cPB0egz3X9n6jYS/aLK627wj42sjrkEo464OQQDzjB+Ro/2O/jd4rbSPD3xM8dwXPhnRiFgigmnuJEjUBcRpLFGinaNoYs20dARweHDVMNWw9KFaduRu611T10NJKSk3Fbn6C+C/FNn438J6T4v0+CW3ttXt47mKOYASKkgyAwUkZx6E18Y6/8Asd+OtZ13UdXg+Kt7aRX1zNOsKwTERLK5YICLoDCg46D6V9yaPpNhoOk2Wh6VEILLToI7eCMdEiiUIi/gABWjXi4fHzoSk6Dsn5J/mbSpqS1POfhP4H1H4ceA9O8H6rrEmv3ViZi15KrI8nmyvIMhnkPyhgv3j0/CvxV/4KJIkn7ZHhCORQytp2jggjIIN7PkGv3wr83f2n/2K/HHx0+O+hfFfQNe07T7DSraxgeC5E3nM1rcSTMV2Iy4IcAZPWvV4fx8IYuVavK10/vfoKcdLI/Qaz8MeGtOuUvNP0m0tZ487ZIoI0dcjBwyqCMg4r8XP+Ct3/I2fDn/AK8tQ/8ARsNft/X58ftr/sf+M/2nda8Lan4V1vT9JTQbe6hlW9EuXM7owK+WjcDac5rLh3FwpYyNSrKyV9fkx1FdWR9sfD3/AJEHw1/2DLP/ANEpX4ff8FKmW2/ay8HXNwfLiGi6W5duFCrf3WTn0GOa7+D/AIJx/tQQLHHF8WrdI4wAqreaiAFHQAbcYAr7d/bA/Y90n9p7S9N1HT9TXQ/FWhq8dtdSRmSGaCQ7jDMFwwAb5kZclSW+Vs8elgKmGweLjU9qpKV07J6diZJtbHz/AP8ABWKaIfB3wdCXHmPr25VzyVW1mBIHoNwz9RXv/wCz/wCEj42/YU0HwTMnOveFrqyAPrdJKin/AMeBB/GviLSP+CaPx58Ya1pdt8bfiVb3vh/SsRxLb3d5qNxHAMZjt1u4444QwAGQSBwdrYwf2Y8N+HtI8I+HtM8K+H7cWmmaPbQ2lrCvIjhgQIi5PJwoHJ5NYZliaNLC0sNRnzOLvdbBFNu7P5e/2T9J1Lxt+0H8MfAt0WksbDXhqQgYcKYAlxcZH+0lqoI9q9e/4KH6Rf8Agf8Aae8XNYObe08a6bYXMqDgSRfugw+huLTf9RX6M/Af9hbW/hF+0vqvxovdYsLrRGl1STTrSES/aIRfOyxB9yhPkhdlbBPPTitT9tP9i3xN+0x4r8OeKvCWs2GkXGlWUllc/bRKTInmeZFs8tW+6XkznHUYr6B8QYd4+E+b3OWz9b3/AERHs3ynvv7HXhb/AIQ79mH4c6OU2NLpUd8w6HdqDNdnPv8Ava+lqy9D0i10DRNP0GxGLbTbeK2iHokKBF/QVqV+e4qt7SpKp3bf3m6R+IP7KP8Ayki+KX/X74p/9OFH7WCmD/gpB8LJZvkR7zwuwJ4GBqBGfzBr64+DP7H/AIz+Gv7VXjD4+6prdhdaT4juNYmhtIRL9ojGo3PnoH3IEyo4bBPPSt39sL9jl/2jbjRfGfg/Wk8O+M/D6eTBcSh/JnhDmWNHePMkbRSFmR1DY3MCpyCv2P8AalD67GTl7rhy37Oxlyux8X/8FbSJPE/w1hT5pPsmpfKOT80kAHHvg1q/8FcVKR/CVG6quuA/h9grvPBH7A3xn8XfFLRfiH+1L4+t/FUGgNE0NtbzT3TzrbvvSF3nihEcRf5nCqxYZHBO4e6ftufsm+L/ANqE+DD4U1mx0j/hGv7R877aJf3n2z7Nt2eWjfd8k5zjqMd6vC5hh6NbC0/aJqCld9PeE4tpn2r4T/5FbRv+vK3/APRa1v1m6LYvpmj2OmysHe0giiZh0JjUKSM9uK0q+Gm9Wbn4h/BbT7XV/wDgpV8SNKvk8y2vTr8Eq/3kkAVh+INfPH7EHw41CX9srSfCurbpU8DXOqT3CHOEksleEEA9P35jJr9Rvht+yN4x8Fftc+JP2iL7WrC40fW5NQeO0jEv2lBeY27soE+XHOG+ldx8IP2XZvhl+0j8SfjjJfW09p4yDizt4w4mgNzKlxdeZkBfmlQEbSeOuK+5q55SjCpGEt6cV89V+pgoM+Fv+CeP/J2nxf8A+uGo/wDpzSqd/wCJviZ/wUJ+PmufDDSvEM3hj4V+GWkeeO2OGubeKXyleReBLNO3KB8xxLzgsDv+vf2Yf2RvGPwL+NPjj4m6/rVhqFj4pjukhgthL5sZnu1uBv3oq8KMHBPNfOKf8E9v2gvh98UNZ8QfAn4k2nhnQdZeVTN51zDfR2sz7/JaOOJo5DHxtbzFzjPyGqeOw0sTUqqaUuWPK2tE+vz7ByuyR47+yt4M0P4d/wDBRPVPAvhsSDS9Ck1izt/NfzJPLigZRvbAy3HPA57Cuu/a2/5SOfCv/r88Lf8ApyNfQf7P37BnjH4GftC2/wAVH8WW2v6NDFcpIZxKuoTSXVuVeRhhkyZiW5cnb1Jbrvftk/sT+Lfj1430b4pfDHxDbaJ4j0y2itZEvHmhRvs8jSwzRTwJI6SoXI+7zhSCpBy5Zph3jYzdS6cOW/n5hyvlPNP+CtEbn4deA5gDsXVbhSewLQZA/HBryTUP2Iv2XPBHwL8NfGv4neMfEen2Os2Gm3ExtTbTKJ9QhWQLGi2rOVyxxycAcnvX3LrX7KniT4r/ALK+kfBb42eJTqHjLTZJLtdbSWW92XgmmaFi04jklUQy+Uwbbx0PCmvjgf8ABPL9qPxRpmj/AA28f/FKxl8A6JKGtreKe7uWhVcqpjtpIYk3KpIUGXCAkLxmoy7H04UI0FX5eSTv/eXlowlHW9j0L436b8PdI/4Jmmw+FV/eap4Vje1Njc6ggjuZFfWAzl1CRgYkLBflHygdep+h/wDgnX/yaP4O/wCu2p/+l89db8af2ak8ZfsxH9nb4dXMGkw2sOn29pLebmQJZTRyM0hjUku4QkkDljmuu/Zd+EGs/Aj4J6F8MNfvbfUb7Snu2ee13+UwuLmSddu8K3AcA5HWvIxWOpzwUoKXvOo5a72tuy0nzH5h/tY/8pIPhV/1++Fv/TjXuH7cv7Q/xNt/iL4b/Ze+Cd22la74o+zLd38b+XMpvpTFBBHKOYhxvkkX5tpXaR8wPpHxo/Y/8Z/Ez9qnwb8fNL1vT7TSfDdxo801rMJftEg0268+QJtQpll4XJHPXFc3+1z+xN48+MfxR0j4yfCDxLa6F4isoreOUXkk0ASW0ctDcQTQRysrrkAjaPugg5yK9LD4zCynh/aSXuwe+yl0uS09bH5oftkfs16F+zbd+BdHtNVuNc1rXLa6utVvZzgS3CyIB5aclUGT94sxOST0A+3v+Ctv/Io/Dr/r+1D/ANFRVz/xA/4Jt/HT4jHTfFPi/wCKNt4h8WuHS+kv/tDW8USbfIitmCliAfMLZWMcjC53E/Xf7an7Lvi79p3QfCumeGdXsdIm0Ge5mmN55pV/PRFATy0Y8FT1Arrea0fbYWU6qly83M9ev9aC5HZ6G94rufgHe/s1eD/Bv7QGq6fp+j67oenLDHdzrDO0sdtFiS2H+s8yIsDuQHbnDcEg/mN4o0D4tf8ABNX4u6XrXhzV31/4f+JZWJgc7Vu4YSvmwzx/dS5jVwY5l4PUfLvjH6WfHr9kTTvjp8EPC3w71DUk07xH4PtbeOx1FUMkQljgSGZHQ7WMUuwE4wwKq3OCp+PrL/gnt+0R8RNc8P2H7Q3xMt9Y8KeHMJBDbXN1d3HkfLujj8+GJYzIqqpkLOwAHDYFceUYvDwhL2lX3W3zRa37OPn/AF2HNPsfsJp99bapYW2p2bb7e7iSaNsYykihlOPoa/K7/grL/wAkr8E/9hqT/wBJnr9V7a3gs7eK0tUEUMCqiIowFVRgAewFfHH7aX7NPij9pnwd4f8ADfhbVbPSZtIv2u5HvPM2srRNHhfLVjnJzzXg5HiIUsZCpN2in+hpNXR4rrF5a2X/AAS6ilu5ViV/C1tEpY4y8sqIij3LEAVxn/BMy1nj/Zo+Il46kRTapeIh9SlhDux9Nwrzi3/4Jj/HPWLOx8M+Lvirbnw7ZlfLtka8u44VXj91bymOMEA8YIr9S/hl8E/DHwf+EcXwm8E7ltYbaeMzzkGSe4uAfMmlKjqzHoBgABRwBXtY/F4enh50adTmc582i2REU73Z+X3/AASUu7TT7b4vX9/MltbW0eiSyyysEjjjQX7MzM2AFAGSTwBWv+0P+y/8PvjENf8A2iP2RfE1tJ4g0C5kn1K30yf9xNdwoJ3ltJoyPLuMEP8AKSkjcgq+4t9KfsX/ALIPiX9m608dWHjjVNP1628Xx2EQjtRKVCWwuVkWQSouQ4nAGM9DmvnHVf8Agnv+0F8P9a8Qaf8As6fEuDRvCPiTclxa3dzdWswhbIEb+RDMspRWKiTKMQegya6p4+jLH1a1Oty/Da/wtWV0yeV8qTR23wX/AGifEv7Qv7FHxdtPGX+k+JvC3h/VbS4uVUD7XFLYTNBKyjAEh2urgDBKhv4sBv8AwSdkjHwf8ZgsAV10MeegNrFyfbg19P8A7Lf7KWg/s9fDDVPBGqXa+IL/AMTMz6vNsMcMqtH5QgjQkny1UsMk5Ysx4BCj4kuv+Cev7Rnw61bX9M/Z9+J1vpXhTxFmOeG6ubq0uDAdwVJBBDKjsisVEgKE5PC5IrneIwlVYjDwmoRk003t5/8AAHZqzPuP9m/9rvwL+03qOu6d4M0fU9NPh+OCSZ75YVRhOzqgTypZDn5CecV+eH/BKAGD4hfEm2l+WVbK0BU9flnkB49ia/Qz9kf9lvS/2YPBV9pJ1Aaxr+uyxz6jeKnlxnygRFDEpJOyPcxBblizHAGFHyf8QP2CPjF4Z+K+s/E79lzx5b+FR4geZ57a5lntWgFy/mSxJJBFMJIt/wAyqyLs4AyVBrKhXwl8RhqUuWMkrN36f5jaejPI/wBmhTN/wUu+I0kPzrHe+JCxHIAFzt/mcVlftjard/s7ftrRfF/S0ZV8Q6DPOuwYVrmSyn07b9QyxufqD1r7k/Y+/Y2n/Z41HWvHnjfXE8R+NdfjMMs8W8wwRPIJZQskuJJXlkVWd2VegAHUmX9tf9knWv2n7PwrN4X1Sz0jU/D0l0ryXgk2yQXIjJUGNWOVaMEZGOTXUs2w/wBfV5Xp8vI330/zFyvlPMf+CWPgb+wfgZrHjWePbP4p1V9jY+9bWKCJPylM1fnV+x7+zH4M/aT+IXjPw3451LUNLGhxC4i+wPEkjO05jYP5scgwOOgHNfvn8Cfhkvwb+EHhX4aebHPLoVmsU8sQIjkuHJkndMgHa0rsRkA4PNfn38Rv2Cvi/wCH/i3rHxV/Zd8d2/hV/EDzSXFtcyz2rQ/aX8yaNJIIphJEX+ZVZF2cAZ2g1OEzmMq2JftOVztyv0en4A4aIj/Zg+FH7KPwz/aau/DXw08W+INW8deHo9Rs57S+ij+yL5X7qfMiW8YJU8DD4J9a8i+GP/KVfXP+v3V//TfJX2X+yB+xpd/s+6xrXxD8e66niXxtr0bQyzxb2hhjlkEs2JJQJJZJXVWZ2VTxjHJJzfCP7H/jPw7+2TqP7Sdzreny6LeXF7Mtmgl+1AXVs0Cg5TZkFsn5ulKeZUfaV71HK8OVN9X5aByvTQ+2vHnhSz8eeCPEHgnUMC21/T7qwkJGcLcxNGT9RuyK/ln0/V/Feu+F9E/ZhWJ47lvF0k2xudt5dJDYKmP9llbP19zX9XN9qFhpls15qVzFaW6Y3STOsaDPTLMQBX4NfBnwb4a+I3/BSnW9S8JyR6h4e0bV9S11poCHiZoslXRlypX7ZIu0jgjp2qeFcV7OnWclpFcy9Vf/ADCqtj93ND0ex8PaJp/h/TE8uz0y3itYV/uxQoEQfgAK1KKK+Nbbd2bBRRRSAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigApCcUE4plA0g61wPi/wAe+DPB2r6JYeI9cs9K1DWZXtrKK5mWN7hmAGxAxGSZPLA9yF6nB76vnP4+fs2eCPjrJ4f1rXbQSa54WuBPYTNPNCn3g+yURNh1DqrgMrYK46MwOlJRcrS2HJtLQ9wuJrrYlnYKUYqAueHwONxyCEX3IJPIC55qzpWj22liSRP3lzOQZpj95yOnXJwOwyfUkkknE8JaRqvhrw/Z6Vf3Q1K7gjAllckPIc8Yc53bRhRkA4AyRXRf2naIwjuibV2IAEvygk9ArfdY+yk1LJuW5oVmTaxKkHKsOqn1H+fY8V454tk/sDxp4V8QONqNd3NteKoO0RS2cshuE9FBgTzR2AB7Zf183lsPuvvPogLn8lya85+I8mpnSbXV/D9k91qOlXBltlYCNWnmhlto0beVO0vMu7AxjNOIHcqFutWWdSGjtYcKRyC8xBP4qqj8H/PlPF99p9hrmhX2r3MdnY6YL3UJ5pnCRxxwwGIu7NgAL53U9K8a+FHjfxT4T0Z4/ivZy6ZaXtzs0+SS3aN/OKgC0ESgsS2MW4C5blFyQoPoMHhy+8XeO7bX/GduqQaRaiWx0wkOlu80oKS3BUlZZwYNwAJjiYAoWdRKalDleoJn59/tb/skfGH9qvxTa/Fb4W3Fh4b8uzi02K0157i3ku7aKSWQXZWOCVrcky4WF13lAGfy3ylTfs4Wfir/AIJ6w/8ACo/jc0Gp+CvFFw2rQ+KNOWT7Np1/NHHFcQXsTjeluDGu24A2KMNIqBjs/WOvAP2hp7KLwtYAx79S+1q9o+AQhQZkLAg7lK8Fe5IzwK2+sTmlTlqlsiVFJ3Nb4w3nh+fwVDqkG261O42/2JcW0u2VbiZcxywzIeEA+ZiDtZRg5Br5l/Zq8MfFWykvB4qsrm8j1AfatQe+U28V1OTlAknlkunzE7V+Rhy3XB8I8I3XiLwH48sZtDsP7a8Gx3DJL4dR1hhtnuWHmf2V5hEcILY8y3YrA/KK0WZM/qjonjPw14h0J/EVheqllAWW4M4Nu9rJH9+O4jlCtDImfmSQKy9xSu4JxtuPfU+efibNr3i34xfDDwjPojzW+gT3/iu5iiniYObCH7DaAs5QD9/feaoOMmLP8Jr3aXxX4gh+94N1SQDvHLp5/wDQrtT+lcp4ISz8RfETxh4/tJo7q2Een6JZyxMJIpILSNrySWN1yDulvGjbB6wgHpXsgrGT6FM/OL9p39rjxL8MoNQS08LxW503y0jh1ZN7tNdRMod1ilMZjVXOFDHcRgkcgfl18KP2odO1f4u6pN8Rxa2z6nYIkNyvk2kcP2eVm8lUZ1jUSGYnIIJKqMEYx+5PxB8K/Drxz4T+I/iv4raNb634at7O4tTFcDGLLSUeSZ0kXDxsbjzcOhDDYpBBAx8N/B39nz4X/BP4O+C7TTfDYu/iX430+yvNYnkeSecLdJ5gtQsjMEQM4TYoAYpufJwa9KhiKapezcNb7mMoO97k9l4n0bXrT7To1vNewkffgEcq/mjkVm6V/a/hfxnafG3wlYXJ1fwTG0l7aKgD6loczAahaqobLyImLmAc/vIgoHzmvTvEn7BnhPxVdia88FaZZXT8/bLKX7BIrHuXtDG5I+h/EV4x+0L+wPq/w1+Cmu+Lvhr458Wa5e6ZAJrzQ5b1rq0uLXcBOsCMvmjy4iXwWYuFIxzinV9k5pJhG9rn0D8cf2tdA8YPH8MPgtqkN/qeqp5cuqWd1FJJp0FzEVnuI1QsBJFBIfLLsMTMgI4NfafgXQrHQvBGheFfh3ZpofhrTrKCCyLqGkFuqAJsjzjcRyXkJJbJZGzmv5G/hLc/EnxL8afDmlfA61Gs+LnnaS2sZJEjSaO1jaaWKYyPGm1okfcC6kj5Rziv1wvP26fj34Msbjw78YPgtq/hDUYwEfU9ChkYR+rvECITxnBZmwOQDUYrDwj7lN3t1HBt6s+2dIfSPh/+0hqF1qNwqLdSSRz3d043bbiISgs5wFUvtOBhR2Ar7ftL2z1C3S7sJ47mCTlZImDo30Zcg1+CXhz9ov4XeLp2Nh4vspryRjvg1cvpt1vPUGSVfLkcnsoGT3r33w58W9X8DLLPpd/caJBeph2cK9s6nowlXzIQf7rbg305rkqUpdS7n6IfHnxT4c0H4davY61fJBJqMS2yRZzK4nkWM7UHJ+916e9fnj+1j4i139qjxx8Kv2c/Dmj/AGfRdZ1abXLx5zhpbHRoWLqxHyokhkKDqPM2/MOletXmleB9Km0vUfiVrDa5qmozWV+LW1b7Uot450kMk8wOG3BCAob8xXYfCh/+FjftE/EX4yeF7eOTTNCsbDwbod3Khjtbe3gRb/UH2fKWJuJkjCLtP7kh2QYq4R5Vzdg8jz3xTcnwey2Os2s0V7ISkNqsZM8zDtGnf6/dA5JA5qb4O+ELHxD8TYH+K4Fr5MZex0hwRA0zgbftDHHmvsJKrjYT03d/TvEH7V3wO8C+JpvC3gma++LXxGuhsksvDsI1O7O042yzx4traFGPzLvUJyxQnJPNeIfhB+0n+0b5es/EW80/4P2MKk2un6Mw1HXGB5CXepNiCIA8gW8TMMnDg1vXxLmveViIU7H1b8R/Hvwo8I2MPh/4hXdm/wDaa+Xb6S0P226vQP4ILCJJJp8Y6Rxtivyt/bK/Z88Y+K/Cvh7xn8Cvhg3hjT9LvXhfSPPitLi9+3bVjli0yJmtYMOABl0ncyYaIEYr7v8A2efDPg34Z6jfeC77Qo9M8aS5a41S4Z7m+1dOvmS3s7PNM3GcFyMcqBggfSHjOzjvvC2pwySpblIWmjllYIkUsH72ORmOAAjqrEnpiuejXlRmpU3qipRUlZn4V/sA/DPxF4FtJP2pfij8Oodf8Ka2fK0+7gRL/VNFW0ldJb8WQR38pnyjmI/aIxGW8ooSR+8eg6/ofijRrPxH4bv4NT0vUI1mt7q2kWWGWNujI6kgj6V8WfsffEXwFoXw48U+DpNZt7W28KeJvEIt1lbYRYXF9JewMM43fJcAYXJzx6VwfjyO91HxBqN58J2m8N2OtSh7vw5AXQ+IJSwLySxoGGmvKMhpUUySA7popBt2uu5VJty3CKSVke2/GH4ya1rmla34M+Ddkms3cMDpfak6h7G0VxtIycq7dfUccBjnH5z/AA6+HqeD/EXje51i8kv9VSeK5e8lZixgurKNZOpPBdJQSeSODxxX6VfCzTF8WWUvhvWYP+EPh0nHn+FYMw3EYbhZLqYHdcJJg4liZo5CD85ZWUeS/GH4S+HfDmt+Lbu1e5J1zQ9Pt7G2Dj95Ot5PBIobG4gC7iI5z6npV0ZQScWKSd9Dy39mr4RSeJ/A1v4qvPBMt3ZXs8j2u3U0tIHiU4YlApkwXDDqMAACv0J0RfGel2EGmab4a0zSrO2ULHEL9yEHsEtse5OeTz1rh/hxp178FbTSfhprU32nQSiQ6bfHjZNjLW8p7FmyUPfOPZfVPFnjzwf4HtPtfivVYNPUjKq7ZlcD+5GuXb8Aa5pybdkWj8+f2hI/Enhb456V4h1v/RNK8XQxaYTbs/kJqFujSWkobC/PIvnQsxAbIhXptr698HaLr0ngqy1r4g+KNQslSIs8ZljtVjiBIQyShRIWKYJLPnJ55r5C/ay/aIbX/g54ltPC2gTRQWkVve2+o3jrbzw3FvcRyWt3bQk7m8mdUk3jOApLLjNfPPwD+L/if9qY6vqHxD0jxR4wn0K4ijePw4loNPzKpZR5l5c28cT8HciqTtw275sDqdFump2tbQm+ti3rd7H8R/Ed7ruth7lJncW6XErztBCSdqK0jMwwOpByTyea6f4c2nhPw42sWfiqOWfRL5LizuAmGlgDoDFcW4PCzxttZX6gjI5qtqHgT4h3PxI1bwx8NvhzrSJaRJdPa6leaRHLapLghGkgv50Ocgrlt5XqvBJ9t+DHw5+ImkfEKeDx34X06K62G5tbO+1L5JWEaI5BhtriN2iBDFcjG4MM7TjqoV4RpSjLczlBuSaO88GftG+B/EekW0UfgK81nxDaqLe+az06HY1zGAHePazOqScSICMhWFbHjF/if8R9NtbXw38OLrT1t5DIp1LUVgjwRj/VOpYH/dHqK+S/2pdX/bU8MftA+H4vhFpNxpela3JYW+ntpkhl0V7oZVxqLNHEmcAg+ai5iVQhJXj9BrT4H6hruLj4veNdV8Zu3LWUTf2RpA/2fsdkVeZD/duprgfpXHNRhyyi076+nkWne6aPzE8e+HvEHw28czJrGpWN5qmrOjyafpbNqbW0oRYxFIkYWWJiEBBdQhzwThq89+Pei/tIweAbDxt4a8Mahpek2zzPcPDci2nO1PllPzJtQAsF+c7y2ACRiv1k0vwtoF78aLLQvDemW2l+HfhzY70tbSFILdL/AFAfKFjjCoNsQDcDgivoy/Wzeynj1CNZbaRGWRHUOrqwwVKnO7dnGMc9K1o5jOl8BM6Slufm78JPEPiTwX4P0fwz8VLFtR8danZ21vqPiO7vGunSWRhLaiOYhwsVrmLhSqSSq0i72Yu/26WnufCizrKW1zXcWLzD70UrEpMIuwSACR1A4OzJLEknxn4e+CH8EeHtMvNNiFxN4SvX0u4sLg73WCFjb27xSnJjZ4HhuCpJjJb5fLBJrz74e/FrVfFvjmJdA0+20iHUppPskAZjFDLIqr5ssXKs2xTkRiMsWbLc5rncOd+6Xe259wS3GmeH7G2tEXyo0VYbeCMbnbYMKkajk4A/ADJwATWXolndXenwLqgCRW4MSWwOR+6JQNKRwxO3O0fKM/xYDVHpNlNpEjXWsK13fSjEl594Fc52qvHlIP7o4zySzEk8t4c+L/w98TazrXhHwbrNvrmu6JcNHc2Vu+ZYndjkyZGFRH3Kz8gMNv3yFOCi7Noq56Pc3cNhIWlyTPgIijLPIOMKO5Ix7AAk4AJrNjtporqF7vGyRy6xDlYcdwe5LEc9ug4Jq1bafJDINQvpBPeHgsBhEQ9UjHZe5PViASeABbLo13IH+YKoQDvluWGPpt9v1qQLGMz5/uL/AOhH/wCtU1ea/DTw9458O6ffQ+OtaXWriacvE67jtT33Bduf7gyq9ic16VRJWYBRRRUgFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAHkHx0+DWgfHv4c3vw18TXtzp9hfSwSvNZlBMDbyCRQDIrrgkYPHSuL/AGev2VvhZ+zXZ36eBY7q71HVQq3V/fyLLcvGhysa7EjREBOcKoJONxOBj6TorqjjaqpOipe69bCsr3CiiiuUYUUUUAFFFFABRRRQAUUUUAf/0/38ooooAKKKKACiiigApCcUE4plA0goo608DFBTYAYpaKKCDz34k/D2z+JOiW+i3t7NYrbXKXSvDg7mRWXayngjDEj0IB9j1VrBbwQx6XdoJCqCNWcBvNUDByT1Yj7wP6itioZ4I7mIxSjIP5g9iD6iq5nawGY2keR82lXD2RH8A+eE+gMbfdHqIyhPrXyJ+1l+1bY/sxaFoUvinRY9YuNauWe3EV39lRo7Bo5ZWbfHIUYlkCoNwOTlxjn2jxp8U18Lyf2FZyRPePJ5Jv5kkks7Q4yfOEXzSSKvzeUhBxjzHiDI7b+m/C/wrHHPca1ZR+JNSvmjkutQ1WKO4mmeEkxbVK7Y0jJJjjjVEQkso3MzHWk1FqU1ddhNXWgmgWek/E3wjpvizXrV5IvEOnw3MNtOpQ2cV3EsgQKeVlUMA7/e3A42jCj5/wDDfxP8ZaV4vh0uztodTtrySLT0Fw7xOwSR1ikLqJNhO/5gEKj+ELX1RdeFdPuGaaOSW0nY5327eWu71aLBikPoZEcivILnwlrumaxq3iKx0yz8QzWN2rqATZ3hjEEbSBAN0Mkz72wf3AD4OccAg42aYO56BbXOs6/cNp95q50W6UFns4YES5C9CRJMZVkXtvjXGeM5rlfGnwmsdesfsmmXlwdZJ3i7u7iWfanIIIYlV3fw7VGCM4IBB5zxB4y8Ma/pK6VPqs3hi6vUItJNcj8uGGeRcRva3u4JLON2VENzIR0OOleW/Bv4iW/gldf8F3Otw+K/EFhdOkmn6NMuqXCNF8rOYTJFMm9sB3ZfLQ4DupqqcZK8o9BPsdDZfAzXtKH9r6he2GnQaOPtMZlZniYwHf8AvW+XbHx87E5xk4r5P/aNv/H37WfheTRvgR4WEepacYbm/nub9LFNfii3LHDYK+1L2GMt5yXEzRxgDELPvJr7mtdCuvihdre/ECew1u0tGWSPw9bXDLaQuhyr3kUkYa6lB5Cy7YUO0rHvUSnsfHfh2w8V2kUl5YX2kalZfNZ38EYlkhccgYtndyueowPUEGtYYqcaiqJ+8hOCtynyF+wr8HP2ivgR8KNWtviDY2ZutY1N72LQpL0eZYxeUiErcQieAySspJiXCdGMoJYD6j8RfHrwt4YsLiLxdDdeDtVZSltHrcX2e1luH+WJFvkaSycsxHyrcFgOqiuc8J/Ha10TVh4J+LFxHpOprhYbycG2iuV6KzLKEKk/3sAdiFPWXU/2g/gV4h8UL4Mu/EdpcRWjy/aPMRntJZEXy/KMhUxOo3Mx5IygrGo5Sk5SV29SkklY4X9qHxt8OfAX7P8AN4A1XxFZQnxLBZaUkUt1FHNd2N7cRQXsy5blTbtKzP8Adz1OTXo3we8EXd3cyfFLxaqyapqo8y1jx8sEDjCso7ZTAUfwpx3OPwE/as+HereIvj94vT4FeF49X8Hrc28dqmjwxQ2VvcyQJ5kbBNkUfz5lJ4Xa6sxBYiv2Y/Zj+IFj8GPhD4F+D/xp1+xi8QWdikMV7Fex3dnK7MzrZechISe3VhCqN8sioGhZ/mVOivShGEfZyu3uTFtt3R9114N+0H46tvBXw08U67dYNl4e0m51S+DdJUhRjBa/W6lUIR3QMDgspqHxl+0V4I8MXFlZaYJNbubssSsHyLHGuMszOACSTwBnvkjjPlvx4srb4n+G/h18KLY/aIfijr1nfasCMbtI0tRqV2D3CnyYLYe0gBzznlhTekmtCr9D5fj/AGQvEei/sa+AvFPgq38r40+B3HjW3uNn+kXWo3TC7u7KbGC/mR7YdvRmjQE7S2fpTXfHGjfHP4S+Bfjd4X/5BurW582Mnc1vNJgSQvj+KKWN427bh719u9K/ISxsJdL/AGmNW+C/gq8+y+APHmpXOt6Tk4t7XWFiDalDGB/DKqNPAgwOJAoAya3o1bu76aiktLHVeJPh94F8XxFfFXh7T9YyMZu7WKcj6F1JH4V4TP8AsyfDi1v1j8Ci/wDCN1dyKm7StRntYiznA3RO7QYyecpj1r9Rbz9n7SJAi2OrXEICgN5iJJkgckY2Yz+NeX+L/gLonifSr3TNG1N7W10rzHvtRuXCQzvGPntlxgJGuD50gztPyAk79nXXxdOatEyhCS3Pxx/bMj8SfCbx7pmjW/iO/wBe8Kajp4ktb+7gtrL7bNbOYJthsooY5ljCp85QFi275twds/8AYzfwf+0J4y1T4OfGT4mavpHgmyQXdn4ft9SezsdSuJXLTpKem0Ab2A2nJJDA5J+vPg7oPhz9rf4m2XiD9oSBr74deHLSbSfBOm3IaK2uy7bJb+QgqSH2BLfsQi5wUBb7vuf2OvgB45+EWh+A7nwpa6BLoan7Jf6NGthf2F/E2yW4gniAYOZU3Nu3BiAWBIFFTHNUlQey1KVNc3MereAf2fPhV8L9EGh/C3T5PC2nSYcpp1zKglOOHdizGRsfxOSfeuvk8B3Df6nxTrUH+7cRN/6MiaviLR7/AONH7LtwmhfE3VhqPg9WCWfi6OAvp6qThY9dskO6ybt9ttz5JyGmXcWNfX+nfF3SLZra08cwjw5NdqrW9zJKsumXSsNytb3q4jII5AfY2D0NedOMt73NThfip8LGfwzceIL7xvrSXGjoZ7WbbZNLHMMBArC2RsM2BjPv1wR8HfF3xN8c9V8Eam+oePbm6tIo0aS2aC1t45UjdWKloo0JJxwDncfl7196/EX4teB/EsM/w28PXcer6rqIQARzRxxJtcOGMkjAEZX+HIPTOa+Qb7w/faxqkU+v2slvp1mweztpFI+0yD7tww/iT/nkOh+/3XHXhaPOnzMznKx8m/ACx8a+O/ipfeBrG9TQbm/urS/eaaIoFYweXu2AqSW+yH5Qy7jxkV+rvhrwL8WvhhbsPDej+H9dkYYecPPb3cv1MpZFHsrAe3evz58WfEfwL8HPilNJ40vBpOq3+lW7W0xDM1le2VyLiyM6qD5ayrNKDvKkRtu6Mu79fPAHjfRPiN4P0vxl4euEuLPU4UlGxg2xyPnjb/aRsqR6iljKlS0eZaBBLofMfjj4ifEPyEuvFfwsvrW/0wO9rqenXfmS2jkcskkcMi7GwN6OTG4G11ZeK/LXxd+0hJYePRrHj26utZ1mxjkaWe2YL5XnmKWPy0dlEZUIPlU7QNpB7D+hG5uILO3lu7qQRQwIzu7HCqqjJJPoBX4pftO/sceEdc8D6l+1FZW1/aSm+h1G80K0kWOG40ITKCoBQyR3DwcqUbaAwGwbaMBWpxnecboKkW1ZH054F8RfH79pfwZHo1t4g8PeFNDeBVlkctq+tXERAZJHhRoYYgVI2SJMx3Dd14rsNF+BHw6+GV/NffGTW9U8T3TN5tpqV5PIqzAABo2jtAjs691laUMpz2YC3c/sbfBvV9P07xj8DNUvfh7dz28VzZXmiTs9lMjxgxSPaTFoyGUgl4vKkbOTJmvKPiLF+054XvbHRfG2kQ/E2x0uGWUX2gqwvlt3ZVDz2L5fcSuFSJp2bBJfg4m6nL3XZMrVI+9PCcHw11bwpPb+EbLTz4fuxJHPbw26RQPuXEiSwlVHKn5g68g88GvnDwJqXww/Zx8d+PPA2mtpuheE9WgXxXpdrZCGGKKVI0tNTtooo8AbWjt5lUDk3DAcLisj4F3fwW17w/q2v65qVjc3No5e4sbtik1gsQ+YTW74O/P3htbGAM54ql8R/F3wv8bP4Zu/BlvFBb+FNRXVL79x9kWfSocLeQqoCmQGNvtHl4+YwAEZxWKp6uI7nufwYR7LQ7rxLqNldz+IPFdw2oXmLaRAgk/1MIklCIVjQ4+9wSa8i8Y+OfF3iXxbHp1jbQWEyahElg5VvPt7mNzGjuwYghtxWVcEFCV64avtnd3rhZvDnhrWvEeovfaXbXJjgijd3iUkyS7mbJIzuChMHqAaiM1q2inFnnniDxOvjz4P6l4gt7ZoNZ8MyRX9xY9ZYtQ0WdLxrfjnEjQ7Ae6P7kV7lcalY2umS6xLMv2OKFp2lByvlKu4tkdtvNfL/jjTdW+CXidPinoJm1Twxf8Al2mvWLtvmSL7sNzG7ffMedpEhyQQN2Dxt6PqNj4o+FWgeA9IuROt7MNEdgcSGwsWZZJXXqvnWsORnjMq4yCMpx002Cx3Xwc0q5g8KyeJtTjMepeK7mXVpweqLcHMMfrhIggx2Oa7S91SwQz6pqVxHa6XpZO+WVgsbSrwSSeMRnger54yori/GvxDt9HvIvA/hGBtX8UXa/JZWpUfZYBgNNO5ykKAEBS3JJGFYZFXvD3gS4Elrq3jO4TUb60wba2jBFjZYHHko2S8g7zSZc/w7QSKl92I5mCLU/EfijV7C0E2jaF4mtBc+Y8e26uJbcLbTSIrcwK0bW6guN5CkqqHD1S+D3gvwwra34sj0iCG8u9QubdTt3eWluFt5UXdnkzRyFj1Yk5JrkP2n/2mfAP7NqeF9X8YW91eXN/PcPFDaCPebaGMJcFmkdAADKjKv8bKOmCw9Y+DN1DeeANIv7dt0Wr20Orx8Y+XVB9qbOecmR3JrWUJKCk1o9hJpux6Sts8H/HrIQv9x/mX8D1H6geleE+Dfhd8Ifg/4r8eeO9M0iDQNQ8Qyx3+pXpllZWjfccLvdliDTCVikaoGLDgnGPoKuE8YaTpmrQX+l6rALm11TT5UljORn7MwaPaRgggyE5zwQDkYrGMugzSTxBBqWjtq2gt/aNo0TSLKgyHAB+VOm5sjGOMHIJBGKzPh5r8nifRJdYuLGWxneeRHEp3F9mMMrYXK4wOAACDXR6FoWneHdLttH0qEW9paKVijBLBQSSeWySSSSSTk1s05Na2EFFFFQMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//1P38ooooAKKKKACkJxQTimUFJBSgZoAzT6Bth0ooooICiiigAr4k0r9r7w141/aavP2XrXS72yuLZ7yF76OTDyS2URllVlADQRMqsFlDFmJXbsLA19t1zMvgzwnNrM/iM6PaprN1GsUl/HCsd40afdU3CAS4HYbuK1pzik7q/wCgmmN1Pwt4evrGx0a50+FrKCXMcWwbUIViCo7c8n175rWF4LQmHUXWPAJWViFRwOT7BgOo/EcZA526v9Z8Pzo+pRSatpyBj58Ee66i6DMkEY/eADPzRDdyB5eAXrP8Z+H9D+KfgabT7e9M9ld7ZoZ7ORWDvC25cH5lYblwR/IjIntcZ6A0qrjHzE8gDkn/AD61haRbNPDczXJ4muZyUHQ7JDGNx/i+VRxwPUGpdC0yDQ9FsdM05muLW1gjjjZyDIyIoAJPAJIHt/Sqja3p2iaC2qXrMFH7wxqpaV5J3ykaJ1Z3dwiAfeYgClbsBwPifxIngzz/AAdDpy6xe66XGiae3Edy0mfPikYhgkEBJklcqQsTYVWYKjfnn8Bf2NNa/Zc+O9t8UvFHi5fEGh2f/EsVbe3a0NudUjEUVzc7pJd8IlHklR0ZlmYhUYD9D5vB+tXEcvj6/QSeL4sTWkQbdHaW6ZP2CMjjEqkiaQcySEN9yOJU6u2/sPxlb3ElxCl7pXiHTUjaKUZWSHMiyxuv0lCsPqK3jWlGLino9xOKbubmr+G9B14L/a9jFctH9x2XEie6OMMp9wRXNP4V8SaX8/hbxBKEHIttRX7ZCfQCQlZ1H/A2+lHga8v7EXPgjXZ3udR0IIIriU7nvLF8i3uGbvJhTHMeCZEZ8BXTPoFYNtaDPl34yzeIdR8JnT/FfhqESpMnlX9vKJoVyfmwGCyJvHGGBB+uK/OEeDdN8K32v6xpMTXN1HfC002zY4SS6uII5MEgbtitIxYjOyNWbB21+iHx4+JeuX/gXxdZfDHTF1t9B0+6vLu5cbrcNaRtMsMZH33YoB8vP93nkfkF+x58Qvir8ffjZqHhK1lttbgWyutRluZ0+zw2DFoog+6CJsmQARqrAkjO1lG/PrYOEfZSnJ2t+pjUbukfpp+zLqXiD4beDtQ8K6Zol14njiuftdxcwlVka7ustPI4wf8AWMMhRwg+UYAAr17xb8T7TXdEvfDfjf4c6hdaVqEZiuLe6h3RSIexDJjryD2OCDkCua+EWl/EPTp9Z+HV5rmn6BqVlMZ5Dbaa0lxPE+Askc09w8ZAGBzB0IOMlq9bufg/catlfE3j3xRqsR/gjv49KAHoH0mGyk/Hfn3rzpWT1Nkfmj8RPjSvwzn0qw+IOmXvi74d2moW4s9QupC+uaNE7jzbO4kU7ry2dF2pK375MASGRgr1Bo37XXgb4vfGJ3+FK3fhPUNO0L+z9KjuYolOyaYy6i0UamSMeYsNpyCsm2Nj7r7h+2P+zp8GbT4SXL2ukzHxHcuU027lnuNT1KbUHRorK2jlvZZZD593JDGw3jKk5IGTX55/CH9kf4j/AAY/afhg+LF5YS3+g6D/AGxZjSHkmt5EvpJrAmV5YoSGj+cMoUjLId3r6FCNKcLO/N+HmZzbWvQ+yb3xT4/0t5bnVr2/nWUMHurWeaXcrDDeZFuMgB7hfMGOpr3fwRofhz41/A6+0DwncW2meLPDd/BqWm6kp3+Rq9uxksp5P4tpIaGWPvGXXA3YrgdVms7SzkubuRIYYlLO7kKqgdyTwBXH+HfhxrPj2w1T4g+FbKI2WlbxP5xEM90saeYHSPbuYAZCl9u7PyZGSYr4ZQklcUJ3R+g/gnxzP8VvCGn3+nQyaRPOjRatGT++0+7gYxXVkGH/AC3jlV0LD7oG8feTPjnxmsZ/i5rlv+y94PkbTfDUMEN14zvLZjH9n0luYdLidfuz3+07+cpbhmP+sTP4+fF79q74pfCj4h+JtF8E+JJtCttNvlaW2TAjvJ4oY43uJNwDETpGpG0rlcN98lz+0H7NngfwfrfwS8I+Nta0OO71rxjp9rr2pzaigubia/1CFJpZGMoYgAkLGONsaogwFAqcVhHQ5ZNp3V1b9Rwqc1yt8dtT+C3hT4VXSTS2EMnhqyWLSrOzmhjnjMYEcMESKciPO0EbSAozjIFfE3gf49fFDxBbf2ffazc2626NNF9iMg4Z8sH2AuxJbO5ic81+l3xO8EWGrfD3VNF0jToVDIrmCOJVWVEYMyFQMHK547nivzu8PeGtG8M+JdQsdJtltra5s7eRUBJAdJJVkwTk4wycVWDoxnGVxVJ2PY/DX7SvjfTrKfQdU0ObxTLcDy7Z5FSFizcbJFfa0in027j0yc8fh/8AtIfFfx5pPj/xR4GuNUl8KaJpF6/2fw9YXkq6bZuQC6xWyv5Mfz7i6DhH3KQpBFfp/wCKPEN7a+LtD8JeF9QOma1qM0cr6gqeb/ZVkjgS3pTkM6/dhQj55OoKK+PYv2nPhz8O9J/Z607Vvh/o1rc6f8IL7Stah1EqJp2SzvoprxY7n/WO8kbSy3Em75n65csUKFT2M9Fe+g2uZHxD8EPA3x68SeBvDniZDp9npfiSG2e2uLHTnuI2e5KxpHLctceTHMHIjdGUbHBTAxX6h+EJfE2nNaaF8Y/HXiTSdSwsQS4j0y2024YDH7i8trMSZP8Ade4D89zWn8QPgXqmkrrHiv4DvBpt3rKmTU9BZvK0vVJQAUuYsAraX6lVZJ0XZIQBOrcOnrHw2+Ifhj4weE3mEAS9t8WusaTeRhbixvAP3tvcwPnGDnaeUdcMjMpBPPUruUEuiKUUnc/D/wDbQ/Y++Ptp8WNQ1/wfbw674R8c6vZW1tqV3fLus7nVZo7aKG789jMV85wiyIsg2lckN8tfXfgT4KfH39kJNJ0DwVqDePNFXT4ppo7eMRXkc0Col2kdsSI7qBWIdFBS4CMQqzOCa+xvjT8Jbi8+EnijSfh9cy2VxHaNe2Wntma0N9YMLu08tGO6EieJMeWwUHkoxrn/AIjfH2z0zR/CN/p2lfaNS1iKDVrR/OBgS2kQfOGA3MJY5GTBVepPZc6TxVSooxk720FGEY3aI9A+OvhX42WFh4JSUafdanMYtRRyUAgt8GeD59rxyyMVhaGQLIoZuMrX034h0Cx8R+HdQ8NXiAWuoW0lswA4VZFK5A9s5FfJ66B8KvjTZXnjrX7lPCXi2WRbdruGeKKVY4UAjjcSDy7qHksBNGxVmbYUYKwz7v4xeJfgppj2vi3VdN1zTP8AVWuoxXG+3V2+55o3vNbgckpKzxhQMXW4hBhUpNPlSs+xSd1cufs6eNT8PfhZqXw+8U7mvvAU5s7OEf62eznkkW0jjX0jljntEGPu2+48HNfT3g/SLzS9Pl1PXmVtY1RvtF44+6hx8sSn+5Evyjn1Pc1+Nem/tG65F8WdP+LF9YpqmlW97KXtzsiLRXYRfMUKFG5JUWRC5YJvkP8AEa/WZ/B+q/EGCK98dah/xKJ1WRNJsHdLd0YZH2if5ZJ/90BE/wBk9adak42cla44tPY+ff2gLPwh8breXwt4A8Pf8JJ4otXiB1izVYRZpG4dojf5QkOMjYH2nvkjFfNPhTw58TNCj1vUILSO5/4QeFr7UF1NRE8SwI0xRxGu2beqEKgRdw+8+Oa/WXTNL03RbKLTdItYrK0hGEihQRoo9lUAV4f4FhtLP4l/FmTUQgtTLpzy+YAU8s2hdtwPGME59qqhiXC/KEqae58N/s0/tpePfiTqyfCtW8MaTd6VYo1pLqdzcIbuGJlhVN4b5pwGUlQDu+Zh0Ir7c8FXvxwvrO81o2nh2VNSvJ5Mi5vEyISLdSP3DfKViBHfB55rxz9nH4YfDn4b/s2S+P7bwtYWWpeMdPm1i9LW6EzR3kkl1Z27KwIEcSSoiRgBVx0zk19EeE/hH4X8NeGdNtdHW48PXFtawiQ6fcy2sQlVBvka2VvszsTnJeJs96MRODk3GNl95UU0tRfEd58RV8LaufEOg6Hd2Ys5zNGNRuArxiMlgQ1pjkf7Q+o61+a/w41zXLS7aCw1+6015kUJcJJlrWK4Cxy+WGDBQBCrEj0HoK+w9Qh8a/G/VLnwroGsvdeAtMmAvb64RIZtSmQgm3ilt0VPLB53CI46nd8oPyr45+MPiz4EfE6wb4e/Du01GTxHe3djYOsE08csdvIlo0FrJEEKuhgaSRmB3K+5h1NbYWNm1Zbdf63JqI+qfgx4Wf4TR6z4oa4gOgyIFu7iW+jZrmfcrLcGZztckMQCzrneMele82vjHU/EeDDbXPhfTmAP2rULcx3Emf8AnmjhoogezTHdkEeTghq818HfCBLPV73xha6zDqOupd/aY/3CDSAZreLLWtmrMLct8wE6O0xBIkkkHy17pp3iEyTpp2t2x0vUG4VHbfDMf+mM2AH9dpCuByUArkqyTdxqOh5N8a/hh8O/G/w4ksde0Gw8Q7bi2ezkvoUvWF1NMkKSB5Q5LHdtznlfl6cV6j/YCaJdW03hvbZx7TC1tjFuwxuXgf6s/KRuUdWJZWNUPGelWNzBp0KwCOS61OxLSR/u3/czLPyy4JyYwOazPifaeK/+EbRfC19JHMbmFWwUWQh22IqOQMfvCucnPv1zEdbIT0O6i1ZZZvsJjMV8BkxP2H94MOGX6c+oByBX1i32W63Dnc43h36cPGygew3FePXBPPNN0DTr5PD1ha+Itk2oLEhuHXvPj5nBGPmz3GPbAxXm3x1+Kug/A74Yar8QfFyT3mmae0KbYFUyl5ZVSMEsVQLuIyxIwOzHGSEXKSjHcTdtT2uiuP8Ah9420n4k+BtA+IGgpNFpviKxgv7dbhPLlWK4QSKHXJAOD2JB6gkYNdhWbQwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1f38ooooAKQnFBOBTKCkgpwHrSgUtANhRRRQSFFFFABRRRQAUUUUAcLeeKNVtvHFn4Zj0aWayuYS7XoJ2oQGbpt24yApywOSOPWtrXg+b7bNr/g+5fQdZlO6V1RZbS7IGP8AS7beokOAB5iMkwACiTblT6Cy7hjoex9KRH3Ag8MvBFVzdgPmzxB+0b4W+Evhx5/jPaT+F7myXy43WKa7sr9o/l/0S4jj5JxzHKscigFthQbz0Hwp8b+HPjJoth47tiPsUJ8vToi4I+aNT9pVhjLyI+FPBRSy8FnFTfGz4B/D79oTwj/whHxDhuGs7W8F3bzWkxt7iGXaQSrgEEMsjKVZSCDnGQCLnwv+GPg3wr8OdG8GaFZPpunaNAbAQW1zPEm61YwuW2ON7FlJLtlmPJJJrVuHLpe/4C1uerEXlvzH/pKf3ThXH0PQ/Q49zXzpY/E7w14O+ND/AAwnE4XWAbi1/d4jt7q7ZWkgbJBw5AkXaCo3nnHI9Mn8Ezyvs8PeIdT0yFenlSQvEp9hLC7SH3ZiPfjFfNfx1+Gni63gsPET6np+rXSXG0XlxprR3i4RtqtPDcKmDk9IeOwA4JRinLl7hJ2R9YeLrN4YoPFVjtW/0MSSDcwQS2zgfaIGZiAA6qGXJAEiRsx2qQeMa61T4tW8Z0eaXTPB9woY3QBjudQRucRBgDHCR1ZgGYcAYzXxB8PJvGWmeJlstX8MQa3ooVpp7azvp3bKD5JfLNuigBiM7n25IJPAI81/aD/bsPwa8WHwn4W0G/sI50jurkXOoJPeKbp2En2JIZ7q2JJBZfN3HzSwdABg7U8JNycVuiXNJXPvbxB4Wsfiben4P6DALL4eaI6r4heHKjUZRhhpKMOWjOQ18+eVIgyS83l+v+A/DWg+HNMuhoemW2nC8vbyaT7NCkPmbriQozbAMkKQBnoOK858U+DfFWhfDefw78LtXvEvhAPs1vItuspVnDTMZhHG6yuC5MjuWaQ5LbiTVb4E2HxFi8FltavBEjyn7Ol6rXMyqOHyRKpUbgcKSSCD0zzha8W7lXOu+JfhfUJms/HXhZP+J/oOXVR/y82/PmQNjrkE7fqQOTx3vhvxBp/inQ7TXtMbdb3aBgD1VujK3upyD7iqMtv43XmC/wBOk9mtJk/UXDfyr5q8aan8VvhJqBh8NRaRLH45vFs7BHMyw2mrXAP71l5/c7FaWQAniMheSoMpXVhnSNbR/Fb4/wBnqVxF53hn4YpdJaseUufEMyxJNJjoy2UEnlof+e0ko4aEV5r+0Zr8HgP41eEvGmnxC8vdW8Oa/wCG5ogRgSXDWl7ZmQnhQvkTtzkld20HBqn+z9pnxJ8Pa+fCmrTXv9l2yXizy8Ok3lzHzpoJCP3jyTvuldMsxZmPznI3v2hrPR9f8R/DPwjpcYMGmeIbPUb5FBEix3jNpe58/Pl/tb7i3JOCc1vy2kvQV7nYfCH4I6NN4d0vxR8RLdNZ1e4AuYoZwWtbZW5j2xNw7hcHfICQT8oXpXiXxy8W6p+zN4rhX4fWkOr33j1J7bTtJlYiJZQPnmuAuWW1ti4dnAztPlA7mBP2/wCNvGGn+BNBOpzW8l7cSuttY2FsAbi9u5AfKt4VJA3NgkkkKiBpHKojMPMvCPwYjuYNb8UfFMxav4y8XQrFfTxktDYWqHfBYWBYApBbsd27AaaXMrgEhVzVRt3kFj44sP8Agnd8Fvib8C7uz8WhtZ+I2pR3iyeK5Zpmm/tGKQwpIqK4jNtGYlSOIqQIhgcndX03+yH8Vtd+Inwxbwz8QIvsfxB+H1w3h/xFbHG77XaALHcDpmO5i2yKwG0ksFyBWv8ABa8v/BfiDXvg94jfM9lObzTJTwLizmRWO33DhzjnHzD+GuP+Lujf8KY+Lul/tOaKvlaJqUcGheN4l4U2DPtstUYD+KxlYLK2Cfs7seBHTbveL+Qz6j8VeIbXwp4dv/EN5zHZRFwucbn6Iv1ZiB+NfE2leG7W30+3+JXjm2uNUutfN1b6dYW7eXNd3Vw8bwRp0A80pJy2EjjBkYhAxHr/AMa9f0nV9d0zwTqeox6do1pjUNWuJHCKkS/cTP8AeYZwBkkspA4r57+JHi34kXvjbSPF9jp1/wCH/DtnZzroERtwkiQohW4uniIZ4neIjAkVGjiwNqkyZqgnsna5Mj1Tw58EPD13puoeDPJhn13UZ1uvEeuW+c2s2393Y2Uj5bEKHYitkImZJAZpCW5TxR4T8Q/DHwdr/wALtciOpeAvE1hd6ZvRciFLyJoiQDnY+GyVJw3JBzk19c+GrLUND8P2WmaFpFvFBHGrfvbsgu7/ADO5dI5S7MxLFiSWJyTU+ow+LtVtZbC50zS/s86lXWW4luFZT2KeRH/Oo9o76jOP/Z48W/8ACcfAvwH4mlkEl1d6NYi7wclLuOFY7hD7rKrKfpVLxL4A0m78Vvqmiamnhvxeg87Tr+PaWlilJMtpcQFl+1WxlDSPGSCrSFomjkw4+M/AWoeIfhB4s8S+BvAPjLQZ7mz1nUDL4eOZ7kxXL/bg1tEblGfyVnMZABdfLIYMFON3XvCXjHxZ4t/4WDa6jFq2napcWcP9oAi3NjNIyQpHLBvd4tjkYKllOQ27mtVR9/V2TE5aaH2LpfxNuvtf/CIeIdJa08apGXXT4n3wXUQODdW1wwUG3B++WCyRkhWTc0e/w3w5+z9ZeMvCFrpfiXVZ7TWfCNxcaRbi32mC1sbWVhaQKjAFlNsYpN7Hcdw6L8o+oL/wToGqacLHUImlmEizi7DFLpLlQVWdJlwySAEgFSAFJTGw7a/P5f2+fhH8Mfid4l8EeLZL/VIXvhbrqtnaLJ9r1CCMWzL5EbB9z+VHEDGuxpAXCxxuAqo0ZzUnTW2rCUktz7O+DWg6b4W8Fz6Qw23Vld3MWoPIfvTRNt3nPARogjqOykZ5ya5LxLoXhf4yefoOi6HYTaPDIDc6vcWqOheM52WwIHmHszk7QM9civn21vfj18ffE0t7pGix/DXwLr4WVG1o/aby9ktQF3tZ2kqj95FtwGuVwI87WKmvqbR/gf4citIIPGl9d+MfIUKkGosi6cgHQJptukVnhT91pInkHeQnJMSbT5m9RpdD8pvE/wCzdb3z+OPD/wAEtVfVdT0m3llh06ziF3YzSFSxiScFYojjja0gbJxtc11P/BPy9+I3xE8TeO/B/wAVZ9W0G88Pw2NzbwzSSafqKPcPMku2F1V2hGxfmK4ViACc4H6VRWkWhfHOMW8axW2r6LsVVAVQ9u4AAA4wEUAVhfG74S6t4iutN+KnwyZLD4j+EwzWMrHZHqFq3M2nXR6GKcD5WP8Aq5ArjgHPRLFuUeR/8N/wAjTSdzuovAvinTz/AMSjxtqAT+7eRwXf6sin9a+bfHy/EDQtJ+MwtdQs7271O2sdPSQ28kEjXF/arZ25QLI6gh5V4xya+lfhR8UNF+K/hSHxDpiPaXcZMN9YzDbcWd0hKyQyqcEFWBHI7EcEEDxj4hNdah8Rl8E6PIq6hruuaRdtuG5YoNKtmvRM47hZoItoONx49a56babTNTkPiXoupq9n4XvHW10zQ7S3tba2t52kgQRRrjJ2R5fbjgrkDGOME7PhHXfE/wAU9Dsfh3e6hJZaZbtJFqepSMVnvlVjttLd24dthHmuMkDrzkN6R4wsBrNvZ+DPDjyJYafqNt/amohv3vmzyiN443x81w/mFpG6Rg/3iAParHQNF03R4fD9lZRR6dAgjSDaDHtHPIOc5PJJySeTzVTqRstNRJFTydH8E+FpF062S003RrV3SKMYVY4lLH8Tgkk8k8nmvI/DPh2TTPEHw30u8BEun6Jq17Ln/n8keySQ/ncS1nfE7xxYeHbqTwJpouLk3UKG7iZt0UdvI2GRGbLhnQEAZ2KCOOaktPHGseIPHkmpaDoMm230uGGO51BzaWii6mkZ3DFWkdW8lAuIxuweRwaiMJcvN0Hc9ZXSZbPxDf3miMtu80UEssLf6mZ2aUEnAJRzgfOo56srcYnu/EPh6ZW0nWdq3MgG6xkXzZmGeCsSBi655DKCPcEHHMwaLqOqa21t4l8R+dctAHlsdNb7GiKh+XcVZrgg7zz5ig/3ew7a08OaHp1v9n02yjswDu3QqEfd03FhyWPcknPfOTWbsB8k+JrH4w3nxktbbRGvBpEclpPYpNN/o8UAGXNwu8nLMkn38uV4HTA+k9YuPF8osLOfTrFhNdxHKXkgJ8jM/wB1rfA/1f8Aerx7xv8AHr4d/CXxtp1l8QL+SK88UXyafpzxQtIHjtgIcyBfu4ubhkyM5OTgAHHt89rqOtalYLqamztY/NnFujZkbaojHmyKcD/WfcQ445ZgcDapzWjdaGel2WV8Q6lO729ro88ksZ2u6yQNChHBG4yKWI7qBnscZBrmfHnjHw14R8LXOpeMLOe5hnK27QNAsvmtLwEAJ8rHcgt0HOT19KHk2saQxIFVQFREAHA4AA6AD8hWZrGgaV4k06XSvENpHfWk2N0Mg3JlTkH6g8g9R2rBNXAh8LeINM8U+H7LXtHVks7tCUV1Csu0lCpAyAVII4JHHBxXQVT0/TrHSbKHTdMgS2tbdQkccY2qqjsBVylK19AQUUUUgCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9b9/KKKKAEIzQBilooHcKKKKBBRRRQAUUUUAFFFFABRRRQAVDKrAiWMZZeo/vD0/wAP/wBdTUUAcmvjPwx/wk//AAia36Nq8kQlFsA27bgnk42htoztJzgZxipdHgKXWo2U/EZmNwkY+6FmJyD7l1diOnzZ5zxXl8I+GYfFA8ZPp0R1J08k3GDuUcgHGccg7ScZH0zWm9t5WqRzxu0fnbom2nOTtDqTuyMLtbHpu9zVu3QDcqre2NnqVrLY38Kz28w2ujjKkfQ0hF8n3THL7HKH8xuz+QrKutWuBIbOC3kSUYDybfNSPPtGSxOOQCB6nHGZS7Aedar4I0+FbY+BY00rxNaZaOeMYiC52v8AagPvROV+VfvE/dwAxHi3xT8F+AfGfhe68Q+MfC9lceOvA8ttrM9zdQRyXiQWE6XE5tLjAfypoY3RBGRtLDOGAJ+j/Bfijwp4njvD4RvxfRpJ/pEuGDtLjaWJdVzkAYYfLgYXgYGt4k8Jab4js1ilHkXMAfyLhQC8e8YYEHh0ccOjZDDrzg1q5NPUEcqvgDW9JUy+D/FN5bbsExX22/ibHQZkxIo+j8DoMcVyWheIfif4UTUdO1bw3DrlvZ3s5afTJir/AOkEXXEEuWOPOxgHjFdN8I9cum8K6f4V18GPWNDSTT5HJJW8/s6Q2rXETHkhzHuKn5l3DPBVm9AgTyNfux91bqCKQD+88ZZJD9QpjB/Cpb6MD5G+Mv7cvws+C2nWZ8QadqUms37OItOaFYJQseN7u7tsVRuAHJJJ6YyRR8I/G34Y/tJ6InjHSbi4k0u+tXshaxQSXV/Yxbx9qBhtFmdbiaWNVUgHZFEJUYGQA4/x+/Z38JftozWcniK7vNK0fQ/tFtod3pzRJcXjytH9ru3aaKVTZoY1SEBQZG3OG2PEx7nw1+yn8H/gl4EsdC8F6reeF7bSUI+2yXQaSaVyWeWZjt3SO2ThCg7KoAAHQ5U+RJL3upKTuYeoftH+HvAF7oulXfhzX9Uv9Jjn04R2+mGxM1s6JJFKq6i1mqkiFQQSBndjjGfk39pb45fEr/hWfiH4tad4Nk0HTNT1Sw06LVbi8tZr3TIYD5sZWG3aYQvJMifvTL8rFduSwYexeMdHuo5/t+oz3F8zzxPFe3EUkTXEYcRmQCX5sFCR3wO9emfDJvDmg/D/AOJHiPxpb2+o+FrKwaa+srhEnjlitoZZZQ8ThlIZOACCG6c4reMfZONWyZLfNeJ8BfsB/tKeMPG3xh8Q6V8QfF6appWiaNJcWeoeIbozfZLiW4iRreKaWRWDXCFiSSxAiwBgkV+r9x+0p8J9Jfy/EGv2NuB/y2tLlb2E+wMQ80e5aIKPWoP2Xfg9pPwV+DGgeGLbRrPRtWvIRf6ulnBHAp1G8JnnXCAZWJnMUefuxoqjAAA9butbvL+V7DwvGk8iErJdy5NrCRwRwQZXB/gQgAghnQ4zz4msqlRytb0KhGysfHPxG/aT/Zv1jWUvNK8eWsWvadCktpdRw3EkccsDMyxO6RMu2UOwYZ4wM+h4XxZ/wUV+AGp6K3h+XzbuHUbZodQM9hcT222VNssSwhQ0ykEqdxRSDnLcivZfGvwRsLjxB4l8S22oXd1d29nDeThtgE125k3Y2Ku0LHGrbR6jn18ObTIfJ4HOK3pYeM43j0JlO25+Xngn9tzVvh3qUXiEw23ibQ7K6jikg1MNLqEmm2pKQQG4ZgUdYlXJVQsjKPMVxuB/or0mO38WeNNW1uePzLHTLRNLgWReC9yq3F1kH1UwofQqwNfjD4K/ZC+HPxK+LnxS8aQWg0ufwha215Yz/NLYxa7CEvzLcWpJjmjkV41khI2su/A3ncP2E+AnilfFfw9hur22bT/EFrdXMGvWUn+ss9X8wyXcR9U3Puhbo8LRuvysKWNqxnZxjaytp+YU4tbu51fw9aWy0ibwrdsXn8OTGyDMcs9uoD2z575hZAx/vBvSuzvoZ7iyuLe2mNvNLG6pKBkozAgNjvg81zF/F/ZXiyy1lOIdVj+wXHp5ibpbZz6AZkT3LqO1dgzKilmIAAySegFcD7mh/KzY/BT9oGT43aL4GvLG50G4svFlvpEvikORYW+oRus2+O9IKNOy4eKMne7lU27ztr9vPil+zloPhjw5f+KIfGPia5vrlkjuFl1a4gjvGkbAMiWDWi7lPzg4xkcg5r0z4NeBfD/xA/Z9Nv4ysVvrH4kS6hr91G+VYprd3JfW5DDDI8MUkQjZSGQopBDAGvKpvGvinWb24+AGu31vqV94XD3T6/dSrFHqGn2+FjkdjhBdRM6x3QHHmbZBtSTavo4jF1K9TmnLVafIzhTUFaJ8/abaalqFrb6vqVxPe3qZEgvZ5b0LNGSrgfaWkyAwIBOcivPPB37BPhX4n+M/EHxd0fXJ7fxJod7Dq2naNMkJ0d9SWX7TGs8Yj3LayvGUeJCNoJKnaoQ9V4b8e3ms+Lb3w/ZaNJJHd3Ei26RZeZ2jXaWCjClX2Z4PGc5NfX3gX4b/AB08NWU2veGJ9P0ebUAplsb5TNK8aZ2btmFjf5iQN5Az83cCsTT9nZxe4oSvuenah8ZvDDfCnTPiXNaTWc0NzHAdOYL9ptdRhdobmyk/hV4yssTnpgFlyCuez+H/AMVNA8faTNqEYOmzWzBJYZ3XK7hlWVs4IPPocg8dM/FPxLsbDw3Nqms/EWw1W2fxEuy6+0TBbKPWQiw2V9E1sI7f59qW026Njt8o7gqyFvp7RPhbpnw+0+117wgG8QRCMC/gmKTm7iHPmW5wFWWPJKqOHXKn5trDjcYKLvv0NNbml488ReGrDxn4K8QPq1mgt7ue0kJnjGFu4WALfN0BX8672X4k/DuD/X+KdKj/AN6+gH83rjvHtn4RvfA8Xiuwt7Nraxns9QSby0VPLhmQvuyBgbNwIOMdDXPeJvjJ8APD1lcXEN/pet3UGV+yaVGmo3Bk7IUtVkKE/wC0BjrUKN0tDQ8Q+LXxG8A/CvxVJ8WPh3rlje32qjyr/T7adXW4mVflmcKcbGACSt1QiOUdJRJynw98beItR8Zt4h1rM2oahbSi4nsYTLdBrp41QW6MxG5UgaOPoEDk4PQ91Laazr2marI/gaW88VeKbSdLaG6t4La2sbALhwIpWEyMQwUF4RukIHOHz8b/ALJ/jj4jXfxC1Cfw/oP9rWnh2zlmuor0yWot1hcQ+TG4ikdpUEjMFKs+FOTkgHupQjyyb6LuJ3urH6jrc+JpfDyWGgeF10TTrQxyxtqE4EgEMgkyYYvMbcSMsWcEnJJJOa9BTR9ZuRnVtYkOesdoi26fTcd8v4hxXFajq/jD/hHJtY1fVNF06yuYSY/LjnuhIJUyoWUywZLDphDnriuhtb+51ONWsta/tCVwCPsEUaQqD0LtJ5236bt3oprz2UcD4q+GXhvX/HGlxRefDKtvLNfSrMzO8KkLCrNJvO5nJweu1WHphPCfirR7TxBrVjpGo22rWGmLbWJnilSRrKGBWZBOkfJQNI6iQAD5SHIwzV03h3w9HqyX3ifxFfT3S3zkRjzTDELW3JWMkReWHB+aQFhjDZABzXjnwc+Amk/BrxRe/ES31W8v4Nfja1EV0QPsNrNKJIA20Au2QqyMw+UkEYUOx0TXK02I9Ni+GEMPjh/GOjagsN1Gvnxhog8bNOrowbay5TAOAMY45OOfRR4hFijDxFD/AGc6AnzM77d8f3JMDn/ZcKx7A9arDTptD1DzNFj32syEyWmQAuxusJPC538ocKeo2nOXatrehXNlJYSXkOZ0Jlhdgsn2cH98Wjb5lAQNnI46dazlJvcLHIw+BPC/ijVtH1LxZodlql74WH2i2lu7aOd7XUrxluJpITIpMUibUKsmCN3Xjj0VpWl1QpAAzwRYJ/hXzWyc+42Dj35x1rndBsL1bFZLMm1iuSZpEf8AiaQ52IfvIqDEYPTavyqOGrnPhqnxGTUdWXxqqi1GwW/yxptYFiyps6pg5y2T7nmhrdktnrEUQjySSzt1Y9T/APW9qloorMQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooARlV1KOAysMEHkEGvLJvHdtYeI9T8Oapbva2mkwi8OoTOFiEcYRjvJ+6uDjeW55zXqlcL8TPh5oHxX8Cax8PPFDTppmtwiKV7aTypk2sHV43wwDKygjIIOMEEZFXTav72wn5G9a61YazZw3miXkU9ncoHS7jZXiZGGQY25VyR0IyB1OehvQy6fbRiKKVFUergkk9SSTkk9yeTXk3w1+Guk/AvwPpXw/8NyXl54b0hHSGWaUy3cLSO0rvLtCrIrO7MSqDZnG0pynqqRTTRLcWt+0iuAyErG8bA8g/KFJBHTDClJK+gzmdF8PeFvCEWo/2Xa2+mWxl+1SOmI12OOWLZ4AO/AGAB0Hr1NvKl3bx3enXSzwSgMjgiWNlPQqykZ+uTXKa/wCG5NVga1vY7W5hu1MMiqjW7c/MreYDJypXgbe9N8OafP4b0WDR7fR1ktrQuirBOskmd5Ys3nLEBuJ3cMevAxTeq3AoiwhTXNcsNRhKpcSW+pwzwuA0Ejx/Z22ZwcjyNxwDneQQQSD81fHL9ofRfCeu6b8Pb5Jb6a4jf+1JrNjCwsJCp8tTgtFLNtAcdVjJZGVnR1wf2qf2wbP9mnxN4VhuPBlze3esw3KqXeNNyPJEpWAReb50wYKfL3JwQM/OGHvnjj4A+CfiNaw3+sWbNqdjHL9kuHYpJJJId5a5243K78lMDaOAF6L0RpqPLKps+xLe9jufDV1fa5olpqPhqCHTLO8gjMcsihikIHyRwwRkKqoDgFmGDk7Dmt2y8G6Pb3i6pfh9V1FPu3N4RK6f9c1wEj/7ZqtO0Cw0a40DT30uB7K0MEYjhjlePygFA2EIw+Zeh75BzV2TQLRuUuLuNvUXcx/RnI/SuZsosa1plvq+mXNjPCk3mxuqiRQwDMpAPOa+V/j7pNlbX3hvU9OVxY+Iry0Gu2kKbmm0rTnW8klMY6gGJIJMDlJcccmus/aK8TH4T/BnxR45u/EWpwxWVsIo0iFuWae6dYIV3mIOoMkigsHBUZIOQK+Yf2JPjn4f+Juk61rOrQX73uhN/ZiQrbXOorCtwBNMqSwxOCsoijO1gpBRvlx8zdNOhL2bq9L2J5lex+hSQTeIYY7i6k8vTplDpDE+TMjDIMkinlSP4EOCOrMDiughiit4kggRY44wFVVACqo4AAHAArwHSPiRoHgi5l8Ny2Wsvpbkyacf7G1FdgOWe23SW6j5OWTn7hx/BzU8X/HbVbGyuLTwl4F8QajqpgaaPdaRQxRxj/lrJ508Z2/3RxvIwO5HPyMo6C98R6nPc6h4f8Hqsuva1dTSSSMN0VjbRYtlmkPqyxBkXuTnGODVPwB8Mm2t4f7QvBJGgWRwyfvGHVsFTtJ+prjPCXi/xp4M0SLStD+C/izULkqpuLy4u/D0LXEoXBdy2rF/oNuFHAr4d/bC/bm+PHwg8QaX4ftfDh+HDS2f21f7QNnqUl6PMZNqvC80Cqu35lVvM5BJAK57MLSnOfLCSXqzOo0ldo+pvCPwm1PRdGtvEXw8uX+3+JdVvtSubW4fMF/psN0z2jOeMFrdLaM9jv42jOe5uvFNjoXiyX4vaXBJpxEcVl400qUbZYraLiDUwv8AEbPJEjgfPasxOWhiSur/AGaPEV/47+DvgvxzqumHSJ7zQtPjS2O7EYEKs7Ju+YLISuAeQFGTmuv8e2/hK+uI1klkXxFbr/o5sIzPeqG7PGoIMTdGEuIyCckda53O71NDu9btoNR0W4jadYVKCVJyRtjeMiSOXPTCMA3pxXlPxN8aWd98E9e1bQL+FbzVrF9PsnilWQJqN+Ps0CAqTuZZpFyBzXzVr2r+NvDHgy++EXj4L4Z0iaEnRHjiN7cXdsrriyUxyiKH7OSq7Xdj5DKoZyjucr4URprlhpvg7w9N/wATu+1hJr3zYMCxtNKDzRzg5O8tcLAygcE7Q2ByXGmrXbFc+jdV1rxHqsdv8JvhHZ/2TBY28VvcandKwWwtUUIixwAq5lZRhVcxsOuMfMKus/Anwdo3hCJTJPqGt6ZMlxplzcEP5eokhYmWAbYcSMdkmVy0ZKs+3ke8+HvD2m+GdNXTdMQhcl5JHO6SaVuWkkY8s7HqfwHGBVWJP7Y1w3jc2mklo4vR7lhtkcf9c1JjH+00gI4FZ8/YZ+fQ+P3wY8LftBeBdCvr6K08Zvd3ug+IJEiJtn1C8JC7bnAU4uYwiZxtjcI21kKL+ldfgbD+ynonxZ/apHja41m6sPh34i1vVNZ0e3RQ01//AGZqdna3LLPlfLhlurt5IQEZmgUENzuH7neE9Su9S0SL+0yP7RtC1td4GB58J2OwHZXxvX/ZYGujGRp3Xs77a379SYX6nzf+2fd3f/Cj/EWnWN3FZSJpt/qMjzDKtFYwkrGAAx3yTyQomATuIwM4r4X/AGQP2fvjvYX3iDwt8ZPGHiX4ZS6lFDfaNoljqMWLtAXW7mkkQS4KExAxQzxyJu3uAHQn7d+IYs/iN8c7PwbqUyReGfBMVlrWuvKwWIvDI02nWzE/KVmudtwwP/Pmqnh69U8XafqnxVsYdP0K3bR7e1mS5tdbnQpc29xHkJNZQnDbsEgmXEbozIyvGzKSNaUafs+j1DlV7nxb8VPg74b8EaommnQ7bWfPhM93d6lJca1csZWYG4hbVGuZInJBMgR2J4KMDuVvTfhv4g/tbVE1nxnFda1F4YihTTLWwtFMO+ZmCNiMJEHJACZxuJHPy11Wp2Wh2VnP4V8UQXep/ESAxyyG3kZ3v7cuE+1xtJmOGAjIZXx5L/JlwUeXnPhV8DfG/gf4qNqN55ENo8z3rTJP5uY5QwFuMqhJQEr9xRgFhWnuOKu9Rq9z1rX9b8caL4dvb2z0b7J4p8VSxWFtPdXEQ8m4ucxwCOOLzi0VqrNKwOCyrI5ALEV3On+Ddb0LwxpWi6NLbWqeH4o0s4oo2kkKwx+XsM0jhS0iZVmaPqd2MirDxN4j+JEczc2PhSJgo6g392g3Eg9DHbsAjDr5si9jXpVckpGp4PqHhe2lt7bSVvpZNMv3+06W7ouyOeQEvbsqqmA24vHx8o3rgBQD1iaW/gvwmvh2zlJmu5DDFcL8u2S4Yl5NvO3y03P1IwhJINauq2duskmj3bmKzuna8R1OGheLMjspOcFZdsq9cktxtGK8m8F/G7SvHerWpj066kmt45PsscKq32mVsK0gDMoi2oGxvbAVmBYHra5pLTpqLQ9uv7W3FpZ+HLNAkE4EZVei2sQG8fRhiPrkb89q2rsWrWsy32z7MyMJPMxs2EYbdnjGOua8/wBPtvFmq3U+pxeRotu/7lI/+PiYIjHcQceXE5bOcCVSADjIyems9C0zzVnvBJfXcZ3b7tvMZWz95E/1afWNVHFZNDMvS9Y3XS6dbiTUXt43Ec4+5LCSu1zI2FYqflcqWORuxzivK9S+EMOr/Fv/AITi6viPOa3ee0CeYgMEe3aJCV+Qqqbl2dZOvPPu9/F+8ivFbbJbhyD0yDgspPoQv4HB7V5F8GfjR8OPjSNa1HwDqZ1BtInWC5DRvGUMwLow3AbkdV2qR1CdB0rSHMk5x/q5Ltsz3Cnimin1gEgooooJCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArDewn06V7vSBlHJaW1Jwjk8s0ZPCOepH3WPXBJetyigDPjuYdRtWe2JLIcFWG1kkXDBWB5B6cHtz0NTREec5X7syq49zjB/TbUNzYiWUXds/kXSjbvAyGUchXXjcvPHIIycEZNeY+HviTD4g8c6v4Em0ueyn0MZklb5klUlR8vA+QlwVP8SjJC9KuMb7Bc6zxXptjqthHqV7bxzpo00V9CXQMwa3cSMyE/dJQMoI659K7KoGNtco8DFZUdSGXggqeCCPQ1U0dpG0y3SZi8sS+VIxOSZIjsc575YHnvUgUdKT7BqF9pnSJ3N1F7CckuM/9dNzfjXQdOTXB+PPFWl+C7O217UVklKuYljhCtI24bjgMVHG3BJOACe+KbZa0vjjS7XUtIiZ9IvUV4zJ+7E+Rk7wcsI17jaQ54J2fefK9wKXiTwxofxa0268P+JrOPUPCNwpilt5Rlb8+vqIVP3WBDO2SCEAMnH/AAf+HPwu+CngyXwV4N0u18PacbqSVo4ifMnuFbyWlZ3LSySkw8EliAFA4AA9lGn3UiCO4umSMDGyAbMj0LnL591K1ieHdNstOPn20Ko89xexu/WRz58jqXc/M2Ap6knmnfSwHz/8cE1fxAdNWS3uf7MhDhS8ZjEs3J3eWcPkKP4lGOccGrfwgafwzoaaD4lhl09NWv4pLOa4jKRukYDeXvPQkx4VGwSGyuRmvoXWIvP1TRo84Mc8soI7FYXTP/j9cpf+OfA934sfwHqVzHcamsJSSzMTSKxlCuEJ2lMlBnBOcGtee8VFIm2tz0yviD9pPwQfjpqF74W0jRovEUfhnTzE5aOGVI7jUZVM4jkm4juoYbZdvl5cLOfu5Gfpf/hHtesxi0lebSB/zDGl/ehfRbgnOP8ApkW29vM2cU74aPptzo11qlkohk1W5e8eHb5TRxMBHahouNhFrHEMDgkEgnOazi7alHmH7Oln4x1j4WWY8eX919qgnuLaWES7JfMtpDDN5ki/veZ0kKgOPlIzkHA+h9P0zTtKg+y6ZbR2sWSxWJQgLHqTjqT3J5NcN4eg/sHx34g0fG231oJq0GeSZQqW91jHAUYhIHUszHnmuhvZrzWZX0zS5Wt7ZCVubpOGBHBihP8Af7M/8HQfPna6kuaTYkrHy5+1TBPr3hPVfEXh2D7XP8PNPv8AVZJCwSNbiGLekSsSNzYRvMUfw/KTlsV+Yf7A/wAbvi78Sv2lr3TNPure/jl0i8nnlltV8m0XdAPnMGwhXaJEAYk55H8Wf2Y0jRbTx3eQSxwrF4K0edZLSAD5NSuoGzHMwPW2hYb48/62bMv3UjaTiT4Z0z4a/tO2XiLR7KGx034n6VNY3nlIsaHV9JZrqFyFAzLcW0k249SLcZ5rqhibUnSsvXqS4e9zHqt94k8faVbiC/8AD8d1cTny4pdPuFkG4gncYpxEcKAWIDHOMDk15l8XvHsGneBbb4feFrq40LxF4wnTRLKa7ie3e1FwGa7vfMkARmt7dZZgwYhpQik5cV9D2qfart9Rb7qgxQ/7mcs3/AyBj2UEdTXjWgX2k+JvifrfjzU7qIWmgJL4f0eNmBZmEitqdwi/eJeeNLYDGQbZiOJK5IlnB/GDSPCfw00D4V63oaR2OieDdSh0yBIvmAsrmzltoIUxnP8ApK2p/wCA5PrXoI+J3hyBNR8Y6HKJNInt5Jb2edXhhtZ7GIyO0mVLFmt1JIUHiJem4GuI+P8AoGk+L/BGoaX4a0O4fVdPUawskVqLfZJYHz4S4m8oyb5Y1UAZP3iM7SD4p8UfAvxLtPDll4O8FxfbLK9ubfVtXFuwmmMEb4tECIgKCWZQfkkk3rG4ICkg7RimldiufRnwX+H0eleHJviN8QUDeJ/Fdw+vagLg4isXuFHkwIjEqn2W3EcJYkncrMGwxr1ea81zxH+50Mtpent96+kQedIP+neJxgD/AKaSDH91GBDDifAE3iP/AIRjTJ/ihaXJ1CJdwLqJokwxMbOsY3eaFxlpE+U9CDnPsNreWl9EJ7OZJ4zxujYMM/UVlU0kxo868QeANCi8MXq6XGbTUIEluYr7JkuftAjI3ySOS0m4fK4Y4K/Lxxia88TWtgpOuvHY6rHHsEBdQZp1P7oW+4gyCYkhAOTyhwwYDvL+A3VjcWw6yxun/fQIr4W/an/ZXuf2rNa8NX+n+Mbjwra+HopY52jtxc/aBK8butvmSPypl27TL84yQNuYyKqjyt2m7ITbS0PsjwlpradpmJyGupXd52HRp2YvMR7eaz7f9nA6AV07MqKXchVUZJPAAFc7o1y0VmEvPluLci3uRyf3ygYYZySJAQRnJIK55yK1TA12Q12MRg5WL1PYv6+w6DrycYye5omYF9bTeIJ8wEww2ybo3OVaR3JyMjlUIXBIwxBOMDBPIeFfhz4I8ONqeo+GtJS1kv5PKjDlpFjBC71VHLKoWQMWUDjbjoBXqcO1RLMx2hnJOe20bf8A2XNfLnhf4U/ES8+Pr/G2TxtcJ4NurNkt/DxV9heSMKXOX8tYzJvmTCbyWGSMsK0hs9bAz6Zh0xbOJItPleBIwFVCTImBwBhskADspFTHz+BcRB8dHjPI9Tg8j6AmrDzKjbBlnPO0dcevt+NIEd+ZiP8AdHT8fX+XtWVxnkHiD4nwWPxH0T4cW9uLuTUkWWV8uGjRi45G3YOEJIZgSDwPXtfB/wAPfAvw/ivoPAvh+w8Px6ncNd3S2NvHbiad+DI4jA3NjjJ6DgcVfm8JeHLnxDB4sn0+J9Xt4/KjuSPnCc8ehxuOCRkZOK6QCqk1ZWJAClooqCQooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArB8TRanLod3/AGLEkuooha3DnAEnYg5HOM45Geh4Jreoppgcb4Yl8Rz6DZL42hii1FgRIY1BUncQuRllViuMgZGTxjoNK30yCKW6iMssYD+YgWQqqq4yflHycuGOCK32UMCrDIPBB718uWlt+0xb/tF6xdagljd/CAWCC0gjeEXjXG1MABgsm9ZDIW8yTyzHjb82ANIq99bCue26n4WtPElqbLUI4p9OLBvLmhBMjL0b92YyFGeO578cHzzwZp3xE8CazrDeKJorzwvNcP8AYYrcbjZRM5KBV2hvL2kAoSxBHynGAfarLVLG/Zo4JCJkGWidTHKo9SjAMAexxg9qvMqupRwGVhgg8gg1PO9gsNhliuIkngdZI5AGVlIKsDyCCOCDWLAvlw30K9LW5aRfU7ts5H4liKpm0uPD0zT6eplsJCWkhzyhJyWTPTPcdD14OSdXS5obl7y4gbekkwIPTpEgIIPIIIwQeQeDUjGXA3a7Y56LBcN+O6IfyJriV+Gnha58bXXxAjgMesCRQsoYmJmjiVNzR5wSOVJGOnYjNdrGuNRtB/zygnT8niH64zVaK8uJ4ha6SFaViWllYZihLksRxje4z90EY6sRkA0m1sB8i/toftC/EL4EeCdMl8E+GxrN9rU8ltNKIp7lIYyoVMR27JIryuwVGY7Qwx8xIr6l8KvP4m8G+HvEOt6U/h3VbrT7W4ltM7ZrCWaJXktycDPlMdrKRtJXlaZrken6TpzxRq95ePLbXEvR5pVimViznhVXCkDO1B91QOBV/wDsK6vfm1Z1kg6ixUn7OPTcxwX+hGzp8mRuq5TTila1uvcSWtz5k8S+O/GSfEWwu2lEmh2Ny0cz20XXT+UmnMqBm2KhMrFTtyowAQCPoC5uLDxlYxaJ4auY20KRVS5ubVwVkjIz9nhdDgbl5kYHKr8q/MwZOG/aN+Hk3xi+FOrfC7S9Sk0TUdYWMxXCR+Z5KW0qSuXjBXfGwXYVDDcWC5AyRyv7MXwKi+Cnwj07wbca/NqupWVxePNqESeQrTSTvuSKEtIDEuMIH3ZyWwpYgaS5HBSWj7frcSvc+pIIIbWGO2to1ihiUIiIAqqqjAAA4AA4AFfN37T3gW++JHw1YaE5F54WvItbiIUsJjZJIJbdMZLNLE7xjHGTgntXuXmavH8uqxefbD+K3BDkf9NI8k49kLZ7gDirWoa3YaZoV7rihri206CWZ0gG5yIULFFX+9gYC8HPFYRbTTRTPJVNx4d+Gml6VZzDUNW1CCCz0uaQme3knuR+7kMZJBSBSZWXqYo2Kk4OPS9E0XRfAHhWy0LR4SljpcMcESDBkkIAUbjxukkbqx5ZjknnNfnN+xp+1pZfH/4jP8LrzQUtLfwtok13pTQymeKO2WaG22XG5QPOSKREjcAZXzcj5q/SKKOSW8Fy+6WztSwhzy2/7rOe7ADKr3+8fmBBG2JpShNwnuTCSaujjfH9r45sPhj4ru/ASxz+NLiwuZbPeV2G78o+UimT5MLwqb/lJ5fq1fB/7BM37TkX/CWH406DrEOgq9kumrqyiO/EkCyK6os7JJ9mUeWUz8u4fugcyEfpndyCXyrWM7vtB5xz+7Xlj9Dwv/AqsQjLPMernA/3V4H9T+NKNdqm4WWv3/eHLrcqWur6fdyCCOXZMckRSq0UpA7+XIFbHvjFJcaNp1zKbgxeXOf+WsRMcn/fSEE/Q8Vent4LmMw3MayxnqrgMDj2Nef+L7vWItA1jTfh5KD4i+yzJaGU77S3u2jIgM5YMFVXKkxplyvRCORilqUVPH13420jQJoPBtwL3VJhiISxB5Y0z88gKgKxUfdDIcnGc81wnhX4pQ6FceG/AHjWxn0/XLq3LcoqReWZGWFmLPnc/l/NwcHlsZ4h+ANj+0Fofw/E3x8k07VPFck8zNLBPtZLXP7mJvJtxGzjk5QDO4A5YEn2m3Baf+0NT0iQXOCPNIil8tDxsTazPtx1wOSScc4Grsrx38xeZYu7dEnTXFIkGzZMF5Uw8kMuOpQkkHupYAZIxsq2EJY5KjqO47H8ayFi0neZId1kzHJO14Ax/wCBBQfWvCvGnxPt7TxNF8JfAvijTv8AhMtouBZzlfMFrsMjDLDy/lX5tmd/l8gYyamFNy0Q+ax7XqyJfQvpkrbbVQq3B7Oz4Ai9wcgv6jC4O442x58/3cwx+pHzn6Dt+PPsK8oTxncWPj3SfBA0W4vI7uAzvqQLGBXO8t5Y2YK5ALNuB5Gc9/ZKmSasNSIY4UiXagwOp9SfUk9TUmKdRUBzBRRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigCpd2FpfKouog5Q5RujIfVWGCp9wQarLDqFn/qZPtcQ/gl4kA9nHDYHADDJPJetSincCrFdwzN5TAxyd43GG98diPcEj3rG+ytpt/c3NlhYXVJJEJwpOCufbCqAD2HB+XG3oJI45V2SqHX0IzXzFb/AAo+NcP7RWqfEg/EBX8BXFgkNroEsc0yxzhI1y0ZkWPCuryLIp3kttI2jJuCTvd2Ez2C513Sr3WpNKOoxWcssAKxNIqXMm8kNtXO5VG0ZYckcrgYaurjimeJbeyX7DbIMAhQHx/sqeFHuRnrwOtfO3iz4U+PLz4s6D480m5tm0+0kSS9iRvLeRo9q5RHVsDyxtC+cPm5zg4H0GLxzxcrPbt/daPcuPUtFuA/77HvTlFWVmCG6laWlloeoJEojV4ZSzMclmKEZZjyT7k5q3c6pBbwtMqPMFxgRrncScAKThSSeAM8nisXXdW0TSNB1DWdUvbO2srWF2mu55ljjiUjGXkckKOcZLCrOmavp3iC3ttd0+VbzTZkElpPAyzxTBxxKrxlgykfdI4IJOTkYnldrjKsmlavf2N6GkXT73UI2Xz1JkkgypCKgG0Ax7iQdxBbJx81cZ8MfC+sfD2xufDmtag+uMXF0tyQ29RIPLKKjM5Kr5eSQc5bpjBr1hbu2ZgglUOeNpOG/I81n6pNbae8Gr3cqQQ2+9JZJGCokcmCSSeB8yrzQpPYDVSRJUEkbB1boQcg1zmo2/8Aat01nYM1u6YW4uojtdR1EasOrHrzkKOcZIqV7iO/VX0CdW+0KHM8RDxbGHDAjKsxHQjoOTkYVrttawxxLbSrsVc4jzlD3JJPLknkluSeSM0gPle48M2fwc120uPg34K0zT4PEoij1SfT9PS3e6lDHy98sIUb/mbMhzlnBwNpz9YR3NtEixlTbqgAAZdqjHQA/d/I1CVgudPW2/1gkjA+Q8jjgg9BjqD+VY+o3Nymks1y6/a3It0Qf6vzmO0Mw6sgHzsOmwE7eKqTv0A4fxnq3jZ9Om1L4ZWceoXv2pLc79vlrboWErpvZFLmUbTg42jJ5Ar0GLWvsVlbDWoGtrt41zHGpkBcAbwmzdlQfXGBycDmpLayjitYbLTI/IhhRYxKchiqjA2gYJ6dW46HDVetrBLVmkjcvK/3nk+Zjj34OPQdB2FK6tYDPVbnWFLzz/ZrX/nlDJ+8bv8APKh+X/dQ9vvkHFaVraQQIiW8SwwxDEcaKFVQe+BwM/56muNlh8ay+OkLxW7eGhDy2F80OFyMHO/dv/4Dt96i+I2h+NtZ0GKz8A6qmlXy3MbyPKzAPCA25A4V2U5Kngc4x3NFtUriud3t8+UMf9XEeB6t6/h/P6CntPGpKjLsP4V5P4+n44qC0tp0tIIb2XzpURVdlG1WYDBO0die1XFVUAVQAB2FSxlY/a5emIF/76f/AAB/76rzNPgh8LV+KA+NMmgRS+Nhb/Zf7Td5DJ5e3ZkR7vKD7Bs8wIH2fLu28V6tRQpPoAUUUUgCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDgPif8NPC3xe8Dap8PvGUUkmlauiJKYJDFMhjkWVHjkHKsrorDqDjBBGRVv4deAPDXws8EaP8PvCELwaRokAgt1lkaWQjJZmd2yWZmJZj6ngAcV2lFVzu3LfQLDWVXUo4DKeoPINeD/tE/Djxz8RfhPq3hL4Varb+HvEF20DRTzl44GWOVXZHeFXZMgcMEYgjGMEmveqKdOo4yUl0E1fQ4D4V+E9U8DfDjw34S128TUtV0uxghvbqNSiXF0FHnSgHkB5Nzc+vQdK6XxHoVr4n0HUPD19JJFb6jC8DvC22RVcYJUkEZ+oI9RW1RUt63Gcv4N8KWHgnw9a+G9Nmlnt7XdteYgud7Fj90KAMngACvEviB+z1eeOvjv4J+M8fjK+0q28Ix7X0iBAYbtwZCG8zePL3iTbKNjeYiqoK4zX0rRVxqyTbT1f6isgooorMYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//ZCmVuZHN0cmVhbQplbmRvYmoKOSAwIG9iagoxMDY3NzgKZW5kb2JqCjExIDAgb2JqCjw8IC9MZW5ndGggMTIgMCBSIC9OIDMgL0FsdGVybmF0ZSAvRGV2aWNlUkdCIC9GaWx0ZXIgL0ZsYXRlRGVjb2RlID4+CnN0cmVhbQp4AYVVW4gbVRj+kznJCrvO09rVLaRDvXQpu0u2Fd2ltJpbk7RrGrLZ1RZBs5OTZMzsJM5M0gt9KoLii6u+SUG8vS0IgtJ6wdYH+1KpUFZ36yIoPrR4QSj0RbfxO5NkJllqm2XPfPP93/lv558ZooG1Qr2u+xWiJcM2c8mo8tzRY8rAOvnpIRqkURosqFY9ks3OEn5CK679v1s/kE8wVyfubO9Xb7kbLHJLJfLdB75WtNQl4BNEgbNq3bSJBobBTx+36wKLHIZNJAj8osDlNoaNhhfb+DVHk8/FoDkLLKuVQhF4BXh8sYcv9+B2DlDAT5Ib3NRURfQia9ZKms4dQ3u5h7lHeTe4pDdQs/PbgXXIqs4dxnUMtb9SLMQFngReUQuJOeBHgK81tYVMB9+u29Ec8GNE/p2N6nwEeDdwqmQenAeGH79ZaaS6+J1Tlfyz4LeB/8ZYzBzp7F1TrRh6STvB367wtOhviEhSNDudB4Yf6YBZywk9cpBKRR5PAI8D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PyG+JxSr1U+aWrliK3vC4SeVCD59XEkb6uS4UtB1xTFZisktbjZ5cZLEd1PsI7qZc76Hvm1XPM5+hmj/X3j3fe9xxxpEKxbRyOMeN4Z35QPvEp17Qm2YzbY/8vm+I7JKe/c4976hKN5fP7daN/EeG3iLaPPNVuuf91utzQ/gf4Pogv4foJ98VQplbmRzdHJlYW0KZW5kb2JqCjE0IDAgb2JqCjEwNzkKZW5kb2JqCjEwIDAgb2JqClsgL0lDQ0Jhc2VkIDEzIDAgUiBdCmVuZG9iagozIDAgb2JqCjw8IC9UeXBlIC9QYWdlcyAvTWVkaWFCb3ggWzAgMCA2ODAgMjYyXSAvQ291bnQgMSAvS2lkcyBbIDIgMCBSIF0gPj4KZW5kb2JqCjE1IDAgb2JqCjw8IC9UeXBlIC9DYXRhbG9nIC9QYWdlcyAzIDAgUiA+PgplbmRvYmoKMTYgMCBvYmoKKE1hYyBPUyBYIDEwLjExIFF1YXJ0eiBQREZDb250ZXh0KQplbmRvYmoKMTcgMCBvYmoKKFBvd2VyUG9pbnQpCmVuZG9iagoxOCAwIG9iagooRDoyMDE2MDYxMzE4MDMwNlowMCcwMCcpCmVuZG9iagoxOSAwIG9iagooKQplbmRvYmoKMjAgMCBvYmoKWyBdCmVuZG9iagoxIDAgb2JqCjw8IC9Qcm9kdWNlciAxNiAwIFIgL0NyZWF0b3IgMTcgMCBSIC9DcmVhdGlvbkRhdGUgMTggMCBSIC9Nb2REYXRlIDE4IDAgUiAvS2V5d29yZHMKMTkgMCBSIC9BQVBMOktleXdvcmRzIDIwIDAgUiA+PgplbmRvYmoKeHJlZgowIDIxCjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDExMDMwNiAwMDAwMCBuIAowMDAwMDAwMzA3IDAwMDAwIG4gCjAwMDAxMTAwMTIgMDAwMDAgbiAKMDAwMDAwMDAyMiAwMDAwMCBuIAowMDAwMDAwMjg4IDAwMDAwIG4gCjAwMDAwMDA0MTEgMDAwMDAgbiAKMDAwMDEwODczNiAwMDAwMCBuIAowMDAwMDAwNTI5IDAwMDAwIG4gCjAwMDAxMDc1MTEgMDAwMDAgbiAKMDAwMDEwOTk3NSAwMDAwMCBuIAowMDAwMTA3NTMzIDAwMDAwIG4gCjAwMDAxMDg3MTUgMDAwMDAgbiAKMDAwMDEwODc3MiAwMDAwMCBuIAowMDAwMTA5OTU0IDAwMDAwIG4gCjAwMDAxMTAwOTUgMDAwMDAgbiAKMDAwMDExMDE0NSAwMDAwMCBuIAowMDAwMTEwMTk2IDAwMDAwIG4gCjAwMDAxMTAyMjUgMDAwMDAgbiAKMDAwMDExMDI2NyAwMDAwMCBuIAowMDAwMTEwMjg2IDAwMDAwIG4gCnRyYWlsZXIKPDwgL1NpemUgMjEgL1Jvb3QgMTUgMCBSIC9JbmZvIDEgMCBSIC9JRCBbIDxhODFiMGQ5NTc0NDA3YzVkNGY0ODRiMzUyMGIzNzhhMT4KPGE4MWIwZDk1NzQ0MDdjNWQ0ZjQ4NGIzNTIwYjM3OGExPiBdID4+CnN0YXJ0eHJlZgoxMTA0MzYKJSVFT0YK";

// CITATION INFO
const std::string CHULL_AUTHORS = "C. Oses, E. Perim, E. Gossett, D. Hicks, F. Rose, C. Nyshadham, J. E. Hansen, G. L. W. Hart, I. Takeuchi, S. Sanvito, C. Toher, and S. Curtarolo";
const std::string CHULL_TITLE = "AFLOW-HULL: Platform for low-temperature thermodynamic phase stability analyses";
const std::string CHULL_JOURNAL = "submitted to Comput. Mater. Sci. (2018)";

namespace chull {
  CHullRuntimeError::CHullRuntimeError(const std::string& function,const std::string& message) : std::runtime_error(message),f_name(function) {}  // I/O or computer type errors (no entries loaded)
  string CHullRuntimeError::where(){return f_name;}
  CHullLogicError::CHullLogicError(const std::string& function,const std::string& message) : std::logic_error(message),f_name(function) {}    //errors in logic, unintended (and insurmountable) use of functionality
  string CHullLogicError::where(){return f_name;}
} // namespace chull

namespace chull {
  bool convexHull(aurostd::xoption& vpflow) {
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    ostream& oss = cout;
    ofstream FileMESSAGE;
    string soliloquy = "chull::convexHull():";
    stringstream message;

    //////////////////////////////////////////////////////////////////////////////
    // START Display usage, if requested
    //////////////////////////////////////////////////////////////////////////////

    string usage_usage="aflow --convex_hull=|--chull --alloy=MnPdPt[,AlCuZn,...] [chull_options] [--destination=[DIRECTORY]]";
    vector<string> usage_options;
    usage_options.push_back(usage_usage);
    usage_options.push_back(" ");
    usage_options.push_back("chull_options:");
    usage_options.push_back("--usage");
    usage_options.push_back("--output=|--o=|--print=|--p=latex|pdf|json|text");
    usage_options.push_back("--image_only|--imageonly|--image");
    usage_options.push_back("--no_document|--nodocument|--no_doc|--nodoc|--full_page_image|--fullpageimage");
    usage_options.push_back("--document_only|--documentonly|--doc_only|--doconly|--doc");
    usage_options.push_back("--keep=tex|--keep_tex|--keeptex|--tex");
    usage_options.push_back("--keep=log|--keep_log|--keeplog|--log");
    usage_options.push_back(" ");
    usage_options.push_back("LOADING OPTIONS:");
    usage_options.push_back("--load_library=|--loadlibrary=|--ll=icsd|lib1|lib2|lib3");
    usage_options.push_back("--load_API|--load_api|--loadapi|--lapi|--api");
    usage_options.push_back("--load_entries_entry_output|--loadentriesentryoutput|--leo");
    usage_options.push_back("--neglect=|--ban=aflow:bb0d45ab555bc208);aflow:fb9eaa58604ce774");
    usage_options.push_back("--see_neglect|--seeneglect|--sn");
    usage_options.push_back("--remove_extreme_points=|--removeextremepoints=|--remove_extrema=|--removeextrema=|--rep=-1000");
    usage_options.push_back("--entropic_temperature|--entropictemperature|--entroptemp");
    usage_options.push_back(" ");
    usage_options.push_back("ANALYSIS OPTIONS:");
    usage_options.push_back("--stability_criterion=|--stabilitycriterion=|--stable_criterion=|--scriterion=|--sc=aflow:bb0d45ab555bc208,aflow:fb9eaa58604ce774");
    usage_options.push_back("--distance_to_hull=|--dist2hull=0.25,0.25");
    usage_options.push_back("--skip_structure_comparison|--skipstructruecomparison|--skipstructcomp|--ssc");
    usage_options.push_back("--include_unreliable_hulls|--include_unreliable|--iuh");
    usage_options.push_back("--include_outliers|--io");
    usage_options.push_back("--force");
    usage_options.push_back(" ");
    usage_options.push_back("GENERAL LATEX OPTIONS:");
    usage_options.push_back("--latex_output|--latexoutput");
    usage_options.push_back("--latex_interactive|--latexinteractive");
    usage_options.push_back("--light_contrast|--lightcontrast|--lc");
    usage_options.push_back("--large_font|--largefont|--large|--lf");
    usage_options.push_back(" ");
    // output usage
    if(vpflow.flag("CHULL::USAGE")) {
      init::ErrorOption(cout, "--usage", "CHULL()", usage_options);
      return TRUE;
    }

    //////////////////////////////////////////////////////////////////////////////
    // END Display usage, if requested
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Flag manipulation
    //////////////////////////////////////////////////////////////////////////////

    // address possible flag issues
    // get libraries to load from flags
    vector<string> vlibraries;
    if(!vpflow.flag("PFLOW::LOAD_LIBRARY")) {vpflow.addattachedscheme("PFLOW::LOAD_LIBRARY", "all", true);}
    aurostd::string2tokens(vpflow.getattachedscheme("PFLOW::LOAD_LIBRARY"),vlibraries,",");
    // special case, all
    if((vlibraries.size() == 1) && (vlibraries[0] == "all")) {pflow::defaultLoadEntriesFlags(vpflow, FileMESSAGE, oss, std::string("A"), false, true);}
    else {
      bool found;
      for (uint i = 0; i < vlibraries.size(); i++) {
        found = false;
        for (uint j = 0; j <= _AFLOW_LIB_MAX_ && !found; j++) {
          string LIB = aurostd::utype2string(j + 1);
          if(vlibraries[i] == "lib" + LIB || vlibraries[i] == "LIB" + LIB) {
            pflow::defaultLoadEntriesFlags(vpflow, FileMESSAGE, oss, LIB, false, true);
            found = true;
          }
        }
        if(!found && (vlibraries[i] == "icsd" || vlibraries[i] == "ICSD")) {
          pflow::defaultLoadEntriesFlags(vpflow, FileMESSAGE, oss, "ICSD", false, true);
          found = true;
        }
        //} else {
        if(!found) {
          message << "Incorrect input for loadlibraries \"" << vlibraries[i] << "\"";
          pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          return FALSE;
        }
      }
    }
    // get desired output from flags
    // give an error if input is not as desired
    if(vpflow.flag("CHULL::OUTPUT")) {
      vector<string> out_forms;
      aurostd::string2tokens(vpflow.getattachedscheme("CHULL::OUTPUT"), out_forms, ",");
      for (uint i = 0; i < out_forms.size(); i++) {
        if(!((out_forms[i][0] == 'A' || out_forms[i][0] == 'a') ||
              (out_forms[i][0] == 'F' || out_forms[i][0] == 'f') ||
              (out_forms[i][0] == 'T' || out_forms[i][0] == 't') ||
              (out_forms[i][0] == 'J' || out_forms[i][0] == 'j') ||
              (out_forms[i][0] == 'W' || out_forms[i][0] == 'w') ||
              (out_forms[i][0] == 'L' || out_forms[i][0] == 'l' || out_forms[i][0] == 'P' || out_forms[i][0] == 'p'))) {
          message << "Incorrect input for output \"" << out_forms[i] << "\"";
          pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          return FALSE;
        }
      }
    }

    //////////////////////////////////////////////////////////////////////////////
    // END Flag manipulation
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Gathering hull inputs
    //////////////////////////////////////////////////////////////////////////////

    // get elements input
    vector<string> vinputs, velements;
    string inputs = vpflow.getattachedscheme("PFLOW::ALLOY");
    if(inputs.empty()) {
      pflow::logger(soliloquy, "No input given for elements", FileMESSAGE, oss, _LOGGER_ERROR_);
      if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
      //really drive the point home
      init::ErrorOption(cout, "--alloy=" + vpflow.getattachedscheme("PFLOW::ALLOY"), "PFLOW()", usage_options);
      return FALSE;
    }
    // if multiple requests separated by comma, get requests
    aurostd::string2tokens(inputs, vinputs, ",");

    //////////////////////////////////////////////////////////////////////////////
    // END Gathering hull inputs
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Looping over hull inputs and creating desired output
    //////////////////////////////////////////////////////////////////////////////
    string log_name;
    for (uint i = 0; i < vinputs.size(); i++) {
      // go through each request
      // create log specific to that request
      velements = pflow::makeAlphabeticVector(vinputs[i], FileMESSAGE,oss);
      if(!velements.size()){
        pflow::logger(soliloquy, "Invalid input (" + vinputs[i] + "), please capitalize element symbols", FileMESSAGE, oss, _LOGGER_ERROR_);
        return FALSE;
      }
      if(vpflow.flag("CHULL::LOG")) {
        log_name = "aflow_" + aurostd::joinWDelimiter(velements,"") + "_hull.log";
        string log_destination = getPath(vpflow, FileMESSAGE, oss) + log_name;  // no output before banner //CO 180220
        FileMESSAGE.open(log_destination.c_str());
      }
      // spit out banner for only the first request
      message << aflow::Banner("BANNER_NORMAL");
      pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_RAW_, i);
      message << "Starting " << aurostd::joinWDelimiter(velements,"") << " convex hull";
      pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_MESSAGE_);
      getPath(vpflow, FileMESSAGE, oss, false); //CO 180220 - directory stuff for logging
      chull::flagCheck(vpflow, FileMESSAGE, oss, i);  // spit out all flag options
      
      ////////////////////////////////////////////////////////////////////////////
      // START Stability criterion calculation
      ////////////////////////////////////////////////////////////////////////////
      if(vpflow.flag("CHULL::STABILITY_CRITERION")) {
        message << "Starting stable criterion calculation of " << vpflow.getattachedscheme("CHULL::STABILITY_CRITERION");
        message << " on " << vinputs[i] << " hull";
        pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_MESSAGE_);
        vector<string> vauid;
        vector<double> vscriterion;
        aurostd::string2tokens(vpflow.getattachedscheme("CHULL::STABILITY_CRITERION"), vauid, ",");
        if(!stabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss)) {return FALSE;} //HAS to be thermal hull by virtue of input
        if(vpflow.flag("CHULL::SCREEN_ONLY")){
          if(!(vpflow.flag("CHULL::TEXT_DOC")||vpflow.flag("CHULL::JSON_DOC"))){vpflow.flag("CHULL::JSON_DOC",true);}
          if(vpflow.flag("CHULL::TEXT_DOC")){
            for (uint ia = 0; ia < vauid.size(); ia++) {
              message << vauid[ia] << ": " << chull::convertUnits(vscriterion[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_)) << endl;
            }
            oss << message.str();
          }else if(vpflow.flag("CHULL::JSON_DOC")){
            vector<string> vmes;
            stringstream dummy;
            for (uint ia = 0; ia < vauid.size(); ia++) {
              dummy << "\"" <<vauid[ia] << "\":" << chull::convertUnits(vscriterion[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
              vmes.push_back(dummy.str()); dummy.str("");
            }
            oss << aurostd::wrapString(aurostd::joinWDelimiter(vmes,","),"{","}");
          }//else{ //WON'T PRINT ANYWAY
          //  pflow::logger(soliloquy, "Unknown print option, only --print=text or --print=json available", FileMESSAGE, oss, _LOGGER_ERROR_);
          //  if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          //  return FALSE;
          //}
        }else{
          for (uint ia = 0; ia < vauid.size(); ia++) {
            if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {
              message << vauid[ia] << " criterion = " << chull::convertUnits(vscriterion[ia], _m_) << " (meV/atom)";
              if(std::signbit(vscriterion[ia])) {  //-4e-13 is still negative!
                message << ", may NOT be on the hull (negative value)";
                pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_WARNING_);
              } else {pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
            } else {
              message << vauid[ia] << " criterion = " << vscriterion[ia] << " (K)";
              if(!std::signbit(vscriterion[ia])) {
                message << ", may NOT be on the hull (positive value)";
                pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_WARNING_);
              } else {pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
            }
          }
        }
        continue;
      }
      ////////////////////////////////////////////////////////////////////////////
      // END Stability criterion calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Hull initialization
      ////////////////////////////////////////////////////////////////////////////

      ConvexHull hull(vpflow,velements,FileMESSAGE,oss);
      if(!hull.m_initialized) {
        pflow::logger(soliloquy, "Hull was not created successfully", FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        return FALSE;
      }
      uint dimension = hull.getDim();
      if(!dimension) {
        pflow::logger(soliloquy, "Hull has no dimensions", FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        return FALSE;
      }
      if(dimension < 2) {
        pflow::logger(soliloquy, "Unable to calculate hulls with dimensions less than 2", FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        return FALSE;
      }
      if(dimension != velements.size()) {
        pflow::logger(soliloquy, "Dimension of hull does not reflect the number of elements", FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        return FALSE;
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Hull initialization
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Distance to hull calculation
      ////////////////////////////////////////////////////////////////////////////
      if(vpflow.flag("CHULL::DISTANCE_TO_HULL")) {
        message << "Starting distance to hull calculation of " << vpflow.getattachedscheme("CHULL::DISTANCE_TO_HULL");
        message << " on " << vinputs[i] << " hull";
        pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_MESSAGE_);
        vector<double> _coords;
        xvector<double> coords(dimension-1,0);
        aurostd::string2tokens<double>(vpflow.getattachedscheme("CHULL::DISTANCE_TO_HULL"), _coords, ",");
        for(uint j=0;j<_coords.size()&&j<dimension;j++){coords[j]=_coords[j];}
        if(LDEBUG){cerr << soliloquy << " coords=" << coords << endl;}
        double dist2hull;
        try{
          ChullPoint cp(coords,FileMESSAGE,hull.m_has_stoich_coords,true,oss);  //not a real point
          dist2hull=hull.getDistanceToHull(cp);
        }
        catch(CHullRuntimeError& re){pflow::logger(re.where(), re.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
        catch(CHullLogicError& le){pflow::logger(le.where(), le.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}

        if(vpflow.flag("CHULL::SCREEN_ONLY")){
          oss << chull::convertUnits(dist2hull, (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
        }else{
          message << "distance[coords=";
          for(int j=coords.lrows;j<=coords.urows;j++){
            message << coords[j];
            if(j!=(int)dimension-1){message << ",";}
          }
          message << "] = ";
          if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {message << chull::convertUnits(dist2hull, _m_) << " (meV/atom)";}
          else{message << dist2hull << " (K)";}
          pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_COMPLETE_);
        }
        continue;
      }
      ////////////////////////////////////////////////////////////////////////////
      // END Distance to hull calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START outputs
      ////////////////////////////////////////////////////////////////////////////

      if(vpflow.flag("CHULL::TEXT_DOC")) {if(!hull.write(_txt_)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} return FALSE;}} // text doc
      if(vpflow.flag("CHULL::JSON_DOC")) {if(!hull.write(_json_)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} return FALSE;}} // json doc
      if(vpflow.flag("CHULL::WEB_DOC")) {if(!hull.write(_web_)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} return FALSE;}} // web-specific json doc
      if(vpflow.flag("CHULL::LATEX_DOC")) {if(!hull.write(_pdf_)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} return FALSE;}} // latex doc

      ////////////////////////////////////////////////////////////////////////////
      // END outputs
      ////////////////////////////////////////////////////////////////////////////

      // close input specific log
      if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
    }
    //////////////////////////////////////////////////////////////////////////////
    // END Looping over hull inputs and creating desired output
    //////////////////////////////////////////////////////////////////////////////
    return TRUE;
  }
} // namespace chull

namespace chull {
//***************************************************************************//
// chull::getPath(aurostd::xoption& vpflow,const bool& silent,ostringstream&
// oss,ofstream& FileMESSAGE)
//***************************************************************************//
// gets path to redirect output
string getPath(const aurostd::xoption& vpflow, ostream& oss, bool silent) {  // overload
  ofstream FileMESSAGE;
  return getPath(vpflow, FileMESSAGE, oss, silent);
}
string getPath(const aurostd::xoption& vpflow, ofstream& FileMESSAGE, ostream& oss, bool silent) {  // main function
  string soliloquy = "chull::getPath():";
  stringstream message;
  if(!vpflow.flag("CHULL::PATH")) {
    string pwd = aurostd::execute2string(XHOST.command("pwd")) + "/";
    if(!silent){
      message << "Directing output to current directory: " << pwd;
      pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_OPTION_); //, silent);  //CO 180220 - silent now means print AT ALL
    }
    return pwd;
  }
  return getPath(vpflow.getattachedscheme("CHULL::PATH"), FileMESSAGE, oss, silent);
}
//***************************************************************************//
// chull::getPath(string _path,const bool& silent,ostream& oss,ofstream&
// FileMESSAGE)
//***************************************************************************//
// gets path to redirect output
string getPath(string _path, ostream& oss, bool silent) {  // overload
  ofstream FileMESSAGE;
  return getPath(_path, FileMESSAGE, oss, silent);
}
string getPath(string _path, ofstream& FileMESSAGE, ostream& oss, bool silent) {  // main function
  string soliloquy = "chull::getPath():";
  stringstream message;
  string pwd = aurostd::execute2string(XHOST.command("pwd"));
  string home = aurostd::execute2string(XHOST.command("echo") + " $HOME");
  string path;
  // add '/' if _path doesn't already have it
  if(_path.at(_path.length() - 1) != '/') {
    _path += "/";
  }
  // remove ./ for relative paths
  if(_path[0] == '.') {
    _path = _path.substr(1, _path.length());
    if(!_path.empty() && _path[0] == '/') {
      _path = _path.substr(1, _path.length());
    }
  }
  // home doesn't have last '/'
  if(!_path.empty() && _path[0] == '~') {
    _path = _path.substr(1, _path.length());
    if(!_path.empty() && _path[0] == '/') {
      _path = _path.substr(1, _path.length());
    }
    _path = home + "/" + _path;
  }
  // if not root path (starting with '/'), it's a relative path, add it to pwd,
  // pwd doesn't have last '/'
  if(_path.empty() || (!_path.empty() && _path[0] != '/')) {
    path = pwd + "/";
    path += _path;
  } else {
    path = _path;
  }
  
  //test of stupidity
  if(!aurostd::IsDirectory(path)){
    message << path << " does not seem to be a viable directory, changing to pwd=" << pwd;
    pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_WARNING_);
    path=pwd+"/";
  }

  if(!silent){
    message << "Directing output to " << path;
    pflow::logger(soliloquy, message, FileMESSAGE, oss, _LOGGER_OPTION_); //, silent);  //CO 180220 - silent now means print AT AL
  }
  return path;
}
} // namespace chull

namespace chull {
//***************************************************************************//
// chull::flagCheck(aurostd::xoption& vpflow,bool silent,ostringstream&
// oss,ofstream& FileMESSAGE)
//***************************************************************************//
// logs which flags are on
void flagCheck(aurostd::xoption& vpflow, ostream& oss, bool silent) {  // overload
  ofstream FileMESSAGE;
  flagCheck(vpflow, FileMESSAGE, oss, silent);
}
void flagCheck(aurostd::xoption& vpflow, ofstream& FileMESSAGE, ostream& oss, bool silent) {  // main function
  string soliloquy = "chull::flagCheck():";
  stringstream message;
  if(vpflow.flag("CHULL::TEXT_DOC")) {
    pflow::logger(soliloquy, "CHULL::TEXT_DOC set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::JSON_DOC")) {
    pflow::logger(soliloquy, "CHULL::JSON_DOC set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::WEB_DOC")) {
    pflow::logger(soliloquy, "CHULL::WEB_DOC set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::LATEX_DOC")) {
    pflow::logger(soliloquy, "CHULL::LATEX_DOC set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    if(vpflow.flag("CHULL::IMAGE_ONLY")) {
      pflow::logger(soliloquy, "CHULL::IMAGE_ONLY set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::NO_DOC")) {
      pflow::logger(soliloquy, "CHULL::NO_DOC set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::DOC_ONLY")) {
      pflow::logger(soliloquy, "CHULL::DOC_ONLY set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::KEEP_TEX")) {
      pflow::logger(soliloquy, "CHULL::KEEP_TEX set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::LATEX_OUTPUT")) {
      pflow::logger(soliloquy, "CHULL::LATEX_OUTPUT set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::LATEX_INTERACTIVE")) {
      pflow::logger(soliloquy, "CHULL::LATEX_INTERACTIVE set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::LIGHT_CONTRAST")) {
      pflow::logger(soliloquy, "CHULL::LIGHT_CONTRAST set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::LARGE_FONT")) {
      pflow::logger(soliloquy, "CHULL::LARGE_FONT set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
  }
  if(vpflow.flag("CHULL::LOG")) {
    pflow::logger(soliloquy, "CHULL::LOG set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_ENTRIES_LOAD_LIB1")) {
    pflow::logger(soliloquy, "PFLOW::LOAD_ENTRIES_LOAD_LIB1 set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_ENTRIES_LOAD_LIB2")) {
    pflow::logger(soliloquy, "PFLOW::LOAD_ENTRIES_LOAD_LIB2 set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_ENTRIES_NARIES_MINUS_ONE")) {
    pflow::logger(soliloquy, "PFLOW::PFLOW::LOAD_ENTRIES_NARIES_MINUS_ONE set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_ENTRIES_LOAD_LIB3")) {
    pflow::logger(soliloquy, "PFLOW::LOAD_ENTRIES_LOAD_LIB3 set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_ENTRIES_LOAD_ICSD")) {
    pflow::logger(soliloquy, "PFLOW::LOAD_ENTRIES_LOAD_ICSD set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_API")) {
    pflow::logger(soliloquy, "PFLOW::LOAD_API set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("PFLOW::LOAD_ENTRIES_ENTRY_OUTPUT")) {
    pflow::logger(soliloquy, "PFLOW::LOAD_ENTRIES_ENTRY_OUTPUT set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::NEGLECT")) {
    pflow::logger(soliloquy, "CHULL::NEGLECT set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::SEE_NEGLECT")) {
    pflow::logger(soliloquy, "CHULL::SEE_NEGLECT set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::REMOVE_EXTREMA")) {
    pflow::logger(soliloquy, "CHULL::REMOVE_EXTREMA set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {
    pflow::logger(soliloquy, "CHULL::ENTROPIC_TEMPERATURE set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::STABILITY_CRITERION")) {
    pflow::logger(soliloquy, "CHULL::STABILITY_CRITERION set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::DISTANCE_TO_HULL")) {
    pflow::logger(soliloquy, "CHULL::DISTANCE_TO_HULL set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::SKIP_STRUCTURE_COMPARISON")) {
    pflow::logger(soliloquy, "CHULL::SKIP_STRUCTURE_COMPARISON set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::INCLUDE_UNRELIABLE_HULLS")) {
    pflow::logger(soliloquy, "CHULL::INCLUDE_UNRELIABLE_HULLS set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("CHULL::INCLUDE_OUTLIERS")) {
    pflow::logger(soliloquy, "CHULL::INCLUDE_OUTLIERS set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
  if(vpflow.flag("FORCE")) {
    pflow::logger(soliloquy, "CHULL::FORCE set to TRUE", FileMESSAGE, oss, _LOGGER_OPTION_, silent);
  }
}
} // namespace chull

namespace chull {
  bool stabilityCriterion(const vector<string>& velements,const string& auid,double& scriterion,ostream& oss){
    ofstream FileMESSAGE;
    return stabilityCriterion(velements,auid,scriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const vector<string>& velements,const string& auid,double& scriterion,ofstream& FileMESSAGE,ostream& oss){
    vector<string> vauid;
    vauid.push_back(auid);
    vector<double> vscriterion;
    if(!stabilityCriterion(velements,vauid,vscriterion,FileMESSAGE,oss)) {return FALSE;}
    scriterion = vscriterion[0];
    return true;
  }
  bool stabilityCriterion(const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ostream& oss){
    ofstream FileMESSAGE;
    return stabilityCriterion(velements,vauid,vscriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ofstream& FileMESSAGE,ostream& oss){
    aurostd::xoption vpflow;
    pflow::defaultLoadEntriesFlags(vpflow,FileMESSAGE,oss,std::string("A"),false,true);
    return stabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,double& scriterion,ostream& oss){
    ofstream FileMESSAGE;
    return stabilityCriterion(vpflow,velements,scriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,double& scriterion,ofstream& FileMESSAGE,ostream& oss){
    string soliloquy = "chull::stabilityCriterion():";
    stringstream message;
    if(!vpflow.flag("CHULL::NEGLECT")) {
      pflow::logger(soliloquy,"CHULL::NEGLECT not set",FileMESSAGE,oss,_LOGGER_ERROR_);
      return false;
    }
    vector<string> points_neglect;
    aurostd::string2tokens(vpflow.getattachedscheme("CHULL::NEGLECT"),points_neglect,",");
    if(points_neglect.size()!=1) {
      message << "Can only handle one AUID at a time, " << points_neglect.size() << " given";
      pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
      return FALSE;
    }
    return stabilityCriterion(vpflow,velements,points_neglect[0],scriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const string& auid,double& scriterion,ostream& oss){
    ofstream FileMESSAGE;
    return stabilityCriterion(vpflow,velements,auid,scriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const string& auid,double& scriterion,ofstream& FileMESSAGE,ostream& oss){
    vector<string> vauid;
    vauid.push_back(auid);
    vector<double> vscriterion;
    if(!stabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss)) {return FALSE;}
    scriterion = vscriterion[0];
    return true;
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,vector<double>& vscriterion,ostream& oss){
    ofstream FileMESSAGE;
    return stabilityCriterion(vpflow,velements,vscriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,vector<double>& vscriterion,ofstream& FileMESSAGE,ostream& oss){
    string soliloquy = "chull::stabilityCriterion():";
    stringstream message;
    if(!vpflow.flag("CHULL::NEGLECT")) {
      pflow::logger(soliloquy,"CHULL::NEGLECT not set",FileMESSAGE,oss,_LOGGER_ERROR_);
      return FALSE;
    }
    vector<string> points_neglect;
    aurostd::string2tokens(vpflow.getattachedscheme("CHULL::NEGLECT"),points_neglect,",");
    return stabilityCriterion(vpflow,velements,points_neglect,vscriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ostream& oss) {
    ofstream FileMESSAGE;
    return stabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss);
  }
  bool stabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ofstream& FileMESSAGE,ostream& oss) {
    string soliloquy = "chull::stabilityCriterion():";
    stringstream message;
    
    //don't only remove vauid, but also equivalent gstates
    //we need organized points, simply initialize dummy hull instead of calculating TWO full hulls
    ConvexHull dummy(vpflow,FileMESSAGE,oss);
    try{dummy.initializePoints(velements);}
    catch(CHullRuntimeError& re){pflow::logger(re.where(), re.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
    catch(CHullLogicError& le){pflow::logger(le.where(), le.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
    dummy.m_initialized=true; //hack so we can get at the g-states
    uint i_point,i_coord_group,g_state;
    vector<uint> eq_gstates;
    bool found;
    vector<ChullPoint> points_to_neglect; //follows vauid
    for(uint i=0;i<vauid.size();i++){
      const string& auid=vauid[i];
      if(auid.empty()){
        message << "Empty auid found";
        pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
        return false;
      }
      if(!dummy.findPoint(auid,i_point)){
        message << "Specified auid not found on hull (auid=" << auid << ")";
        pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
        return false;
      }
      const ChullPoint& point=dummy.m_points[i_point];  //this point may not be on the hull, it may be an equivalent structure, but coordgroup is
      if(!dummy.getCoordGroupIndex(point,i_coord_group)){
        message << "Coordgroup index not set (auid=" << auid << ")";
        pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
        return false;
      }
      if(!dummy.m_coord_groups[i_coord_group].m_points.size()){
        message << "No points found within coordgroup (auid=" << auid << ")";
        pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
        return false;
      }
      //assume user knows what he's doing, we will check for sure later
      dummy.m_coord_groups[i_coord_group].m_is_on_hull=true;
      g_state=dummy.m_coord_groups[i_coord_group].m_ref_state;
      dummy.m_points[g_state].m_is_g_state=true;
      eq_gstates=dummy.getEquivalentGStates(g_state);
      //check to make sure entry with specified auid among gstates
      found=false;
      for(uint i=0;i<eq_gstates.size();i++){
        if(dummy.m_points[eq_gstates[i]].m_entry.auid==auid){found=true;}
        points_to_neglect.push_back(dummy.m_points[eq_gstates[i]]);
      }
      if(!found){
        message << "Point was not found to be an equivalent ground state structure (auid=" << auid << ")";
        pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
        return false;
      }
    }
    
    //////////////////////////////////////////////////////////////////////////////
    // START Getting entries to be neglected
    //////////////////////////////////////////////////////////////////////////////

    vector<ChullPoint> new_points;
    const vector<ChullPoint>& points=dummy.m_points;
    for(uint i=0;i<points.size();i++){
      if(points[i].m_is_artificial){continue;}  //they will be added again
      found=false;
      for(uint j=0;j<points_to_neglect.size()&&!found;j++){
        if(points[i].m_entry.auid==points_to_neglect[j].m_entry.auid){
          message << "Removing equivalent ground state (auid=" << points_to_neglect[j].m_entry.auid << ")";
          pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_MESSAGE_);
          found=true;
        }
      }
      if(found){continue;}
      new_points.push_back(points[i]);
    }
    
    //////////////////////////////////////////////////////////////////////////////
    // END Getting entries to be neglected
    //////////////////////////////////////////////////////////////////////////////
    
    message << "Create new hull without relevant g-states";
    pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_MESSAGE_);
    aurostd::xoption cflags=vpflow;
    cflags.flag("CHULL::SKIP_THERMO_POSTPROCESSING",true); //postprocessing NOT needed, just need hull
    ConvexHull hull(cflags,new_points,velements,FileMESSAGE,oss,true,true);
    if(!hull.m_initialized){return false;}
    //since i_nary and i_alloy don't change, the getDistanceToHull function should work fine (getRelevantFacets())
    uint i_nary,i_alloy;
    for (uint i=0;i<points_to_neglect.size();i++) {
      ChullPoint& point=points_to_neglect[i];
      if(!dummy.getAlloyIndex(point,i_nary,i_alloy)){
        message << "Alloy index not set (auid=" << point.m_entry.auid << ")";
        pflow::logger(soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
        return false;
      }
      xvector<int>& elements_present=dummy.m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
      point.setHullCoords(elements_present);
      try{vscriterion.push_back(hull.getDistanceToHull(point));}
      catch(CHullRuntimeError& re){pflow::logger(re.where(), re.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
      catch(CHullLogicError& le){pflow::logger(le.where(), le.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
    }

    return true;
  }
} // namespace chull

namespace chull {
// ***************************************************************************
// chull::convertUnits(double value,char units)
// ***************************************************************************
// returns value in desired units
double convertUnits(double value, char units) {
  if(units == _m_) {return value * 1e3;}
  return value;
}
double Hf_atom(const ChullPoint& point, char units) {return Hf_atom(point.m_entry,units);}
double Hf_atom(const aflowlib::_aflowlib_entry& entry, char units){return convertUnits(entry.enthalpy_formation_atom,units);}
double dist2Hull(const ChullPoint& point, char units){
  if(point.m_formation_energy_coord){return convertUnits(point.m_dist_2_hull,units);}
  else{return point.m_dist_2_hull;}  //no unit conversions coded yet here
}
double Ts(const ChullPoint& point){return Ts(point.m_entry);}
double Ts(const aflowlib::_aflowlib_entry& entry){return entry.entropic_temperature;}

int roundDouble(double doub, int multiple, bool up) {
  // rounds double to the nearest (multiple), choose round up or down
  // http://stackoverflow.com/questions/3407012/c-rounding-up-to-the-nearest-multiple-of-a-number
  int numToRound = round(doub);
  if(multiple == 0) {return numToRound;}
  int remainder = abs(numToRound) % multiple;
  if(remainder == 0) {return numToRound;}
  if(up) {
    if(numToRound < 0) {return -(abs(numToRound) - remainder);}
    else {return numToRound + multiple - remainder;}
  } else {  //down
    if(numToRound < 0) {return -(abs(numToRound) + (multiple - remainder));}
    else {return numToRound - remainder;}
  }
}
} // namespace chull

namespace chull {
//--------------------------------------------------------------------------------
// class ChullPoint
//--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
ChullPoint::ChullPoint(bool has_stoich_coords,bool is_artificial,ostream& oss) : p_FileMESSAGE(NULL) {initialize(has_stoich_coords,is_artificial,oss);}
ChullPoint::ChullPoint(const xvector<double>& coord,bool has_stoich_coords,bool is_artificial,ostream& oss) : p_FileMESSAGE(NULL) {initialize(coord,has_stoich_coords,is_artificial,oss);}
ChullPoint::ChullPoint(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_hull,ostream& oss) : p_FileMESSAGE(NULL) {initialize(velements,entry,formation_energy_hull,oss);}
ChullPoint::ChullPoint(ofstream& FileMESSAGE,bool has_stoich_coords,bool is_artificial,ostream& oss) : p_FileMESSAGE(NULL) {initialize(FileMESSAGE,has_stoich_coords,is_artificial,oss);}
ChullPoint::ChullPoint(const xvector<double>& coord,ofstream& FileMESSAGE,bool has_stoich_coords,bool is_artificial,ostream& oss) : p_FileMESSAGE(NULL) {initialize(coord,FileMESSAGE,has_stoich_coords,is_artificial,oss);}
ChullPoint::ChullPoint(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,ofstream& FileMESSAGE,bool formation_energy_hull,ostream& oss) : p_FileMESSAGE(NULL) {initialize(velements,entry,FileMESSAGE,formation_energy_hull,oss);}
ChullPoint::ChullPoint(const ChullPoint& b) {copy(b);} // copy PUBLIC

ChullPoint::~ChullPoint() {
  free();
  if(new_ofstream){delete p_FileMESSAGE;}
}

const ChullPoint& ChullPoint::operator=(const ChullPoint& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

void ChullPoint::HullCopy(const ChullPoint& b){ //copies ALL chull stuff, no entry data
  m_initialized=b.m_initialized;
  m_coords=b.m_coords;
  m_has_stoich_coords=b.m_has_stoich_coords;
  m_has_entry=b.m_has_entry;
  m_formation_energy_coord=b.m_formation_energy_coord;
  m_is_artificial=b.m_is_artificial;
  m_i_nary=b.m_i_nary;
  m_i_alloy=b.m_i_alloy;
  m_i_coord_group=b.m_i_coord_group;
  s_coords=b.s_coords;
  c_coords=b.c_coords;
  m_elements_present=b.m_elements_present;
  m_is_on_hull=b.m_is_on_hull;
  m_is_g_state=b.m_is_g_state;
  m_is_equivalent_g_state=b.m_is_equivalent_g_state;
  m_dist_2_hull=b.m_dist_2_hull;
  m_decomp_coefs=b.m_decomp_coefs;
  p_oss=b.p_oss;
  new_ofstream=b.new_ofstream;  //very important! seg faults otherwise
  p_FileMESSAGE=b.p_FileMESSAGE;
  h_coords=b.h_coords;
}

bool ChullPoint::operator<(const ChullPoint& other) const {
  //NB: this is ALWAYS sorted in descending order of stoich, no need to make options for ascending order
  //but, sorts in ascending order for energy
  string soliloquy="ChullPoint::operator<():";
  if(m_coords.rows!=other.m_coords.rows){throw CHullLogicError(soliloquy,"Dimension mismatch among points");}
  for(uint i=0;i<(uint)m_coords.rows;i++){if(m_coords[i]!=other.m_coords[i]){return (m_coords[i]<other.m_coords[i]);}}
  return false;
}

void ChullPoint::clear() {ChullPoint a; copy(a);}  //clear PUBLIC
void ChullPoint::free() {
  m_initialized=false;
  m_coords.clear();
  m_has_stoich_coords=false;
  m_entry.clear(); if(m_entry.vsg.size()==0){m_entry.vsg.push_back(NOSG);} if(m_entry.vsg2.size()==0){m_entry.vsg2.push_back(NOSG);}  //hack so it doesn't break with front(),back(),[0]
  m_has_entry=false;
  m_formation_energy_coord=false;
  m_is_artificial=false;
  m_i_nary=AUROSTD_MAX_UINT;
  m_i_alloy=AUROSTD_MAX_UINT;
  m_i_coord_group=AUROSTD_MAX_UINT;
  s_coords.clear();
  c_coords.clear();
  m_elements_present.clear();
  m_is_on_hull=false;
  m_is_g_state=false;
  m_is_equivalent_g_state=false;
  m_dist_2_hull=AUROSTD_NAN;
  m_decomp_coefs.clear();
  p_oss=NULL;
  p_FileMESSAGE=NULL;
  new_ofstream=false;
  cleanPoint();
}

void ChullPoint::copy(const ChullPoint& b) {  //copy PRIVATE
  HullCopy(b);  //copies ALL chull stuff, no entry data
  m_entry=b.m_entry; if(m_entry.vsg.size()==0){m_entry.vsg.push_back(NOSG);} if(m_entry.vsg2.size()==0){m_entry.vsg2.push_back(NOSG);}  //hack so it doesn't break with front(),back(),[0]
}

void ChullPoint::setOFStream(ofstream& FileMESSAGE){p_FileMESSAGE=&FileMESSAGE;}
void ChullPoint::setOSS(ostream& oss) {p_oss=&oss;}

bool ChullPoint::initialize(bool has_stoich_coords,bool is_artificial,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(*_p_FileMESSAGE,has_stoich_coords,is_artificial,oss); 
  new_ofstream=true;  //override
  return m_initialized;
}

bool ChullPoint::initialize(const xvector<double>& coord,bool has_stoich_coords,bool is_artificial,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(coord,*_p_FileMESSAGE,has_stoich_coords,is_artificial,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ChullPoint::initialize(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_hull,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(velements,entry,*_p_FileMESSAGE,formation_energy_hull,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ChullPoint::initialize(ofstream& FileMESSAGE,bool has_stoich_coords,bool is_artificial,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  m_has_stoich_coords=has_stoich_coords;
  m_is_artificial=is_artificial;
  m_initialized=false;  //no point
  return m_initialized;
}

bool ChullPoint::initialize(const xvector<double>& coord,ofstream& FileMESSAGE,bool has_stoich_coords,bool is_artificial,ostream& oss) {
  //we start by setting the most general coords, m_coords, relating to highest d-hull
  //then, if we can, we derive stoich and composition coords
  //it may seem "backwards", as stoich and composition are most accesible to entries, but
  //this code is GENERAL (any type of coords, not just energy/stoich)
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  initializeCoords(coord);
  m_has_stoich_coords=has_stoich_coords;
  if(m_has_stoich_coords){setStoichCoords();}
  m_is_artificial=is_artificial;
  m_initialized=true;
  return m_initialized;
}

bool ChullPoint::initialize(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,ofstream& FileMESSAGE,bool formation_energy_hull,ostream& oss) {
  //we start by setting the most general coords, m_coords, relating to highest d-hull
  //then, if we can, we derive stoich and composition coords
  //it may seem "backwards", as stoich and composition are most accesible to entries, but
  //this code is GENERAL (any type of coords, not just energy/stoich)
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  initializeCoords(velements,entry,formation_energy_hull);
  m_has_stoich_coords=true;
  setStoichCoords();
  m_is_artificial=false;
  m_initialized=true;
  return m_initialized;
}

bool ChullPoint::isGState() const{
  string soliloquy="ConvexHull::isGState():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  return m_is_on_hull || m_is_g_state || m_is_equivalent_g_state;
}

xvector<double> ChullPoint::getTruncatedGenCoords() const{
  xvector<double> r_coords(m_coords.rows-2,0);
  for(uint i=0;i<(uint)m_coords.rows-1;i++){r_coords[i]=m_coords[i];}
  return r_coords;
}

xvector<double> ChullPoint::getTruncatedCoords(const xvector<double>& coords,const xvector<int>& elements_present) const{
  string soliloquy="ChullPoint::getTruncatedStoich():";
  if(coords.rows!=elements_present.rows){throw CHullLogicError(soliloquy,"Reduction invalid, coords mismatch");}
  uint h_dim=sum(elements_present);
  xvector<double> red_coords(h_dim-1,0);
  vector<uint> relevant_indices=getRelevantIndices(elements_present);
  for(uint i=0;i<relevant_indices.size();i++){red_coords[i]=coords[relevant_indices[i]];}
  return red_coords;
}

xvector<double> ChullPoint::getTruncatedStoich(const xvector<int>& elements_present) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullPoint::getTruncatedStoich():";
  if(!m_has_stoich_coords){throw CHullLogicError(soliloquy,"Non-stoich coordinates");}
  xvector<double> coords=getTruncatedCoords(s_coords,elements_present);
  if(LDEBUG){cerr << soliloquy << " truncated stoich for " << s_coords << " is " << coords << " (elements_present=" << elements_present << ")" << endl;}
  return coords;
}

xvector<double> ChullPoint::getTruncatedComp(const xvector<int>& elements_present) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullPoint::getTruncatedComp():";
  if(!m_has_stoich_coords){throw CHullLogicError(soliloquy,"Non-stoich coordinates");}
  xvector<double> coords=getTruncatedCoords(c_coords,elements_present);
  if(LDEBUG){cerr << soliloquy << " truncated comp for " << c_coords << " is " << coords << " (elements_present=" << elements_present << ")" << endl;}
  return coords;
}

xvector<double> ChullPoint::getRedComp() const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullPoint::getRedComp():";
  if(!m_has_stoich_coords){throw CHullLogicError(soliloquy,"Non-stoich coordinates");}
  xvector<double> coords=aurostd::reduceByGCD(c_coords,ZERO_TOL);
  if(LDEBUG){cerr << soliloquy << " reduced comp for " << c_coords << " is " << coords << endl;}
  return coords;
}

uint ChullPoint::loadXstructures(bool relaxed_only) {  //load relaxed only
  if(!pflow::loadXstructures(m_entry,*p_FileMESSAGE,*p_oss,relaxed_only)){return false;}
  return m_entry.vstr.size();
}

bool ChullPoint::getMostRelaxedXstructure(xstructure& xstr) const { //this is const!
  aflowlib::_aflowlib_entry entry; entry.auid=m_entry.auid; entry.aurl=m_entry.aurl;  //fast copy
  if(!pflow::loadXstructures(entry,*p_FileMESSAGE,*p_oss,true)){return false;}
  if(entry.vstr.size()==1){xstr=entry.vstr[0]; return true;}
  return false;
}

//small get()'s of fundamental types get copies, otherwise const&
double ChullPoint::getLastCoord() const {return m_coords[m_coords.urows];}
uint ChullPoint::getDim() const {return m_coords.rows;}
bool ChullPoint::isUnary() const {return m_i_nary==0;}
double ChullPoint::getEnergy() const {return m_entry.enthalpy_formation_atom;}
double ChullPoint::getEntropicTemperature() const {return m_entry.entropic_temperature;}
const string& ChullPoint::getSG() const {return m_entry.vsg.back();}  //tight tolerance fine!

//since we don't check ALL attributes of entry, then we weed out MORE
//entries existing in different catalogs will not be strictly identical
//avoid this by comparing only the most pertinent information
bool ChullPoint::entryIdentical(const aflowlib::_aflowlib_entry& other) const {
  return (m_entry.compound==other.compound) && 
    (m_entry.prototype==other.prototype) && //believe it or not, compound + prototype is PROBABLY enough, but let's be sure
    (aurostd::identical(m_entry.enthalpy_formation_atom,other.enthalpy_formation_atom,ENERGY_TOL)) &&
    (m_entry.vsg==other.vsg);
}

void ChullPoint::initializeCoords(const xvector<double>& coord) {
  clear();
  setGenCoords(coord);
  setHullCoords();  //default, will change later with increasing dims
}

void ChullPoint::initializeCoords(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_hull) {
  clear();
  addEntry(entry);
  setGenCoords(velements,m_entry,formation_energy_hull);
  setHullCoords();  //default, will change later with increasing dims
  m_has_entry=true;
}

void ChullPoint::addEntry(const aflowlib::_aflowlib_entry& entry) {
  m_entry=entry;
  if(CORRECT_BAD_DATABASE){m_entry.correctBadDatabase(*p_FileMESSAGE,true,*p_oss);} //verbose
}

void ChullPoint::setGenCoords(const xvector<double>& coord) {m_coords=coord;aurostd::shiftlrows(m_coords,0);}
void ChullPoint::setGenCoords(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_hull) {
  xvector<double> coord(velements.size()-1,0);
  double c_sum=0.0;
  bool found;
  for(uint i=0;i<entry.vcomposition.size();i++){c_sum+=entry.vcomposition[i];}  //derive stoich exactly!
  for(uint i=0;i<velements.size()-1;i++){
    found=false;
    for(uint j=0;j<entry.vspecies.size() && !found;j++){
      if(velements[i]==entry.vspecies[j]){
        coord[i]=entry.vcomposition[j]/c_sum;
        found=true;
      }
    }
  }
  m_formation_energy_coord=formation_energy_hull;
  if(m_formation_energy_coord){coord[coord.urows]=entry.enthalpy_formation_atom;}
  else{coord[coord.urows]=entry.entropic_temperature;}  //entropic temperature is positive for stable compounds (we want upper half convex-hull)
  setGenCoords(coord);
}

vector<uint> ChullPoint::getRelevantIndices(const xvector<int>& elements_present) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullPoint::getRelevantIndices():";
  if(!m_has_stoich_coords){throw CHullLogicError(soliloquy,"Non-stoich coordinates");}
  if(elements_present.rows!=s_coords.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between point and elements_present");}
  vector<uint> relevant_indices;
  for(uint i=0;i<(uint)elements_present.rows;i++){
    if(elements_present[i]==0 && abs(s_coords[i])>=ZERO_TOL){throw CHullLogicError(soliloquy,"Attempting to reduce non-zero coord");}
    if(elements_present[i]==1){relevant_indices.push_back(i);}
  }
  if(LDEBUG){
    cerr << soliloquy << " relevant indices=";
    for(uint i=0;i<relevant_indices.size();i++){cerr << relevant_indices[i] << (i!=relevant_indices.size()-1?",":"");}
    cerr << " (elements_present=" << elements_present << ")" << endl;
  }
  return relevant_indices;
}

void ChullPoint::setStoichCoords() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullPoint::setStoichCoords():";
  if(!m_has_stoich_coords){throw CHullLogicError(soliloquy,"Non-stoich coordinates");}
  double c_sum=0.0; //concentration sum
  xvector<double> stoich(m_coords.urows,0);
  xvector<int> elements_present(m_coords.urows,0);
  if(LDEBUG){cerr << soliloquy << " m_coords=" << m_coords << endl;}
  for(uint j=0;j<(uint)m_coords.rows-1;j++){
    if(std::signbit(m_coords[j])){throw CHullLogicError(soliloquy,"Negative stoich coordinate found");} //no negative numbers in stoich coordinates, only energy
    stoich[j]=m_coords[j];
    if(m_coords[j]>=ZERO_TOL){elements_present[j]=1;}
    c_sum+=m_coords[j];
  }
  stoich[stoich.urows]=(1.0-c_sum); //hidden dimension
  if(std::signbit(stoich[stoich.urows])){throw CHullLogicError(soliloquy,"Negative stoich coordinate found");}  //no negative numbers
  if(stoich[stoich.urows]>=ZERO_TOL){elements_present[elements_present.urows]=1;}   //check if nary++
  s_coords=stoich;
  c_coords=s_coords;
  if(m_has_entry){
    c_sum=0.0;
    for(uint i=0;i<m_entry.vcomposition.size();i++){c_sum+=m_entry.vcomposition[i];}  //derive stoich exactly! better than natoms (double vs. uint)
    c_coords*=c_sum;
  }
  m_elements_present=elements_present;
  m_i_nary=sum(elements_present)-1;
  setHullCoords(elements_present);  //default, will change later with increasing dims
}

void ChullPoint::setHullCoords() {setHullCoords(m_coords);}  //default to m_coords
void ChullPoint::setHullCoords(const xvector<double>& coords) {h_coords=coords;}
void ChullPoint::setHullCoords(const xvector<int>& elements_present) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullPoint::setHullCoords():";
  uint h_dim=sum(elements_present);
  xvector<double> coords(h_dim-1,0);
  vector<uint> relevant_indices=getRelevantIndices(elements_present);
  for(uint i=0;i<relevant_indices.size();i++){coords[i]=m_coords[relevant_indices[i]];}
  coords[coords.urows]=getLastCoord(); //overwrite last coord appropriately
  
  if(LDEBUG){
    cerr << soliloquy << " elements_present=" << elements_present << endl;
    cerr << soliloquy << " s_coords=" << s_coords << endl;
    cerr << soliloquy << " c_coords=" << c_coords << endl;
    cerr << soliloquy << " setting h_coords=" << coords << endl;
  }

  setHullCoords(coords);
}

void ChullPoint::cleanPoint() {h_coords.clear();}
} // namespace chull

namespace chull {
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
FacetPoint::FacetPoint() {free();}
FacetPoint::FacetPoint(const ChullPoint& point,uint index,bool full_copy){initialize(point,index,full_copy);}  //need BOTH point and index, otherwise, just use point/index independently
FacetPoint::FacetPoint(const FacetPoint& b) {copy(b);}  // copy PUBLIC
FacetPoint::~FacetPoint() {free();}

const FacetPoint& FacetPoint::operator=(const FacetPoint& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

//simple sort, so ONLY sort facets from the same hull
bool FacetPoint::operator<(const FacetPoint& other) const {return ch_index<other.ch_index;}
void FacetPoint::clear() {FacetPoint a; copy(a);} //clear PUBLIC
void FacetPoint::free() {
  m_initialized=false;
  ch_index=AUROSTD_MAX_UINT;
  ch_point.clear();
}

void FacetPoint::copy(const FacetPoint& b) { //copy PRIVATE
  m_initialized=b.m_initialized;
  ch_index=b.ch_index;
  ch_point=b.ch_point;
}

void FacetPoint::initialize(const ChullPoint& point,uint index,bool full_copy) {
  if(full_copy){ch_point=point;}
  else{ch_point.HullCopy(point);} //fast copy of just hull relevant data, not extra entry data, for this, use index in ConvexHull
  ch_index=index;
  m_initialized=true;
}
} // namespace chull

//nice sorters for points we know sit on a thermo hull (stoich coords + energy dimension)
namespace chull {
bool sortThermoPoints::operator() (const FacetPoint& fpi,const FacetPoint& fpj) const{
  string soliloquy="ConvexHull::sortThermoPoints::operator():";
  const ChullPoint& ci=fpi.ch_point;
  const ChullPoint& cj=fpj.ch_point;
  return (*this).operator()(ci,cj);
}

bool sortThermoPoints::operator() (const ChullPoint& ci,const ChullPoint& cj) const{
  string soliloquy="ConvexHull::sortThermoPoints::operator():";
  if(!(ci.m_initialized && cj.m_initialized)){throw CHullLogicError(soliloquy,"Points not initialized");}
  //do not first sort binaries from ternaries, screws up facet sorting
  //keep sorting based on concentration of elements in relative order
  //if(ci.m_has_stoich_coords&&cj.m_has_stoich_coords){
  //  if(ci.m_i_nary!=cj.m_i_nary){return ci.m_i_nary<cj.m_i_nary;} //binaries before ternaries
  //}
  if(ci.m_coords.rows!=cj.m_coords.rows){throw CHullLogicError(soliloquy,"Dimension mismatch among points");}
  else{
    for(uint i=0;i<(uint)ci.m_coords.rows-1;i++){
      if(ci.m_coords[i]!=cj.m_coords[i]){
        return m_sort_stoich_ascending ? (ci.m_coords[i]<cj.m_coords[i]) : (ci.m_coords[i]>cj.m_coords[i]);
      }
    }
    if(ci.getLastCoord()!=cj.getLastCoord()){
      return m_sort_energy_ascending ? (ci.getLastCoord()<cj.getLastCoord()) : (ci.getLastCoord()>cj.getLastCoord());
    }
    return false; //true; //breaks if true
  }
}
} //namespace chull

namespace chull {
//--------------------------------------------------------------------------------
// class ChullFacet
//--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
ChullFacet::ChullFacet(ostream& oss) : p_FileMESSAGE(NULL) {create(oss);}
ChullFacet::ChullFacet(ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {create(FileMESSAGE,oss);}
ChullFacet::ChullFacet(const ChullFacet& b) {copy(b);} // copy PUBLIC
ChullFacet::~ChullFacet() {
  free();
  if(new_ofstream){delete p_FileMESSAGE;}
}

const ChullFacet& ChullFacet::operator=(const ChullFacet& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

bool ChullFacet::operator<(const ChullFacet& other) const {
  string soliloquy="ChullFacet::operator<():";
  if(m_vertices.size()!=other.m_vertices.size()){throw CHullLogicError(soliloquy,"Dimension mismatch between facet points");}

  //simply sort by m_point (indices)
  for(uint i=0;i<m_vertices.size();i++){
    if(!(m_vertices[i].m_initialized && other.m_vertices[i].m_initialized)){throw CHullLogicError(soliloquy,"Uninitialized facetpoint");}
    if(m_vertices[i].ch_index!=other.m_vertices[i].ch_index){return m_vertices[i].ch_index<other.m_vertices[i].ch_index;}
  }
  return false;
}

void ChullFacet::clear() {ChullFacet a; copy(a);}  //clear PRIVATE
void ChullFacet::free() {
  m_initialized=false;
  m_vertices.clear();
  m_dim=AUROSTD_MAX_UINT;
  m_has_stoich_coords=false;
  m_directive_vectors.clear();
  m_normal.clear();
  m_offset=AUROSTD_NAN;
  m_facet_centroid.clear();
  m_hull_reference.clear();
  m_is_vertical=false;
  m_is_artificial=false;
  m_in_lower_hemisphere=false;
  m_ridges.clear();
  p_oss=NULL;
  p_FileMESSAGE=NULL;
  new_ofstream=false;
  cleanFacet();
}

void ChullFacet::copy(const ChullFacet& b) {  //copy PRIVATE
  m_initialized=b.m_initialized;
  m_vertices.clear(); for(uint i=0;i<b.m_vertices.size();i++){m_vertices.push_back(b.m_vertices[i]);}
  m_dim=b.m_dim;
  m_has_stoich_coords=b.m_has_stoich_coords;
  m_directive_vectors.clear(); for(uint i=0;i<b.m_directive_vectors.size();i++){m_directive_vectors.push_back(b.m_directive_vectors[i]);}
  m_normal=b.m_normal;
  m_offset=b.m_offset;
  m_facet_centroid=b.m_facet_centroid;
  m_hull_reference=b.m_hull_reference;
  m_is_vertical=b.m_is_vertical;
  m_is_artificial=b.m_is_artificial;
  m_in_lower_hemisphere=b.m_in_lower_hemisphere;
  f_visited=b.f_visited;
  f_outside_set.clear(); for(uint i=0;i<b.f_outside_set.size();i++){f_outside_set.push_back(b.f_outside_set[i]);}
  f_furthest_point=b.f_furthest_point;
  m_ridges.clear(); for(uint i=0;i<b.m_ridges.size();i++){m_ridges.push_back(b.m_ridges[i]);}
  f_neighbors.clear(); for(uint i=0;i<b.f_neighbors.size();i++){f_neighbors.push_back(b.f_neighbors[i]);}
  p_oss=b.p_oss;
  new_ofstream=b.new_ofstream;  //very important! seg faults otherwise
  p_FileMESSAGE=b.p_FileMESSAGE;
}

bool ChullFacet::shareRidge(const ChullFacet& other) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::shareRidge():";
  bool match;
  for(uint i=0;i<m_ridges.size();i++){
    const vector<uint>& ridge_indices1=m_ridges[i].getCHIndices();
    for(uint j=0;j<other.m_ridges.size();j++){
      const vector<uint>& ridge_indices2=other.m_ridges[j].getCHIndices();
      if(LDEBUG){
        cerr << soliloquy << " comparing ";
        for(uint ri=0;ri<ridge_indices1.size();ri++){cerr << ridge_indices1[ri] << " ";}
        cerr << " vs. ";
        for(uint rj=0;rj<ridge_indices1.size();rj++){cerr << ridge_indices2[rj] << " ";}
      }
      match=ridge_indices1==ridge_indices2;
      if(LDEBUG){cerr << (match?"MATCH":"NO") << endl;}
      if(match){return true;}
    }
  }
  return false;
}

bool ChullFacet::isPointOnFacet(const FacetPoint& fp) const {
  string soliloquy="ChullFacet::isPointOnFacet():";
  if(!fp.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized facetpoint");}
  return isPointOnFacet(fp.ch_index);
}

bool ChullFacet::isPointOnFacet(uint i_point) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::isPointOnFacet():";
  if(m_vertices.size()==0){throw CHullLogicError(soliloquy,"Facet has no vertices");}
  //if(!m_initialized){throw CHullLogicError(soliloquy,"Uninitialized facet");}
  if(LDEBUG){cerr << soliloquy << "checking if point[" << i_point << "] is on this facet" << endl;}
  for(uint i=0;i<m_vertices.size();i++){
    if(LDEBUG){cerr << soliloquy << "m_vertices[i].ch_index==" << m_vertices[i].ch_index << " ?= i_point==" << i_point << endl;}
    if(m_vertices[i].ch_index==i_point){return true;}
  }
  if(LDEBUG){cerr << soliloquy << " point[" << i_point << "] is not on this facet" << endl;}
  return false;
}

bool ChullFacet::isPointOutside(const FacetPoint& f_point) const {
  string soliloquy="ChullFacet::isPointOutside():";
  if(!f_point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized facetpoint");}
  if(isPointOnFacet(f_point)){return false;}
  return isPointOutside(f_point.ch_point);
}

bool ChullFacet::isPointOutside(const ChullPoint& point) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::isPointOutside():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Facet not initialized");}
  double dist_point=pointPlaneDistance(point);
  bool is_outside;
  //special case no longer needed, but we keep here just in case
  //if(m_is_vertical){
  //  if(LDEBUG){cerr << soliloquy << " performing special VERTICAL facet check for outside-ness" << endl;}
  //  xvector<double> ref=m_hull_reference;
  //  for(uint i=0;i<(uint)ref.rows-1;i++){ref[i]=1.0/m_dim;}
  //  if(LDEBUG){cerr << soliloquy << " ref=" << ref << endl;}
  //  double dist_ref=pointPlaneDistance(point);
  //  is_outside=(std::signbit(dist_point)!=std::signbit(dist_ref) && abs(dist_point)>=ZERO_TOL);
  //  if(LDEBUG){cerr << soliloquy << " sign of distance indicates point is " << (is_outside?"OUTSIDE":"INSIDE") << " hull" << endl;}
  //  return is_outside;
  //}
  //if(LDEBUG){cerr << soliloquy << " performing normal check for outside-ness (not vertical facet)" << endl;}
  if(LDEBUG){
    cerr << soliloquy << " looking at facet with vertices: ";
    for(uint i=0;i<m_vertices.size();i++){
      cerr << m_vertices[i].ch_point.m_coords << " | ";
    }
    cerr << "m_normal=" << m_normal << endl;
    cerr << soliloquy << " checking if point[h_coords=" << point.h_coords << "] is on this facet" << endl;
    cerr << soliloquy << " dist=" << dist_point << endl;
  }     
  //point is on facet
  if(abs(dist_point)<ZERO_TOL){
    if(LDEBUG){cerr << soliloquy << " point appears to be right on top of facet" << endl;}
    return false;
  }
  is_outside=(std::signbit(dist_point));
  if(LDEBUG){cerr << soliloquy << " sign of distance indicates point is " << (is_outside?"OUTSIDE":"INSIDE") << " hull" << endl;}
  return std::signbit(dist_point);                //shortcut with inward-aligned normal
}

double ChullFacet::pointPlaneDistance(const ChullPoint& point) const {return pointPlaneDistance(point.h_coords);}
double ChullFacet::pointPlaneDistance(const xvector<double>& point) const {
  string soliloquy="ChullFacet::pointPlaneDistance():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Facet not initialized");}
  if(point.rows!=m_vertices[0].ch_point.h_coords.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between point and facet");}
  xvector<double> diff=point-m_vertices[0].ch_point.h_coords;
  return scalar_product(m_normal,diff);
}

double ChullFacet::zeroPointProjectionDistance(const ChullPoint& point) const {
  string soliloquy="ChullFacet::zeroPointProjectionDistance():";
  return zeroPointProjectionDistance(point.h_coords);
}

double ChullFacet::zeroPointProjectionDistance(const xvector<double>& point) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::zeroPointProjectionDistance():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Uninitialized facet");}
  if(m_normal.rows!=point.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between facet["+aurostd::utype2string(m_normal.rows)+"] and point["+aurostd::utype2string(point.rows)+"]");}
  double dist=-m_offset;
  for(uint i=0;i<(uint)point.rows-1;i++){dist-=m_normal[i]*point[i];} //note that we don't go to rows (because we assume it is zero)
  dist/=m_normal[m_normal.urows];
  if(LDEBUG){
    cerr << soliloquy << " point=" << point << " projected onto facet with normal=" << m_normal << " and offset=" << m_offset << endl;
    cerr << soliloquy << " dist=" << dist << endl;
  }
  return dist;
}

double ChullFacet::verticalDistance(const ChullPoint& point,bool zero_point_projection_only) const {
  string soliloquy="ChullFacet::verticalDistance():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Uninitialized facet");}
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  return verticalDistance(point.h_coords,zero_point_projection_only);
}

double ChullFacet::verticalDistance(const xvector<double>& point,bool zero_point_projection_only) const {
  //NB: we approximate the facet to be a hyperplane (hence not verticalDistance2Facet)
  //also, this is the vertical distance, not the shortest (vertical is chemically meaningful)
  //to find the true distance between point and facet, must use quadratic programming
  //https://www.mathworks.com/matlabcentral/answers/107595-how-can-i-find-the-minimum-distance-from-convex-boundary
  //https://stackoverflow.com/questions/18230259/computing-distance-from-a-point-to-a-triangulation-in-3d-with-matlab
  string soliloquy="ChullFacet::verticalDistance():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Uninitialized facet");}
  double dist=zeroPointProjectionDistance(point);
  if(zero_point_projection_only){return dist;}
  dist-=point[point.urows];
  return dist;
}

vector<uint> ChullFacet::getCHIndices() const {
  string soliloquy="ChullFacet::getCHIndices():";
  if(!m_vertices.size()){throw CHullLogicError(soliloquy,"No vertices found");}
  vector<uint> vi;
  for(uint i=0;i<m_vertices.size();i++){vi.push_back(m_vertices[i].ch_index);}
  return vi;
}

void ChullFacet::create(ostream& oss) { //this it NOT an initialization, as we do this piece by piece
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  create(*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
}

void ChullFacet::create(ofstream& FileMESSAGE,ostream& oss) { //this it NOT an initialization, as we do this piece by piece
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
}

void ChullFacet::setOFStream(ofstream& FileMESSAGE){p_FileMESSAGE=&FileMESSAGE;}
void ChullFacet::setOSS(ostream& oss) {p_oss=&oss;}

void ChullFacet::addVertex(const FacetPoint& fp){m_vertices.push_back(fp);}
void ChullFacet::addVertex(const ChullPoint& point,uint index) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  stringstream message;
  string soliloquy="ChullFacet::addVertex():";
  if(m_vertices.size()==0){
    m_has_stoich_coords=point.m_has_stoich_coords;
    if(LDEBUG){cerr << soliloquy << " setting has_stoich_coords=" << m_has_stoich_coords << endl;}
  }
  else{
    if(m_has_stoich_coords && !point.m_has_stoich_coords){
      message << "Mismatch among coord types (stoich vs. non-stoich coords), assuming non-stoich coords";
      pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      m_has_stoich_coords=false; //(m_has_stoich_coords && point.m_has_stoich_coords);
    }
  }
  m_vertices.push_back(FacetPoint(point,index,false));  //no need for full copy
}

void ChullFacet::initialize(const xvector<double>& ref,uint h_dim,bool check_validity){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::initialize():";
  if(LDEBUG){
    cerr << soliloquy << " initialize facet with points: " << endl;
    for(uint i=0;i<m_vertices.size();i++){cerr << "    " << m_vertices[i].ch_point.h_coords << endl;}
  }
  m_dim=h_dim;
  m_hull_reference=ref;
  setDirectiveVectors(check_validity);
  setNormal(check_validity);
  setOffset();  //FIX after normal alignment
  setCentroid();
  alignNormalInward(); //hull centroid
  setVertical();
  setArtificial();
  setHemisphere();
  setRidges();
  m_initialized=true;
}

bool ChullFacet::hasValidPoints(string& error){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::hasValidPoints():";
  error.clear();
  if(!m_vertices.size()){error="Facet has no defining points";return false;}
  for(uint i=0;i<m_vertices.size();i++){if(!m_vertices[i].m_initialized){error="Uninitialized facetpoint";}}
  if((uint)m_vertices[0].ch_point.h_coords.rows!=m_vertices.size()){
    if(LDEBUG){
      cerr << soliloquy << " m_vertices[0].ch_point.h_coords.rows=" << m_vertices[0].ch_point.h_coords.rows;
      cerr << " vs. m_vertices.size()=" << m_vertices.size() << endl;
    }
    error="Dimension mismatch among points and coordinates";return false;
  }
  for(uint i=1;i<m_vertices.size();i++){
    if(LDEBUG){
      cerr << soliloquy << " " << m_vertices[i].ch_index << "  h_coords=" << m_vertices[i].ch_point.h_coords << endl;
      cerr << soliloquy << " m_vertices[i].ch_point.h_coords.rows=" << m_vertices[i].ch_point.h_coords.rows << " vs. m_vertices[0].ch_point.h_coords.rows=" << m_vertices[0].ch_point.h_coords.rows << endl;
    }
    if(m_vertices[i].ch_point.h_coords.rows!=m_vertices[0].ch_point.h_coords.rows){error="Dimension mismatch among facet points";return false;}
  }
  for(uint i=0;i<m_vertices.size();i++) {
    for(uint j=i+1;j<m_vertices.size();j++) {
      if(m_vertices[i].ch_index==m_vertices[j].ch_index){error="Facet points are degenerate";return false;}
    }
  }
  if(m_vertices.size()!=(uint)m_vertices[0].ch_point.h_coords.rows){error="Facet has wrong number of defining points given dimension";return false;}
  return true;
}

void ChullFacet::setDirectiveVectors(bool check_validity){  //perhaps we already checked...
  string soliloquy="ChullFacet::setDirectiveVectors():";
  m_directive_vectors.clear();
  string error;
  if(check_validity && !hasValidPoints(error)){throw CHullLogicError(soliloquy,error);}
  
  std::sort(m_vertices.begin(),m_vertices.end());
  for(uint i=1;i<m_vertices.size();i++){
    m_directive_vectors.push_back( m_vertices[i].ch_point.h_coords - m_vertices[0].ch_point.h_coords );
  }
}

bool ChullFacet::pointsMatchDirectiveVectors(string& error){
  error.clear();
  //now we can define 
  if(m_directive_vectors.size()!=m_vertices.size()-1){error="Dimension mismatch among directive vectors and points";return false;}
  if((uint)m_directive_vectors[0].rows!=m_vertices.size()){error="Dimension mismatch among directive vectors coordinates and points";return false;}
  return true;
}

bool ChullFacet::hasValidDirectiveVectors(string& error){
  error.clear();
  if(!m_directive_vectors.size()){error="No directive vectors found";return false;}
  for(uint i=1;i<m_directive_vectors.size();i++){
    if(m_directive_vectors[i].rows!=m_directive_vectors[0].rows){error="Dimension mismatch among directive vectors coordinates";return false;}
  }
  for(uint i=0;i<m_directive_vectors.size();i++){if(modulus(m_directive_vectors[i])<ZERO_TOL){error="Ill-defined directive vectors";return false;}}
  return true;
}

bool ChullFacet::hasCollinearVectors(bool check_validity){  //perhaps we already checked...
  string soliloquy="ChullFacet::hasCollinearVectors():";
  string error;
  if(check_validity && !pointsMatchDirectiveVectors(error)){throw CHullLogicError(soliloquy,error);}
  if(check_validity && !hasValidDirectiveVectors(error)){throw CHullLogicError(soliloquy,error);}
  for(uint i=0;i<(m_directive_vectors.size()-1);i++) {
    for(uint j=i+1;j<m_directive_vectors.size();j++) {
      if(aurostd::isCollinear(m_directive_vectors[i],m_directive_vectors[j],ZERO_TOL)){return true;}
    }
  }
  return false;
}

bool ChullFacet::isValid(string& error) {
  error.clear();
  if(!hasValidPoints(error)){return false;}
  setDirectiveVectors(false);
  if(!pointsMatchDirectiveVectors(error)){return false;}
  if(!hasValidDirectiveVectors(error)){return false;}
  if(hasCollinearVectors(false)){error="Directive vectors are collinear";return false;}
  return true;
}

void ChullFacet::setNormal(bool check_validity){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::setNormal():";
  m_normal.clear();
  string error;
  if(check_validity && !isValid(error)){throw CHullLogicError(soliloquy,error);}
  if(LDEBUG){
    for(uint i=0;i<m_directive_vectors.size();i++){
      cerr << soliloquy << " directive_vector[" << i << "]=" << m_directive_vectors[i] << endl;
    }
  }
  if(!m_directive_vectors.size()){throw CHullLogicError(soliloquy,"No directive vectors calculated");}
  m_normal=aurostd::getGeneralNormal(m_directive_vectors);
  if(aurostd::modulus(m_normal)<ZERO_TOL){throw CHullLogicError(soliloquy,"Invalid normal calculated");}
  if(LDEBUG){cerr << soliloquy << " normal=" << m_normal << endl;}
}

void ChullFacet::setOffset(){
  string soliloquy="ChullFacet::setOffset():";
  if(!m_vertices.size()){throw CHullLogicError(soliloquy,"Facet has not been defined");}
  const xvector<double>& plane_point=m_vertices[0].ch_point.h_coords;
  if(m_normal.rows!=plane_point.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between normal and point");}
  m_offset=-scalar_product(m_normal,plane_point);
}

void ChullFacet::setCentroid() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::setCentroid():";
  vector<xvector<double> > points;
  for(uint i=0;i<m_vertices.size();i++){points.push_back(m_vertices[i].ch_point.h_coords);}
  m_facet_centroid=aurostd::getCentroid(points);
  if(LDEBUG){cerr << soliloquy << " centroid: " << m_facet_centroid << endl;}
}

//_AFLOW_CHULL_VERTICAL_PLANE_TOLERANCE_ = 1e-4 for Hf_atom, else 1e-9 for Ts
void ChullFacet::setVertical(){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::setVertical():";
  if(LDEBUG){cerr << soliloquy << " looking if vertical hull: normal=" << m_normal << endl;}
  m_is_vertical=(abs(m_normal[m_normal.urows])<ZERO_TOL); //simple
}

void ChullFacet::setArtificial(){  //in half hulls, this finds the facet of all artificial points
  string soliloquy="ChullFacet::setArtificial():";
  for(uint i=0;i<m_vertices.size();i++){if(!m_vertices[i].ch_point.m_is_artificial){m_is_artificial=false;return;;}}
  m_is_artificial=true;return;
}

void ChullFacet::alignNormalInward() { 
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::alignNormalInward():";
  //we want normal pointing inward
  double dist=scalar_product(m_normal,m_hull_reference)+m_offset;  //point-plane distance formula without normalization
  if(LDEBUG){
    cerr << soliloquy << " m_normal=" << m_normal << endl;
    cerr << soliloquy << " h_reference=" << m_hull_reference << endl;
    cerr << soliloquy << " dist=" << dist << endl;
  }
  bool negate=std::signbit(dist);
  if(negate){
    if(LDEBUG){cerr << soliloquy << " NEGATING" << endl;}
    m_normal=-m_normal; 
    m_offset=-m_offset; //flips sign of offset
  }
  if(LDEBUG){cerr << soliloquy << " aligned normal=" << m_normal << endl;}
}

void ChullFacet::setHemisphere() {
  string soliloquy="ChullFacet::alignNormalInward():";
  //vertical facets are NOT considered lower_hemisphere
  m_in_lower_hemisphere=(!m_is_vertical && !std::signbit(m_normal[m_normal.urows])); //not flat and upward pointed normal
}

void ChullFacet::setFurthestPoint(){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::setFurthestPoint():";
  f_furthest_point.clear();
  if(!m_initialized){throw CHullLogicError(soliloquy,"Facet not initialized");}
  if(!f_outside_set.size()){return;}
  if(LDEBUG){cerr << soliloquy << " getting furthest point for facet with normal " << m_normal << " (is_artificial=" << m_is_artificial << ")" << endl;}
  double dist=AUROSTD_MAX_DOUBLE,max_dist=0;
  for(uint i=0;i<f_outside_set.size();i++){
    dist=abs(pointPlaneDistance(f_outside_set[i].ch_point.h_coords)); //we only care about magnitude here
    if(LDEBUG){cerr << soliloquy << " point=" << f_outside_set[i].ch_point.h_coords << " is " << dist << " from facet" << endl;}
    if(dist>max_dist){
      max_dist=dist;
      f_furthest_point=f_outside_set[i];
    }
  }
  if(LDEBUG){
    cerr << soliloquy << " furthest point from facet:" << endl;
    for(uint i=0;i<m_vertices.size();i++){cerr << "       point[" << m_vertices[i].ch_index << "]=" << m_vertices[i].ch_point.h_coords << endl;}
    cerr << "    is point[" << f_furthest_point.ch_index << "]=" << f_furthest_point.ch_point.h_coords << endl;
  }
}

void ChullFacet::setRidges(){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ChullFacet::setRidges():";
  m_ridges.clear();
  if(!m_vertices.size()){throw CHullLogicError(soliloquy,"Facet has no vertices");}
  for(uint i=(m_vertices.size()-1);i<m_vertices.size();i--){  //wrap around to HUGE number
    m_ridges.push_back(ChullFacet());
    for(uint j=0;j<m_vertices.size();j++){
      if(i!=j){m_ridges.back().m_vertices.push_back(m_vertices[j]);}
    }
    if(m_ridges.back().m_vertices.size()!=m_dim-1){throw CHullLogicError(soliloquy,"Ridge vertex count and facet dimension mismatch");}
    std::sort(m_ridges.back().m_vertices.begin(),m_ridges.back().m_vertices.end());
  }
  std::sort(m_ridges.begin(),m_ridges.end());
  
  if(LDEBUG){
    for(uint i=0;i<m_ridges.size();i++){
      cerr << soliloquy << " ridges for facet[" << i << "]: ";
      for(uint j=0;j<m_ridges[i].m_vertices.size();j++){
        cerr << m_ridges[i].m_vertices[j].ch_index << " " ;
      }
      cerr << endl;
    }
  }
}

void ChullFacet::cleanFacet() {
  f_visited=false;
  f_outside_set.clear();
  f_furthest_point.clear();
  f_neighbors.clear();
}
} // namespace chull

namespace chull {
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
CoordGroup::CoordGroup() {free();}
CoordGroup::CoordGroup(const xvector<double>& coord,bool has_stoich_coords) {initialize(coord,has_stoich_coords);}
CoordGroup::CoordGroup(const CoordGroup& b) {copy(b);}  // copy PUBLIC
CoordGroup::~CoordGroup() {free();}

const CoordGroup& CoordGroup::operator=(const CoordGroup& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

bool CoordGroup::operator<(const CoordGroup& other) const {
  // safety, so it doesn't break, but it's outside scope of function
  string soliloquy="CoordGroup::operator<():";
  if(m_coords.rows!=other.m_coords.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between stoichiometries");} //{return (m_coords.rows<other.m_coords.rows);}
  for(uint i=0;i<(uint)m_coords.rows;i++) {
    if(m_coords(i)!=other.m_coords(i)) {return (m_coords(i)<other.m_coords(i));}
  }
  return false;
}

void CoordGroup::clear() {CoordGroup a; copy(a);} //clear PUBLIC
void CoordGroup::free() {
  m_initialized=false;
  m_coords.clear();
  m_points.clear();
  m_has_stoich_coords=false;
  m_has_artificial_unary=false;
  m_is_on_hull=false;
  m_hull_member=AUROSTD_MAX_UINT;
  m_ref_state=AUROSTD_MAX_UINT;
  m_hull_points.clear();
  m_i_nary=AUROSTD_MAX_UINT;
  m_i_alloy=AUROSTD_MAX_UINT;
  m_nearest_facet=AUROSTD_MAX_UINT;
  m_nearest_distance=AUROSTD_MAX_DOUBLE;
  m_decomp_phases.clear();
  m_decomp_coefs.clear();
  m_equilibrium_phases.clear();
  m_equivalent_g_states.clear();
}

void CoordGroup::copy(const CoordGroup& b) {
  m_initialized=b.m_initialized;
  m_coords=b.m_coords;
  m_points.clear(); for(uint i=0;i<b.m_points.size();i++){m_points.push_back(b.m_points[i]);}
  m_has_stoich_coords=b.m_has_stoich_coords;
  m_has_artificial_unary=b.m_has_artificial_unary;
  m_is_on_hull=b.m_is_on_hull;
  m_hull_member=b.m_hull_member;
  m_ref_state=b.m_ref_state;
  m_hull_points.clear(); for(uint i=0;i<b.m_hull_points.size();i++){m_hull_points.push_back(b.m_hull_points[i]);}
  m_i_nary=b.m_i_nary;
  m_i_alloy=b.m_i_alloy;
  m_nearest_facet=b.m_nearest_facet;
  m_nearest_distance=b.m_nearest_distance;
  m_decomp_phases.clear(); for(uint i=0;i<b.m_decomp_phases.size();i++){m_decomp_phases.push_back(b.m_decomp_phases[i]);}
  m_decomp_coefs=b.m_decomp_coefs;
  for(uint i=0;i<m_equilibrium_phases.size();i++){m_equilibrium_phases.clear();} m_equilibrium_phases.clear(); for(uint i=0;i<b.m_equilibrium_phases.size();i++){m_equilibrium_phases.push_back(b.m_equilibrium_phases[i]);}
  m_equivalent_g_states.clear(); for(uint i=0;i<b.m_equivalent_g_states.size();i++){m_equivalent_g_states.push_back(b.m_equivalent_g_states[i]);}
}

void CoordGroup::initialize(const xvector<double>& coord,bool has_stoich_coords) {
  free();
  m_coords=coord;
  m_has_stoich_coords=has_stoich_coords;
  m_has_artificial_unary=false;
  m_initialized=true;
}

xvector<int> CoordGroup::getElementsPresent() const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  //quick checks
  string soliloquy="CoordGroup::getElementsPresent():";
  if(!m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  for(uint i=0;i<(uint)m_coords.rows;i++){
    if(std::signbit(m_coords[i]) || m_coords[i]>1.0){throw CHullLogicError(soliloquy,"Coord("+aurostd::utype2string(i)+") is outside of [0,1] range of a generalized stoichiometry coordinate");}
  }
  double hid_dim=1.0-sum(m_coords);
  if(LDEBUG){cerr << soliloquy << " hid_dim=" << hid_dim << endl;}
  if(std::signbit(hid_dim) || hid_dim>1.0) {throw CHullLogicError(soliloquy,"Coord("+aurostd::utype2string(m_coords.rows)+") is outside of [0,1] range of a generalized stoichiometry coordinate");}

  xvector<int> elements_present(m_coords.rows,0);
  for(uint i=0;i<(uint)m_coords.rows;i++){if(m_coords[i]>=ZERO_TOL){elements_present[i]=1;}}
  if(hid_dim>=ZERO_TOL){elements_present[m_coords.rows]=1;}

  if(LDEBUG){cerr << soliloquy << " elements_present=" << elements_present << endl;}
  return elements_present;
}

uint CoordGroup::getDim() const {
  if(!m_initialized){
    string soliloquy="CoordGroup::getDim():";
    throw CHullLogicError(soliloquy,"Uninitialized coordgroup");
  }
  return sum(getElementsPresent());
}

} // namespace chull

namespace chull {
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
Alloy::Alloy() {free();}
Alloy::Alloy(const xvector<int>& elements_present) {initialize(elements_present);}
Alloy::Alloy(const Alloy& b) {copy(b);}
Alloy::~Alloy() {free();}

const Alloy& Alloy::operator=(const Alloy& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

bool Alloy::operator<(const Alloy& other) const {
  // safety, so it doesn't break, but it's outside scope of function
  string soliloquy="Alloy::operator<():";
  if(m_elements_present.rows!=other.m_elements_present.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between alloys");} //{return (m_elements_present.rows<other.m_elements_present.rows);}
  for(uint i=0;i<(uint)m_elements_present.rows;i++) {
    if(m_elements_present[i]!=other.m_elements_present[i]) {return (m_elements_present[i]<other.m_elements_present[i]);}
  }
  return false;
}

void Alloy::clear() {Alloy a; copy(a);} //clear PUBLIC
void Alloy::free() { 
  m_initialized=false;
  m_elements_present.clear();
  m_dim=AUROSTD_MAX_UINT;
  m_coord_groups.clear();
  m_facets.clear();
}

void Alloy::copy(const Alloy& b) {
  m_initialized=b.m_initialized;
  m_elements_present=b.m_elements_present;
  m_dim=b.m_dim;
  m_coord_groups.clear(); for(uint i=0;i<b.m_coord_groups.size();i++){m_coord_groups.push_back(b.m_coord_groups[i]);}
  m_facets.clear(); for(uint i=0;i<b.m_facets.size();i++){m_facets.push_back(b.m_facets[i]);}
}

void Alloy::initialize(const xvector<int>& elements_present){
  free();
  m_elements_present=elements_present;
  m_dim=sum(elements_present);
  m_initialized=true;
}
}

namespace chull { 
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
Nary::Nary() {free();}
Nary::Nary(uint dim) {initialize(dim);}
Nary::Nary(const Nary& b) {copy(b);}
Nary::~Nary() {free();}

const Nary& Nary::operator=(const Nary& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

bool Nary::operator<(const Nary& other) const {return (nary<other.nary);}

void Nary::clear() {Nary a; copy(a);}
void Nary::free() {
  m_initialized=false;
  nary=AUROSTD_MAX_UINT;
  m_alloys.clear();
}

void Nary::copy(const Nary& b) {
  m_initialized=b.m_initialized;
  nary=b.nary;
  m_alloys.clear(); for(uint i=0;i<b.m_alloys.size();i++){m_alloys.push_back(b.m_alloys[i]);}
}

void Nary::initialize(uint dim) {
  free();
  nary=dim;
  m_initialized=true;
}
} // namespace chull

namespace chull {
//--------------------------------------------------------------------------------
// class ConvexHull
//--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// constructor
//------------------------------------------------------------------------------
ConvexHull::ConvexHull(ostream& oss) : p_FileMESSAGE(NULL) {initialize(oss);}
ConvexHull::ConvexHull(string alloy,ostream& oss) : p_FileMESSAGE(NULL) {initialize(alloy,oss);}
ConvexHull::ConvexHull(const vector<string>& velements,ostream& oss) : p_FileMESSAGE(NULL) {initialize(velements,oss);}
ConvexHull::ConvexHull(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) : p_FileMESSAGE(NULL) {initialize(velements,entries,oss);}
ConvexHull::ConvexHull(const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vcoords,oss,has_stoich_coords,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpoints,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpoints,velements,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(FileMESSAGE,oss);}
ConvexHull::ConvexHull(string alloy,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(alloy,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(velements,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(velements,entries,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vcoords,FileMESSAGE,oss,has_stoich_coords,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpoints,FileMESSAGE,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpoints,velements,FileMESSAGE,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,string alloy,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,alloy,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,velements,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,velements,entries,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpflow,vcoords,oss,has_stoich_coords,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpflow,vpoints,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpflow,vpoints,velements,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,string alloy,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,alloy,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,velements,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) : p_FileMESSAGE(NULL) {initialize(vpflow,velements,entries,FileMESSAGE,oss);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpflow,vcoords,FileMESSAGE,oss,has_stoich_coords,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpflow,vpoints,FileMESSAGE,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) : p_FileMESSAGE(NULL) {initialize(vpflow,vpoints,velements,FileMESSAGE,oss,half_hull,add_artificial_unaries);}
ConvexHull::ConvexHull(const ConvexHull& b) {copy(b);}

ConvexHull::~ConvexHull() {
  free();
  if(new_ofstream){delete p_FileMESSAGE;}
}

const ConvexHull& ConvexHull::operator=(const ConvexHull& other) {
  if(this!=&other) {free();copy(other);}
  return *this;
}

void ConvexHull::clear() {ConvexHull a; copy(a);}  //clear PRIVATE
void ConvexHull::free() {
  m_initialized=false;
  m_velements.clear();
  m_points.clear();
  m_naries.clear();
  m_coord_groups.clear();
  m_dim=AUROSTD_MAX_UINT;
  m_half_hull=false;
  m_lower_hull=false;
  m_has_stoich_coords=false;
  m_add_artificial_unaries=false;
  m_thermo_hull=false;
  m_formation_energy_hull=false;
  m_facets.clear();
  m_i_facets.clear();
  m_sort_energy_ascending=true;
  m_cflags.clear();
  p_oss=NULL;
  p_FileMESSAGE=NULL;
  new_ofstream=false;
  cleanHull();
}

void ConvexHull::copy(const ConvexHull& b) {  //copy PRIVATE
  m_initialized=b.m_initialized;
  m_velements.clear(); for(uint i=0;i<b.m_velements.size();i++){m_velements.push_back(b.m_velements[i]);}
  m_points.clear(); for(uint i=0;i<b.m_points.size();i++){m_points.push_back(b.m_points[i]);}
  m_naries.clear(); for(uint i=0;i<b.m_naries.size();i++){m_naries.push_back(b.m_naries[i]);}
  m_coord_groups.clear(); for(uint i=0;i<b.m_coord_groups.size();i++){m_coord_groups.push_back(b.m_coord_groups[i]);}
  m_dim=b.m_dim;
  m_half_hull=b.m_half_hull;
  m_lower_hull=b.m_lower_hull;
  m_has_stoich_coords=b.m_has_stoich_coords;
  m_add_artificial_unaries=b.m_add_artificial_unaries;
  m_thermo_hull=b.m_thermo_hull;
  m_formation_energy_hull=b.m_formation_energy_hull;
  m_facets.clear(); for(uint i=0;i<b.m_facets.size();i++){m_facets.push_back(b.m_facets[i]);}
  m_i_facets.clear(); for(uint i=0;i<b.m_i_facets.size();i++){m_i_facets.push_back(b.m_i_facets[i]);}
  m_sort_energy_ascending=b.m_sort_energy_ascending;
  m_cflags=b.m_cflags;
  p_oss=b.p_oss;
  new_ofstream=b.new_ofstream;  //very important! seg faults otherwise
  p_FileMESSAGE=b.p_FileMESSAGE;
  h_dim=b.h_dim;
  m_elements_present=b.m_elements_present;
  h_points.clear(); for(uint i=0;i<b.h_points.size();i++){h_points.push_back(b.h_points[i]);}
  h_centroid=b.h_centroid;
  h_reference=b.h_reference;
  h_facets.clear(); for(uint i=0;i<b.h_facets.size();i++){h_facets.push_back(b.h_facets[i]);}
  h_visible_facets.clear(); for(uint i=0;i<b.h_visible_facets.size();i++){h_visible_facets.push_back(b.h_visible_facets[i]);}
  h_horizon_ridges.clear(); for(uint i=0;i<b.h_horizon_ridges.size();i++){h_horizon_ridges.push_back(b.h_horizon_ridges[i]);}
}

bool ConvexHull::initialize(ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(string alloy,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(alloy,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const vector<string>& velements,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(velements,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(velements,entries,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vcoords,*_p_FileMESSAGE,oss,has_stoich_coords,half_hull,add_artificial_unaries);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpoints,*_p_FileMESSAGE,oss,half_hull,add_artificial_unaries);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpoints,velements,*_p_FileMESSAGE,oss,half_hull,add_artificial_unaries);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  m_initialized=false;  //no points
  return m_initialized;
}

bool ConvexHull::initialize(string alloy,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  return createHull(alloy);
}

bool ConvexHull::initialize(const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  return createHull(velements);
}

bool ConvexHull::initialize(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  return createHull(velements,entries);
}

bool ConvexHull::initialize(const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  return createHull(vcoords,has_stoich_coords,half_hull,add_artificial_unaries);
}

bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  return createHull(vpoints,half_hull,add_artificial_unaries);
}

bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setDefaultCFlags();
  return createHull(vpoints,velements,half_hull,add_artificial_unaries);
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,string alloy,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,alloy,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,velements,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,velements,entries,*_p_FileMESSAGE,oss);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,vcoords,*_p_FileMESSAGE,oss,has_stoich_coords,half_hull,add_artificial_unaries);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,vpoints,*_p_FileMESSAGE,oss,half_hull,add_artificial_unaries);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  ofstream* _p_FileMESSAGE=new ofstream();
  initialize(vpflow,vpoints,velements,*_p_FileMESSAGE,oss,half_hull,add_artificial_unaries);
  new_ofstream=true;  //override
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  m_initialized=false;  //no points
  return m_initialized;
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,string alloy,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  return createHull(alloy);
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  return createHull(velements);
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  return createHull(velements,entries);
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  return createHull(vcoords,has_stoich_coords,half_hull,add_artificial_unaries);
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  return createHull(vpoints,half_hull,add_artificial_unaries);
}

bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool half_hull,bool add_artificial_unaries) {
  free();
  setOFStream(FileMESSAGE); new_ofstream=false;
  setOSS(oss);
  setCFlags(vpflow);
  return createHull(vpoints,velements,half_hull,add_artificial_unaries);
}

void ConvexHull::initializePoints(string alloy){
  loadPoints(alloy);
  structurePoints();
}

void ConvexHull::initializePoints(const vector<string>& velements){
  loadPoints(velements);
  structurePoints();
}

void ConvexHull::initializePoints(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries){
  loadPoints(velements,entries);
  structurePoints();
}

void ConvexHull::initializePoints(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries){
  loadPoints(vcoords,has_stoich_coords,half_hull,add_artificial_unaries);
  structurePoints();
}

void ConvexHull::initializePoints(const vector<ChullPoint>& vpoints,bool half_hull,bool add_artificial_unaries){
  loadPoints(vpoints,half_hull,add_artificial_unaries);
  structurePoints();
}

void ConvexHull::initializePoints(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool half_hull,bool add_artificial_unaries){
  loadPoints(vpoints,velements,half_hull,add_artificial_unaries);
  structurePoints();
}

uint ConvexHull::getDim() const {return m_dim;}
uint ConvexHull::getEntriesCount() const {
  uint i_point,count=0;
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      if(!m_points[i_point].m_is_artificial){count++;}
    }
  }
  return count;
}

vector<uint> ConvexHull::getHullPoints(bool sort_stoich_ascending) const { //pure hull-members, not equivalent ones too
  vector<uint> hull_points;
  uint i_point;
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      if(m_points[i_point].m_is_on_hull){hull_points.push_back(i_point);}
    }
  }
  std::sort(hull_points.begin(),hull_points.end(),sortCHullPoints(m_points,sort_stoich_ascending,true));
  return hull_points;
}

uint ConvexHull::getUnaryGState(uint i_alloy) const {
  string soliloquy="ConvexHull::getUnaryGStates():";
  uint i_nary=0;
  if(i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within alloys");}
  uint g_state=AUROSTD_MAX_UINT;
  if(m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size()!=1){throw CHullLogicError(soliloquy,"Unexpected count of coordgroups for unaries, should only be 1");}
  uint i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[0];
  uint i_point;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
    i_point=m_coord_groups[i_coord_group].m_points[i];
    if(m_points[i_point].m_is_g_state){
      g_state=i_point;
      return g_state;
    }
  }
  return g_state;
}

bool ConvexHull::isViablePoint(uint i_point) const {return i_point<m_points.size();}
bool ConvexHull::isViableGState(uint g_state) const {return g_state<m_points.size() && m_points[g_state].m_has_entry;}

bool ConvexHull::findPoint(const string& auid,uint& i_point) const{
  for(uint i=0;i<m_points.size();i++){
    if(!m_points[i].m_has_entry){continue;}
    if(m_points[i].m_entry.auid==auid){i_point=i;return true;}
  }
  return false;
}

bool ConvexHull::findPoint(const xvector<double>& coords,uint& i_point) const{
  for(uint i=0;i<m_points.size();i++){if(aurostd::identical(m_points[i].m_coords,coords,ZERO_TOL)){i_point=i;return true;}}
  return false;
}

bool ConvexHull::getNariesIndex(uint i_point,uint& i_nary,uint& i_alloy,uint& i_coord_group,bool redo) const{
  string soliloquy="ConvexHull::getNariesIndex():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  return getNariesIndex(m_points[i_point],i_nary,i_alloy,i_coord_group,redo);
}

bool ConvexHull::getNariesIndex(const ChullPoint& point,uint& i_nary,uint& i_alloy,uint& i_coord_group,bool redo) const{
  string soliloquy="ConvexHull::getNariesIndex():";
  if(!point.m_has_stoich_coords){throw CHullLogicError(soliloquy,"Point does not have stoich coordinates");}
  return (getAlloyIndex(point,i_nary,i_alloy,redo) && getCoordGroupIndex(point,i_coord_group,redo));
}

bool ConvexHull::getCoordGroupIndex(uint i_point,uint& i_coord_group,bool redo) const {
  string soliloquy="ConvexHull::getCoordGroupIndex():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  return getCoordGroupIndex(m_points[i_point],i_coord_group,redo);
}

bool ConvexHull::getCoordGroupIndex(const ChullPoint& point,uint& i_coord_group,bool redo) const {
  string soliloquy="ConvexHull::getCoordGroupIndex():";
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized chullpoint");}
  if(!redo){
    i_coord_group=point.m_i_coord_group;
    if(i_coord_group<m_coord_groups.size()){return true;}
  }
  return getCoordGroupIndex(point.getTruncatedGenCoords(),i_coord_group);
}

bool ConvexHull::getCoordGroupIndex(const xvector<double>& r_coords,uint& i_coord_group) const {
  string soliloquy="ConvexHull::getCoordGroupIndex():";
  for(uint i=0;i<m_coord_groups.size();i++){
    if(!m_coord_groups[i].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
    if(identical(m_coord_groups[i].m_coords,r_coords,ZERO_TOL)){
      i_coord_group=i;
      return true;
    }
  }
  return false;
}

bool ConvexHull::getAlloyIndex(const ChullPoint& point,uint& i_nary,uint& i_alloy,bool redo) const {
  string soliloquy="ConvexHull::getAlloyIndex():";
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized chullpoint");}
  if(!point.m_has_stoich_coords){throw CHullLogicError(soliloquy,"Point does not have stoich coordinates");}
  if(!redo){
    i_nary=point.m_i_nary;
    i_alloy=point.m_i_alloy;
    if(i_nary<m_naries.size() && i_alloy<m_naries[i_nary].m_alloys.size()){return true;}
  }
  return getAlloyIndex(point.m_elements_present,i_nary,i_alloy);
}

bool ConvexHull::getAlloyIndex(const CoordGroup& cg,uint& i_nary,uint& i_alloy,bool redo) const {
  string soliloquy="ConvexHull::getAlloyIndex():";
  if(!cg.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  if(!cg.m_has_stoich_coords){throw CHullLogicError(soliloquy,"Coordgroup does not have stoich coordinates");}
  if(!cg.m_points.size()){throw CHullLogicError(soliloquy,"Coordgroup has no points");}
  if(!redo){
    i_nary=cg.m_i_nary;
    i_alloy=cg.m_i_alloy;
    if(i_nary<m_naries.size() && i_alloy<m_naries[i_nary].m_alloys.size()){return true;}
  }
  return getAlloyIndex(cg.getElementsPresent(),i_nary,i_alloy);
}

bool ConvexHull::getAlloyIndex(const xvector<int>& elements_present,uint& i_nary,uint& i_alloy) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getAlloyIndex():";
  i_nary=sum(elements_present)-1;
  if(i_nary>m_naries.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(LDEBUG){cerr << soliloquy << " elements_present=" << elements_present << endl;}
  for(uint i=0;i<m_naries[i_nary].m_alloys.size();i++){
    if(!m_naries[i_nary].m_alloys[i].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
    if(m_naries[i_nary].m_alloys[i].m_elements_present==elements_present){
      i_alloy=i;
      return true;
    }
  }
  return false;
}

uint ConvexHull::artificialMap(uint i_point) const{
  string soliloquy="ConvexHull::artificialMap():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_points");}
  if(!m_points[i_point].m_is_artificial){return i_point;}
  //we found an artificial point, but was it supposed to be here?
  if(!m_add_artificial_unaries){throw CHullLogicError(soliloquy,"Invalid artificial point, not sure how to handle mapping");}
  
  const ChullPoint& art_point=m_points[i_point];
  uint i_coord_group;
  if(!getCoordGroupIndex(art_point,i_coord_group)){throw CHullLogicError(soliloquy,"Coordgroup index not set");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  if(m_coord_groups[i_coord_group].m_points.size()==0){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}

  uint i_point_new;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
    i_point_new=m_coord_groups[i_coord_group].m_points[i];
    if(!m_points[i_point_new].m_is_artificial){return i_point_new;}
  }

  //if we get here, there are no viable replacements, simply return artificial point
  if(m_coord_groups[i_coord_group].m_points.size()==1){if(m_coord_groups[i_coord_group].m_points[0]==i_point){return i_point;}}

  //really bad if we get here
  throw CHullLogicError(soliloquy,"Cannot determine artificial point mapping");
}

bool ConvexHull::write(char mode) const {
  bool written=false;
  try{
    if(mode==_apool_){writeAPool();written=true;}
    else if(mode==_json_){writeText(mode);written=true;}
    else if(mode==_pdf_){writePDF();written=true;}
    else if(mode==_txt_){writeText(mode);written=true;}
    else if(mode==_web_){writeWebApp();written=true;}
  }
  catch(CHullRuntimeError& re){pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
  catch(CHullLogicError& le){pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
  return written;
}

void ConvexHull::setDefaultCFlags() {pflow::defaultLoadEntriesFlags(m_cflags, *p_FileMESSAGE, *p_oss, std::string("A"), false, true);}
void ConvexHull::setCFlags(const aurostd::xoption& vpflow) {m_cflags=vpflow;}
void ConvexHull::setOFStream(ofstream& FileMESSAGE){p_FileMESSAGE=&FileMESSAGE;}
void ConvexHull::setOSS(ostream& oss) {p_oss=&oss;}

bool ConvexHull::createHull(string alloy) {
  try{
    initializePoints(alloy);
    checkStructurePoints(); //some nice checks that everything checks out
    calculate();
    m_initialized=true;
  }
  catch(CHullRuntimeError& re){
    pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  catch(CHullLogicError& le){
    pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  return m_initialized;
}

bool ConvexHull::createHull(const vector<string>& velements) {
  try{
    initializePoints(velements);
    checkStructurePoints(); //some nice checks that everything checks out
    calculate();
    m_initialized=true;
  }
  catch(CHullRuntimeError& re){
    pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  catch(CHullLogicError& le){
    pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  return m_initialized;
}

bool ConvexHull::createHull(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries) {
  try{
    initializePoints(velements,entries);
    checkStructurePoints(); //some nice checks that everything checks out
    calculate();
    m_initialized=true;
  }
  catch(CHullRuntimeError& re){
    pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  catch(CHullLogicError& le){
    pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  return m_initialized;
}

bool ConvexHull::createHull(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) {
  try{
    initializePoints(vcoords,has_stoich_coords,half_hull,add_artificial_unaries);
    checkStructurePoints(); //some nice checks that everything checks out
    calculate();
    m_initialized=true;
  }
  catch(CHullRuntimeError& re){
    pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  catch(CHullLogicError& le){
    pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  return m_initialized;
}

bool ConvexHull::createHull(const vector<ChullPoint>& vpoints,bool half_hull,bool add_artificial_unaries) {
  try{
    initializePoints(vpoints,half_hull,add_artificial_unaries);
    checkStructurePoints(); //some nice checks that everything checks out
    calculate();
    m_initialized=true;
  }
  catch(CHullRuntimeError& re){
    pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  catch(CHullLogicError& le){
    pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  return m_initialized;
}

bool ConvexHull::createHull(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool half_hull,bool add_artificial_unaries) {
  try{
    initializePoints(vpoints,velements,half_hull,add_artificial_unaries);
    checkStructurePoints(); //some nice checks that everything checks out
    calculate();
    m_initialized=true;
  }
  catch(CHullRuntimeError& re){
    pflow::logger(re.where(), re.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  catch(CHullLogicError& le){
    pflow::logger(le.where(), le.what(), *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
    clear();
  }
  return m_initialized;
}

bool ConvexHull::entryValid(const aflowlib::_aflowlib_entry& entry) const {
  string reason;
  return entryValid(entry,reason);
}

bool ConvexHull::entryValid(const aflowlib::_aflowlib_entry& entry,string& reason) const {
  char LOGGER_TYPE=_LOGGER_OPTION_;
  return entryValid(entry,reason,LOGGER_TYPE);
}

bool ConvexHull::entryValid(const aflowlib::_aflowlib_entry& entry,string& reason,char& LOGGER_TYPE) const {
  string soliloquy="ConvexHull::entryValid():";
  reason="";
  LOGGER_TYPE=_LOGGER_OPTION_;
  //tests of stupidity
  if(entry.vspecies.size()!=entry.vcomposition.size()){
    //throw CHullRuntimeError(soliloquy,"Bad entry ("+entry.auid+") - vspecies.size!=vcomposition.size()"); //let's not break the code for one bad entry
    reason="Entry (auid="+entry.auid+") is ill-defined: vspecies.size()!=vcomposition.size()";
    reason+=" (please report on AFLOW Forum: aflow.org/forum)";
    LOGGER_TYPE=_LOGGER_WARNING_;
    return false;
  }
  bool found;
  for(uint j=0;j<entry.vspecies.size();j++){
    found=false;
    for(uint i=0;i<m_velements.size() && !found;i++){if(m_velements[i]==entry.vspecies[j]){found=true;}}
    if(!found){
      reason="Entry (auid="+entry.auid+") contains "+entry.vspecies[j]+" and does not belong to hull";
      reason+=" (please report on AFLOW Forum: aflow.org/forum)";
      LOGGER_TYPE=_LOGGER_WARNING_;
      return false;
    }
  }
  if(!entry.ldau_TLUJ.empty()){
    reason="calculated with +U parameters";
    return false;
  }
  if(entry.enthalpy_formation_atom==AUROSTD_NAN || entry.entropic_temperature==AUROSTD_NAN){
    reason="enthalpy_formation_atom/entropic_temperature not calculated";
    return false;
  }
  if(IGNORE_BAD_DATABASE && entry.ignoreBadDatabase(reason)){return false;}
  //otherwise return true
  return true;
}

void ConvexHull::addArtificialUnaries(uint dim){
  //points are really dim+1 dimensional (hidden dimension)
  //really, dim specifies within s_coords unless dim == s_coords.size()
  //then it's the last coord
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::addArtificialUnaries():";
  if(dim>m_dim-1){throw CHullLogicError(soliloquy,"Invalid dimension requested");}
  xvector<double> dummy(m_dim-1,0);
  if(dim!=m_dim-1){dummy[dim]=1;}
  m_points.push_back(ChullPoint(dummy,*p_FileMESSAGE,true,true,*p_oss));
  if(LDEBUG){cerr << soliloquy << " new artificial point=" << m_points.back().m_coords << endl;}
}

void ConvexHull::addArtificialUnaries(){for(uint i=0;i<m_dim;i++){addArtificialUnaries(i);}}

bool ConvexHull::entryUnique(const vector<uint>& unique_entries,const aflowlib::_aflowlib_entry& entry,string& canonical_auid) const {
  //points have already been created, determined to be unique
  //hack, go backwards, as the way entries are ordered, duplicates occur near each other
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  canonical_auid="";
  string soliloquy="ConvexHull::entryUnique():";
  for(uint i=unique_entries.size()-1;i<unique_entries.size();i--){
    const ChullPoint& point=m_points[unique_entries[i]];
    if(point.entryIdentical(entry)){
      if(LDEBUG){
        cerr << soliloquy << " entry[auid=" << point.m_entry.auid << ",compound=" << point.m_entry.compound << ",prototype=" << point.m_entry.prototype << "] == ";
        cerr << "entry[auid=" << entry.auid << ",compound=" << entry.compound << ",prototype=" << entry.prototype << "]" << endl;
      }
      canonical_auid=point.m_entry.auid;
      return false;
    }
  }
  return true;
}

void ConvexHull::loadPoints(string alloy) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::loadPoints():";
  if(LDEBUG){cerr << soliloquy << " initializing alloy, compound=" << alloy << endl;}
  vector<string> velements = pflow::makeAlphabeticVector(alloy, *p_FileMESSAGE, *p_oss);
  return loadPoints(velements);
}

void ConvexHull::loadPoints(const vector<string>& _velements) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::loadPoints():";
  
  vector<string> velements; 
  for(uint i=0;i<_velements.size();i++){velements.push_back(_velements[i]);}
  std::sort(velements.begin(),velements.end()); //safe
  
  if(LDEBUG){cerr << soliloquy << " initializing velements, velements=" << aurostd::joinWDelimiter(velements,",") << endl;}
  
  vector<vector<vector<aflowlib::_aflowlib_entry> > > entries;
  pflow::loadEntries(m_cflags,velements,entries,*p_FileMESSAGE,*p_oss);
  return loadPoints(velements,entries);
}

void ConvexHull::loadPoints(const vector<string>& _velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::loadPoints():";
  stringstream message;
  
  vector<string> velements;
  velements.clear(); for(uint i=0;i<_velements.size();i++){velements.push_back(_velements[i]);}
  std::sort(velements.begin(),velements.end()); //safe
  
  if(LDEBUG){cerr << soliloquy << " initializing velements WITH entries, velements=" << aurostd::joinWDelimiter(velements,",") << endl;}
  
  m_formation_energy_hull=!m_cflags.flag("CHULL::ENTROPIC_TEMPERATURE");    //energy vs. entropic_temperature hull
  m_lower_hull=m_formation_energy_hull; //energy/entropic_temperature lower/upper hull
  m_has_stoich_coords=true;
  m_half_hull=true;
  m_add_artificial_unaries=true;
  
  vector<ChullPoint> points;
  ChullPoint cp;
  
  for(uint i=0;i<entries.size();i++){
    for(uint j=0;j<entries[i].size();j++){
      for(uint k=0;k<entries[i][j].size();k++){
        cp.initialize(velements,entries[i][j][k],*p_FileMESSAGE,m_formation_energy_hull,*p_oss);
        points.push_back(cp);
      }
    }
  }
  if(!points.size()){throw CHullRuntimeError(soliloquy,"No entries loaded");}
  return loadPoints(points,velements,m_half_hull,m_add_artificial_unaries);
}

void ConvexHull::loadPoints(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool half_hull,bool add_artificial_unaries) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::loadPoints():";
  vector<ChullPoint> points;
  if(LDEBUG){cerr << soliloquy << " initializing vcoords (has_stoich_coords==" << has_stoich_coords << "), count=" << vcoords.size() << endl;}
  ChullPoint cp;
  for(uint i=0;i<vcoords.size();i++){
    cp.initialize(vcoords[i],has_stoich_coords);
    points.push_back(cp);
  }
  return loadPoints(points,half_hull,add_artificial_unaries);
}

void ConvexHull::loadPoints(const vector<ChullPoint>& vpoints,bool half_hull,bool add_artificial_unaries) {
  vector<string> velements;
  return loadPoints(vpoints,velements,half_hull,add_artificial_unaries);
}

void ConvexHull::loadPoints(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool half_hull,bool add_artificial_unaries) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::loadPoints():";
  stringstream message;

  if(velements.size()){
    m_velements.clear(); for(uint i=0;i<velements.size();i++){m_velements.push_back(velements[i]);}
    std::sort(m_velements.begin(),m_velements.end()); //safe
  }
  
  if(LDEBUG){cerr << soliloquy << " initializing chullpoints, count=" << vpoints.size() << endl;}
  for(uint i=0;i<vpoints.size();i++){m_points.push_back(vpoints[i]);};
  if(!m_points.size()){throw CHullLogicError(soliloquy,"No points loaded, no way to determine dimensionality of hull");}
  
  //flag defaults
  m_formation_energy_hull=!m_cflags.flag("CHULL::ENTROPIC_TEMPERATURE");    //energy vs. entropic_temperature hull
  m_lower_hull=m_formation_energy_hull; //energy/entropic_temperature lower/upper hull
  m_half_hull=(m_half_hull || half_hull);
  m_add_artificial_unaries=(m_add_artificial_unaries || add_artificial_unaries);
  
  //detect for coord types mixture!
  m_has_stoich_coords=( m_points[0].m_has_stoich_coords || m_has_stoich_coords );
  m_dim=m_points[0].m_coords.rows;
  if(m_dim<2){throw CHullLogicError(soliloquy,"1D hulls are trivial");}
  //test of stupidity
  for(uint i=0;i<m_points.size();i++){
    if(!m_points[i].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
    if(m_points[i].getDim()!=m_dim){throw CHullLogicError(soliloquy,"Dimension mismatch among points");}
    if(m_points[i].m_has_stoich_coords!=m_has_stoich_coords){
      message << "Mismatch among coord types (stoich vs. non-stoich coords), assuming non-stoich coords";
      pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      m_has_stoich_coords=false;
      break;
    }
  }
  
  if(m_half_hull && m_has_stoich_coords && m_add_artificial_unaries){m_thermo_hull=true;}
  if(LDEBUG){
    cerr << soliloquy << " thermo_hull=" << m_thermo_hull << endl;
    cerr << soliloquy << " half_hull=" << m_half_hull << endl;
    cerr << soliloquy << " lower_hull=" << m_lower_hull << endl;
    cerr << soliloquy << " has_stoich_coords=" << m_has_stoich_coords << endl;
    cerr << soliloquy << " add_artificial_unaries=" << m_add_artificial_unaries << endl;
  }

  //ensures proper construction of hull
  //duplicates DO NOT AFFECT performance/accuracy of algorithm
  //we ignore these points after hull construction anyway
  if(m_add_artificial_unaries){addArtificialUnaries();}
  
  //get s_coords
  if(m_has_stoich_coords){for(uint i=0;i<m_points.size();i++){m_points[i].setStoichCoords();}} //repetita iuvant

  //if(0){  //do NOT resort points, keep in same order as user input
  //  if(LDEBUG){cerr << soliloquy << " resorting all points (including artificial points) by coord/stoich (descending) and energy (ascending)" << endl;}
  //  std::sort(m_points.begin(),m_points.end());
  //}

  //DO NOT ADD/SUBTRACT/CHANGE-ORDER OF M_POINTS BEYOND THIS FUNCTION
}

vector<uint> ConvexHull::getOutliers() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  //it is very important that we do not define outliers using std/mean, as these are
  //very sensitive to outliers
  //instead, use median
  //see discussion here:  doi=10.1016/j.jesp.2013.03.013
  string soliloquy="ConvexHull::getOutliers():";
  vector<uint> outliers;
  
  bool force_outlier_test=false;  //override binary alloy statistics check
  bool keep_outliers=m_cflags.flag("CHULL::INCLUDE_OUTLIERS");
  bool show_warnings=true;
  bool iqr_method=true; //unfortunately, MAD is normal distribution dependent, NOT our case here
  
  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  
  //get vector of last coords (we want to find outliers in this dimension)
  vector<double> _energies;  //vector and not xvector because we need push_back()
  uint i_point;
  if(m_half_hull){  //we only care about points above/below hull
    if(m_lower_hull){
      for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
        if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
        for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(std::signbit(m_points[i_point].getLastCoord())){ //negative
            _energies.push_back(m_points[i_point].getLastCoord());
          }
        }
      }
    }else{
      for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
        if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
        for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!std::signbit(m_points[i_point].getLastCoord())){ //positive
            _energies.push_back(m_points[i_point].getLastCoord());
          }
        }
      }
    }
  }else{
    for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        _energies.push_back(m_points[i_point].getLastCoord());
      }
    }
  }
  //nice solution here! but only works for odd counts
  //http://en.cppreference.com/w/cpp/algorithm/nth_element
  //so we sort full anyway to be completely robust, should be easy considering how we sorted before
  if(_energies.size()<4){outliers.clear();return outliers;} //ALWAYS not enough points to do statistics (need 3 quartiles)
  if(!force_outlier_test && _energies.size()<BINARY_ENTRIES_THRESHOLD){outliers.clear();return outliers;} //not enough points to do statistics (not at high-throughput)
  xvector<double> energies=aurostd::vector2xvector<double>(_energies);
  if(LDEBUG){cerr << "lastCoords(): " << energies << endl;}
  double q1,q2,q3;
  aurostd::getQuartiles(energies,q1,q2,q3);  //we sort in here

  double lower_anchor,upper_anchor,range,multiplier;
  if(iqr_method){  //classical iqr measure of outlier
    lower_anchor=q1;
    upper_anchor=q3;
    range=q3-q1;      //interquartile range, iqr
    //multiplier=3.25;  //default=1.5, but we need to be more conservative from trials
  }else{  //absolute deviation around the median (MAD)
    lower_anchor=q2;
    upper_anchor=q2;
    range=aurostd::getMAD(energies,q2); //better iqr IF normal distribution, otherwise we need to know type of distribution (quartiles)
    //multiplier=3.25;                    //doi=10.1080/14640749108400962; 3 (very conservative), 2.5 (moderately conservative), 2 (poorly conservative)
  }
  multiplier=DEFAULT_CHULL_OUTLIER_MULTIPLIER;

  if(LDEBUG){
    cerr << soliloquy << " lower_anchor=" << lower_anchor << ", median=" << q2 << ", upper_anchor=" << upper_anchor << ", range=" << range << endl;
  }

  double threshold;
  stringstream message;
  char LOGGER_TYPE=_LOGGER_OPTION_;
  if(show_warnings){LOGGER_TYPE=_LOGGER_WARNING_;}  //show warning if we do not remove!
  if(!(m_half_hull && !m_lower_hull)){  //look at lower range
    threshold=lower_anchor-(multiplier*range);
    for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(m_points[i_point].getLastCoord()<threshold){
          outliers.push_back(i_point);
          message << "Found (lower) outlier auid=" << m_points[i_point].m_entry.auid << 
            ", lastCoord()=" << m_points[i_point].getLastCoord() << 
            " (<threshold=" << threshold << ")"; 
          pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, LOGGER_TYPE);
        }
      }
    }
  }
  if(!(m_half_hull && m_lower_hull)){  //look at upper range
    threshold=upper_anchor+(multiplier*range);
    for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(m_points[i_point].getLastCoord()>threshold){
          outliers.push_back(i_point);
          message << "Found (upper) outlier auid=" << m_points[i_point].m_entry.auid << 
            ", lastCoord()=" << m_points[i_point].getLastCoord() << 
            " (>threshold=" << threshold << ")"; 
          pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, LOGGER_TYPE);
        }
      }
    }
  }
  if(keep_outliers){
    message << "NOT removing outliers";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
    outliers.clear();
  }
  ////remove outliers
  //std::sort(outliers.rbegin(),outliers.rend()); //descending
  //for(uint i=0;i<outliers.size();i++){
  //  message << "Removing outlier auid=" << m_points[outliers[i]].m_entry.auid;
  //  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
  //  m_points.erase(m_points.begin()+outliers[i]);
  //}
  if(LDEBUG){cerr << soliloquy << " done" << endl;}
  return outliers;
}

vector<uint> ConvexHull::findArtificialPoints(uint i_coord_group){
  string soliloquy="ConvexHull::findArtificialPoints():";
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  
  uint i_point;
  vector<uint> artificial_points;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
    i_point=m_coord_groups[i_coord_group].m_points[i];
    if(m_points[i_point].m_is_artificial){artificial_points.push_back(i_point);}
  }

  return artificial_points;
}

uint ConvexHull::findArtificialUnary(uint i_coord_group){
  string soliloquy="ConvexHull::findArtificialUnary():";
  if(!m_has_stoich_coords){throw CHullLogicError(soliloquy,"No unaries to be found (coordinates are not stoichiometric)");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  if(!m_coord_groups[i_coord_group].m_points.size()){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is empty");}
  if(!m_points[m_coord_groups[i_coord_group].m_points[0]].isUnary()){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is not unary");}

  vector<uint> artificial_points=findArtificialPoints(i_coord_group);
  if(artificial_points.size()==0){throw CHullLogicError(soliloquy,"Missing artificial points");}
  if(artificial_points.size()!=1){throw CHullLogicError(soliloquy,"Found too many artificial points: "+aurostd::utype2string(artificial_points.size()));}

  return artificial_points[0];
}

void ConvexHull::organizeHullPoints(uint i_coord_group) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::organizeHullPoints():";
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}

  if(LDEBUG){cerr << soliloquy << " finding min/max energy point(s) for coord_group[" << i_coord_group << "]" << endl;}

  m_coord_groups[i_coord_group].m_hull_points.clear();
  uint p_size=m_coord_groups[i_coord_group].m_points.size();
  if(p_size==0){throw CHullLogicError(soliloquy,"Coordgroup has no points");}
  
  //the sole purpose of an artificial point is to sit on the hull, ignore all others
  uint i_point;
  if(m_coord_groups[i_coord_group].m_has_artificial_unary){
    if(LDEBUG){cerr << soliloquy << " looking for artificial point in coord_group[" << i_coord_group << "]" << endl;}
    i_point=findArtificialUnary(i_coord_group);
    if(LDEBUG){
      cerr << soliloquy << " found artificial point in coord_group[" << i_coord_group << "]: ";
      cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
    }
    m_coord_groups[i_coord_group].m_hull_points.push_back(i_point);
    return;
  }
  
  if(m_half_hull){
    i_point=m_coord_groups[i_coord_group].m_points[0];        //lowest point for lower_hull, highest point for upper_hull
    if(m_lower_hull){
      if(std::signbit(m_points[i_point].getLastCoord())){
        m_coord_groups[i_coord_group].m_hull_points.push_back(i_point);
        if(LDEBUG){
          cerr << soliloquy << " lower half hull point found: ";
          cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
        }
      }
    }else{
      if(!std::signbit(m_points[i_point].getLastCoord())){
        m_coord_groups[i_coord_group].m_hull_points.push_back(i_point);
        if(LDEBUG){
          cerr << soliloquy << " upper half hull point found: ";
          cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
        }
      }
    }
    return; //below, we add other extreme in energy, which we don't care about for half hulls
  }
  
  i_point=m_coord_groups[i_coord_group].m_points[0];        //lowest energy point
  m_coord_groups[i_coord_group].m_hull_points.push_back(i_point);
  if(LDEBUG){
    cerr << soliloquy << " hull point found: ";
    cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
  }
  if(p_size>1){ //also grab other extreme
    i_point=m_coord_groups[i_coord_group].m_points[p_size-1];
    m_coord_groups[i_coord_group].m_hull_points.push_back(i_point);
    if(LDEBUG){
      cerr << soliloquy << " hull point found: ";
      cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
    }
  }
}

void ConvexHull::organizeHullPoints() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::organizeHullPoints():";
  if(!m_coord_groups.size()){throw CHullLogicError(soliloquy,"Points have not been structured correctly");}
  if(LDEBUG){
    cerr << soliloquy << " filtering points definitely NOT on the hull by energy" << endl;
    cerr << soliloquy << " only looking for min/max energy points in all coord_groups" << endl;
  }
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){organizeHullPoints(i_coord_group);}
}

void ConvexHull::initializeNaries() {
  //clear
  for(uint i_nary=0;i_nary<m_naries.size();i_nary++){
    for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
      m_naries[i_nary].m_alloys[i_alloy].clear();
    }
    m_naries[i_nary].clear();
  }
  m_naries.clear();

  //initialize with combinations of dim
  Nary nary;
  Alloy alloy;
  xvector<int> elements_present;
  aurostd::xcombos xc;
  for(uint i_nary=0;i_nary<m_dim;i_nary++){
    nary.initialize(i_nary+1);
    m_naries.push_back(nary);
    xc.reset(m_dim,i_nary+1);
    while(xc.increment()){
      elements_present=aurostd::vector2xvector<int>(xc.getCombo(),0);
      alloy.initialize(elements_present);
      m_naries[i_nary].m_alloys.push_back(alloy);
    }
  }
  //SORT NOW! do not sort later as we populate m_points with i_nary and i_alloy
  for(uint i_nary=0;i_nary<m_naries.size();i_nary++){
    std::sort(m_naries[i_nary].m_alloys.rbegin(),m_naries[i_nary].m_alloys.rend()); //descending order
  }
  std::sort(m_naries.begin(),m_naries.end());
}

void ConvexHull::structurePoints() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::structurePoints():";
  stringstream message;
  m_coord_groups.clear();
  m_naries.clear();

  if(LDEBUG){cerr << soliloquy << " starting" << endl;}

  //NOTE, m_points is UNTOUCHED (unsorted, fully populated) input, i.e., identical input of user
  //HOWEVER, m_coord_groups[].m_points only contain indices to points that we will consider for the hull calculation, i.e., does not contain
  //any points to be neglected (requested or otherwise)
  //if you want input of the user, use m_points
  //if you want points for the hull, go through m_coord_groups
  if(LDEBUG){cerr << soliloquy << " gathering points to neglect" << endl;}
  vector<uint> unique_entries;
  vector<string> points_neglect;
  if(m_cflags.flag("CHULL::NEGLECT")){aurostd::string2tokens(m_cflags.getattachedscheme("CHULL::NEGLECT"),points_neglect,",");}
  bool see_neglect=m_cflags.flag("CHULL::SEE_NEGLECT");
  bool remove_invalid=true;
  bool remove_duplicate_entries=true;        //we remove duplicate entries from the database, but in general, keep input of user constant
  bool remove_extreme=m_cflags.flag("CHULL::REMOVE_EXTREMA");
  double extrema_val;
  if(remove_extreme){
    extrema_val=aurostd::string2utype<double>(m_cflags.getattachedscheme("CHULL::REMOVE_EXTREMA"));
    if(m_formation_energy_hull){
      if(extrema_val>=ZERO_TOL){
        message << "Ignoring remove extreme points flag -- you provided a number >= 0. Hform convex hull sits below 0";
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        remove_extreme=false;
      }
    }else{
      if(extrema_val<=-ZERO_TOL){
        message << "Ignoring remove extreme points flag -- you provided a number <= 0. Ts convex hull sits above 0";
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        remove_extreme=false;
      }
    }
  }
  string invalid_reason,canonical_auid;
  char LOGGER_TYPE;
  bool silent;

  //organize into coordgroups
  if(LDEBUG){cerr << soliloquy << " organizing into coordgroups" << endl;}
  uint i_coord_group;
  CoordGroup cg;
  xvector<double> r_coords;
  for(uint i=0;i<m_points.size();i++){
    const ChullPoint& point=m_points[i];
    const aflowlib::_aflowlib_entry& entry=m_points[i].m_entry;
    if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
    //// start remove points
    if(remove_invalid && m_points[i].m_has_entry){
      if(!entryValid(entry,invalid_reason,LOGGER_TYPE)){
        if(!invalid_reason.empty()){
          silent=(!see_neglect && LOGGER_TYPE==_LOGGER_OPTION_);
          message << "Neglecting " << entry.auid << ": " << invalid_reason;
          pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, LOGGER_TYPE, silent);
        }
        continue;
      }
      if(remove_duplicate_entries && !entryUnique(unique_entries,entry,canonical_auid)){
        silent=(!see_neglect);
        message << "Neglecting " << entry.auid << ": duplicate database entry (see " << canonical_auid << ")";
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_, silent);
        continue;
      }
      unique_entries.push_back(i);
      if(aurostd::withinList(points_neglect,entry.auid)){
        message << "Neglecting " << entry.auid << ": as requested";
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
        continue;
      }
      if(remove_extreme){
        if(m_formation_energy_hull){
          if(chull::Hf_atom(entry, _m_) < extrema_val){
            message << "Neglecting " << entry.auid << ": flagged as extreme with Hform = " << chull::Hf_atom(entry, _m_) << " (meV/atom)";
            pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
            continue;
          }
        }else{
          if(chull::Ts(entry) > extrema_val){
            message << "Neglecting " << entry.auid << ": flagged as extreme with Ts = " << chull::Ts(entry) << " (K)";
            pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
            continue;
          }
        }
      }
    }
    //// end remove points
    //organize into m_naries
    r_coords=point.getTruncatedGenCoords();
    if(LDEBUG){cerr << soliloquy << " point[" << i << "]: m_coords=" << point.m_coords << ", r_coords=" << r_coords << ", compound= " << point.m_entry.compound << ", dim=" << point.m_i_nary+1 << endl;}
    if(!getCoordGroupIndex(r_coords,i_coord_group)){
      cg.initialize(r_coords,point.m_has_stoich_coords);
      m_coord_groups.push_back(cg);
      i_coord_group=m_coord_groups.size()-1;
    }
    m_coord_groups[i_coord_group].m_points.push_back(i);
    if(m_coord_groups[i_coord_group].m_has_stoich_coords && !point.m_has_stoich_coords){
      message << "Mismatch among coord types (stoich vs. non-stoich coords), assuming non-stoich coords";
      pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      m_coord_groups[i_coord_group].m_has_stoich_coords=false;
    }
    if(point.isUnary()&&point.m_is_artificial){m_coord_groups[i_coord_group].m_has_artificial_unary=true;}
  }
  
  //remove outliers before sort (BY MATCHING COORDS)
  uint i_point;
  vector<uint> outliers=getOutliers();
  bool found_outlier;
  vector<uint> points_to_remove;
  uint valid_count=0;
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    points_to_remove.clear();
    for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      found_outlier=false;
      for(uint j=0;j<outliers.size()&&!found_outlier;j++){if(i_point==outliers[j]){found_outlier=true;}}
      if(found_outlier){points_to_remove.push_back(i);} //not i_point, so I can remove this index
      else{valid_count++;}
    }
    if(points_to_remove.size()){
      std::sort(points_to_remove.rbegin(),points_to_remove.rend()); //descending
      if(LDEBUG){cerr << soliloquy << " before outlier removal, count = " << m_coord_groups[i_coord_group].m_points.size() << endl;}
      for(uint i=0;i<points_to_remove.size();i++){
        i_point=m_coord_groups[i_coord_group].m_points[points_to_remove[i]];
        message << "Remove outlier ";
        if(m_points[i_point].m_has_entry){message << "auid=" << m_points[i_point].m_entry.auid;}
        else{message << "m_coords=" << m_points[i_point].m_coords;}
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
        m_coord_groups[i_coord_group].m_points.erase(m_coord_groups[i_coord_group].m_points.begin()+points_to_remove[i]);
      }
      if(LDEBUG){cerr << soliloquy << " after outlier removal, count = " << m_coord_groups[i_coord_group].m_points.size() << endl;}
    }
  }
  if(LDEBUG){cerr << soliloquy << " found " << valid_count << " valid/relevant/unique points (may include artificial points in count)" << endl;}
  
  //remove empty m_coord_groups
  vector<uint> empty_coord_groups;
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    if(m_coord_groups[i_coord_group].m_points.size()==0){empty_coord_groups.push_back(i_coord_group);}
  }
  std::sort(empty_coord_groups.rbegin(),empty_coord_groups.rend()); //descending
  for(uint i=0;i<empty_coord_groups.size();i++){m_coord_groups.erase(m_coord_groups.begin()+empty_coord_groups[i]);}
  
  //sort
  m_sort_energy_ascending=!(m_half_hull==true && m_lower_hull==false); //upper half hull should sort DESCENDING (ground state first)
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    std::sort(m_coord_groups[i_coord_group].m_points.begin(),m_coord_groups[i_coord_group].m_points.end(),sortWithinCoordGroup(m_points,m_sort_energy_ascending));  //ascending order
  }
  std::sort(m_coord_groups.rbegin(),m_coord_groups.rend()); //descending order for alphabetic print out later
  
  //assign coord group indices to points, useful later
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    //set ref state
    if(m_coord_groups[i_coord_group].m_points.size()){
      m_coord_groups[i_coord_group].m_ref_state=artificialMap(m_coord_groups[i_coord_group].m_points[0]);
    }
    for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      m_points[i_point].m_i_coord_group=i_coord_group;
    }
  }
  if(LDEBUG){cerr << soliloquy << " done organizing into coordgroups" << endl;}
  
  organizeHullPoints();

  if(LDEBUG){
    cerr << soliloquy << " coord_groups structure:" << endl;
    for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
      cerr << soliloquy << " coord_group[" << i_coord_group << "] coords=" << m_coord_groups[i_coord_group].m_coords << endl;
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
        cerr << soliloquy << " point[" << i << "] compound=" << m_points[m_coord_groups[i_coord_group].m_points[i]].m_entry.compound << " ";
        cerr << "coords=" << m_points[m_coord_groups[i_coord_group].m_points[i]].m_coords << endl;
      }
    }
  }

  if(m_has_stoich_coords){
    if(LDEBUG){cerr << soliloquy << " stoich_coords found, also sorting into n-aries and alloys" << endl;}

    initializeNaries(); //create empty bins first, we can do this combinatorially

    uint i_nary,i_alloy;
    for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
      //we already filled bins, if we cannot find alloy system, then it's a bust
      if(!getAlloyIndex(m_coord_groups[i_coord_group],i_nary,i_alloy,true)){throw CHullLogicError(soliloquy,"Cannot get alloys index");}  //redo as we never done before
      m_coord_groups[i_coord_group].m_i_nary=i_nary;
      m_coord_groups[i_coord_group].m_i_alloy=i_alloy;
      m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.push_back(i_coord_group);
      //set i_nary and i_alloy to points too
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        m_points[i_point].m_i_nary=i_nary;
        m_points[i_point].m_i_alloy=i_alloy;
      }
    }
  
    if(LDEBUG){
      for(uint i_nary=0;i_nary<m_naries.size();i_nary++){
        cerr << soliloquy << " " << i_nary+1 << "-nary:" << endl;
        for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
          cerr << soliloquy << " alloy[" << i_alloy << "]: elements_present=" << m_naries[i_nary].m_alloys[i_alloy].m_elements_present << endl;
          for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i++){
            i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
            cerr << soliloquy << " coord_group[" << i_coord_group << "]=" << m_coord_groups[i_coord_group].m_coords << endl;
            for(uint j=0;j<m_coord_groups[i_coord_group].m_points.size();j++){
              cerr << soliloquy << " compound=";
              cerr << (m_points[m_coord_groups[i_coord_group].m_points[j]].m_is_artificial ? 
                  string("ARTIFICIAL") : 
                  m_points[m_coord_groups[i_coord_group].m_points[j]].m_entry.compound) << " ";
              cerr << "coords=" << m_points[m_coord_groups[i_coord_group].m_points[j]].m_coords << endl;
            }
          }
        }
      }
    }
  }
}

vector<string> ConvexHull::alloyToElements(const ChullPoint& point) const {return alloyToElements(point.m_i_nary,point.m_i_alloy);}
vector<string> ConvexHull::alloyToElements(uint i_nary,uint i_alloy) const {
  string soliloquy="ConvexHull::alloyToElements():";
  const xvector<int>& elements_present=getElementsPresent(i_nary,i_alloy);
  if((uint)elements_present.rows!=m_velements.size()){throw CHullLogicError(soliloquy,"Dimension mismatch between elements present and composition");}
  vector<string> vout;
  for(int i=elements_present.lrows;i<=elements_present.urows;i++){
    if(elements_present[i]==1){vout.push_back(m_velements[i]);}
  }
  return vout;
}

void ConvexHull::checkStructurePoints() {
  string soliloquy="ConvexHull::checkStructurePoints():";
  stringstream message;

  bool binary_statistics_check=true;

  if(m_has_stoich_coords){
    //UNARIES - START
    //tests of stupidity
    if(m_naries.size()!=m_dim){throw CHullLogicError(soliloquy,"Missing n-aries");} //these are populated by default if done correctly
    uint i_nary=0;
    if(m_naries[i_nary].m_alloys.size()!=m_dim){throw CHullLogicError(soliloquy,"Missing unary alloys");} //these are populated by default if done correctly

    //check for ground states (non-artificial points)
    bool found_real,found_artificial;
    uint i_coord_group,i_point,i_point_real;
    for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
      if(m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size()!=1){throw CHullLogicError(soliloquy,"Unexpected count of coordgroups for unaries, should only be 1");}
      found_real=found_artificial=false;
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[0];
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size()&&!(found_real&&found_artificial);i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(m_points[i_point].m_is_artificial){found_artificial=true;}
        else{
          if(!found_real){i_point_real=i_point;}  //grab first i_point that's real
          found_real=true;
        }
      }
      if(m_add_artificial_unaries&&!found_artificial){
        message << "Missing artificial points for ";
        if(i_alloy<m_velements.size()){message << m_velements[i_alloy];}
        else{message << " unary " << i_alloy+1;}
        throw CHullLogicError(soliloquy,message.str()); message.str("");
      }
      if(found_real){
        if(m_thermo_hull){
          if(abs(m_points[i_point_real].getLastCoord())>=ENERGY_TOL){
            message << "Very skewed ground-state end point for ";
            if(i_alloy<m_velements.size()){message << m_velements[i_alloy];}
            else{message << "unary " << i_alloy+1;}
            message << " (auid=" << m_points[i_point_real].m_entry.auid << ")";
            message << ": abs(" << m_points[i_point_real].getLastCoord() << ")>=" << ENERGY_TOL << " [eV]";
            message << " (please report on AFLOW Forum: aflow.org/forum)";
            if(m_cflags.flag("FORCE")){pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);}
            else{throw CHullLogicError(soliloquy,message.str()); message.str("");}
          }
        }
      }else{
        message << "No ground state available for ";
        if(i_alloy<m_velements.size()){message << m_velements[i_alloy];}
        else{message << " unary " << i_alloy+1;}
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      }
    }
    //UNARIES - STOP
    
    //BINARIES - START
    if(binary_statistics_check){
      i_nary=1;
      uint count;
      for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
        count=0;
        for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i++){
          i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
          for(uint j=0;j<m_coord_groups[i_coord_group].m_points.size();j++){count++;}
        }
        if(count<BINARY_ENTRIES_THRESHOLD){
          string hull;
          //safe in case m_velements was not set
          if(m_velements.size()){hull=aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"");}
          else{hull=aurostd::utype2string(i_alloy+1);}
          message << "Binary hull " << hull << " is unreliable (entry_count=" << count << " < " << BINARY_ENTRIES_THRESHOLD << ")";
          if(m_cflags.flag("FORCE")||m_cflags.flag("CHULL::INCLUDE_UNRELIABLE_HULLS")){pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);}
          else{throw CHullRuntimeError(soliloquy,message.str()); message.str("");}
        }
      }
    }
    //BINARIES - STOP
  }
}

void ConvexHull::addPointToFacet(ChullFacet& facet,uint i_point) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::addPointToFacet():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  facet.addVertex(m_points[i_point],i_point);
  if(LDEBUG){
    cerr << soliloquy << " facet.m_vertices.size()=" << facet.m_vertices.size() << endl;
    for(uint i=0;i<facet.m_vertices.size();i++){
      cerr << facet.m_vertices[i].ch_index << "  h_coords=" << facet.m_vertices[i].ch_point.h_coords << endl;
    }
  }
}

void ConvexHull::initializeFacet(ChullFacet& facet,bool check_validity) {facet.initialize(h_reference,h_dim,check_validity);}

uint ConvexHull::getExtremePoint(uint dim) {
  vector<FacetPoint> points_to_avoid;
  return getExtremePoint(dim,points_to_avoid);
}

uint ConvexHull::getExtremePoint(uint dim,const vector<FacetPoint>& points_to_avoid) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getExtremePoint():";
  stringstream message;
  if(!h_points.size()){throw CHullLogicError(soliloquy,"No starting points provided");}
  uint i_point=AUROSTD_MAX_UINT;
  double extreme=-1.0;  //since it's the abs() we check below, -1 is FINE
  bool avoid;
  if(LDEBUG){
    cerr << soliloquy << " h_points:" << endl;
    for(uint i=0;i<h_points.size();i++){
      cerr << h_points[i] << "  h_coords=" << m_points[h_points[i]].h_coords << endl;
    }
    cerr << soliloquy << " points_to_avoid:" << endl;
    for(uint j=0;j<points_to_avoid.size();j++){
      cerr << points_to_avoid[j].ch_index << "  h_coords=" << m_points[points_to_avoid[j].ch_index].h_coords << endl;
    }
  }

  for(uint i=0;i<h_points.size();i++){
    if(dim>(uint)m_points[h_points[i]].h_coords.urows){throw CHullLogicError(soliloquy,"Invalid coordinate index");}
    avoid=false;
    for(uint j=0;j<points_to_avoid.size()&&!avoid;j++){if(h_points[i]==points_to_avoid[j].ch_index){avoid=true;}}
    if(avoid){continue;}
    if(abs(m_points[h_points[i]].h_coords[dim])>extreme){
      i_point=h_points[i];
      extreme=abs(m_points[h_points[i]].h_coords[dim]);
    }
  }
  if(i_point==AUROSTD_MAX_UINT){
    message << "No point found, points_to_avoid is too restrictive (points_to_avoid.size()==" << points_to_avoid.size() << ")";
    throw CHullLogicError(soliloquy,message.str()); message.str("");
  }
  if(LDEBUG){cerr << soliloquy << " i_point=" << i_point << endl;}
  return i_point;
}

void ConvexHull::setCentroid() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setCentroid():";
  vector<xvector<double> > points;
  for(uint i=0;i<h_points.size();i++){points.push_back(m_points[h_points[i]].h_coords);}
  h_centroid=h_reference=aurostd::getCentroid(points);  //fix h_reference later
  //if(1){
  //  //h_centroid[0]=0.5;h_centroid[1]=0.5;h_centroid[2]=-0.01;
  //  for(uint i=0;i<h_centroid.rows-1;i++){h_centroid[i]=0.5;}
  //  h_centroid[h_centroid.urows]=-0.01;
  //}
  if(LDEBUG){cerr << soliloquy << " centroid: " << h_centroid << endl;}
}

vector<FacetPoint> ConvexHull::getInitialExtremePoints() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getInitialExtremePoints():";
  ChullFacet facet;
  string error;
  //get first h_dim points from just the extremes, and plug into facet
  //BAD CASE: fewer than h_dim points, this is NOT hull-able
  if(h_points.size()<h_dim){throw CHullRuntimeError(soliloquy,"Not enough points to build an initial facet");}
  for(uint i=0;i<h_dim;i++){addPointToFacet(facet,getExtremePoint(i,facet.m_vertices));}
  if(!facet.isValid(error)){throw CHullRuntimeError(soliloquy,"An initial facet cannot be created per initial extreme points, invalid points input: "+error);}
  initializeFacet(facet,false); //already validated
  //now get furthest point from this facet, initialize outside set first
  FacetPoint f_point;
  for(uint i=0;i<h_points.size();i++){
    if(facet.isPointOnFacet(h_points[i])){continue;}
    f_point.initialize(m_points[h_points[i]],h_points[i]);
    facet.f_outside_set.push_back(f_point);
    if(LDEBUG){cerr << soliloquy << " adding to facet[" << 0 << "] outside set: " << h_points[i] << endl;}
  }
  if(facet.f_outside_set.size()){ //in special case where there are only 2 points in 2D, we simply return facet and not simplex
    facet.setFurthestPoint();
    facet.addVertex(facet.f_furthest_point); //already have a vector<uint> in m_points, simply append and return
  }
  if(LDEBUG){
    cerr << soliloquy << " building initial simplex with extreme points:" << endl;
    for(uint i=0;i<facet.m_vertices.size();i++){
      cerr << facet.m_vertices[i].ch_point.h_coords << endl;
    }
  }
  return facet.m_vertices;
}

void ConvexHull::setNeighbors() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setNeighbors():";
  
  //print ridges so far
  if(LDEBUG){
    vector<uint> indices;
    for(uint i=0;i<h_facets.size();i++){
      indices=h_facets[i].getCHIndices();
      cerr << soliloquy << " facet[" << i << "] has ridges: ";
      for(uint j=0;j<indices.size();j++){
        cerr << indices[j];
        if(j!=indices.size()-1){cerr << ",";}
      }
      cerr << endl;
    }
  }

  for(uint i_facet=0;i_facet<h_facets.size();i_facet++){h_facets[i_facet].f_neighbors.clear();}
  for(uint i=0;i<h_facets.size();i++){
    for(uint j=i+1;j<h_facets.size();j++){
      if(h_facets[i].shareRidge(h_facets[j])){
        h_facets[i].f_neighbors.push_back(j);
        h_facets[j].f_neighbors.push_back(i);
      }
    }
    //can only perform this check if we have more than one h_facet, otherwise NO neighbors
    if(h_facets.size()>1&&h_facets[i].f_neighbors.size()!=h_dim){throw CHullLogicError(soliloquy,"Neighbor count ("+aurostd::utype2string(h_facets[i].f_neighbors.size())+") and facet dimension ("+aurostd::utype2string(h_dim)+") mismatch");}
  }
  for(uint i=0;i<h_facets.size();i++){std::sort(h_facets[i].f_neighbors.begin(),h_facets[i].f_neighbors.end());}
  
  if(LDEBUG){
    for(uint i=0;i<h_facets.size();i++){
      cerr << soliloquy << " neighbors for facet[i_facet=" << i << ",coords=";
      for(uint j=0;j<h_facets[i].m_vertices.size();j++){cerr << h_facets[i].m_vertices[j].ch_point.h_coords << (j!=h_facets[i].m_vertices.size()-1?", ":"");}
      cerr << "]: " << endl;
      for(uint j=0;j<h_facets[i].f_neighbors.size();j++){
        cerr << h_facets[i].f_neighbors[j] << " ";
      }
      cerr << endl;
    }
  }
}

void ConvexHull::createInitializeSimplex() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::createInitializeSimplex():";
  //clear
  h_facets.clear();
  setCentroid();

  vector<FacetPoint> initial_extreme_points=getInitialExtremePoints();
  //fix h_reference now!
  //NOTE: originally we used the hull centroid to determine alignment of facet normals
  //however, this does not work in the case of 3D hulls with no 3D points (only 2D hull points)
  //instead, we align with the centroid of the initial_extreme_points, as this point SHOULD be guaranteed to be in the hull
  //the hull only gets bigger by accepting more points
  //so we set h_reference first to h_centroid, since we don't care about the alignment of the normal inside getInitialExtremePoints()
  //then we fix here and keep for all facets
  vector<xvector<double> > points;
  for(uint i=0;i<initial_extreme_points.size();i++){points.push_back(initial_extreme_points[i].ch_point.h_coords);}
  h_reference=aurostd::getCentroid(points);
  if(LDEBUG){cerr << soliloquy << " new h_reference=" << h_reference << endl;}

  //new first facet of endpoints
  
  if(initial_extreme_points.size()==h_dim+1){if(LDEBUG){cerr << soliloquy << " building initial simplex" << endl;}}
  else if(initial_extreme_points.size()==h_dim){if(LDEBUG){cerr << soliloquy << " not enough points to build a simplex, will settle for a facet instead" << endl;}}
  else{throw CHullRuntimeError(soliloquy,"Not enough points to construct initial simplex/facet");}

  //get dim combos of points
  string error;
  aurostd::xcombos xc(initial_extreme_points.size(),h_dim);
  vector<int> indices;
  while(xc.increment()){
    //remember, indices are NOT the indices themselves, but a place holder as to whether to include the number at the index
    //e.g., indices==1,1,0; therefore, include indices 0,1
    indices=xc.getCombo();
    if(LDEBUG){
      cerr << soliloquy << " indices=";
      for(uint i=0;i<indices.size();i++){cerr << indices[i] << (i!=indices.size()-1?",":"");}
      cerr << endl;
    }
    h_facets.push_back(ChullFacet());
    for(uint i=0;i<indices.size();i++){
      if(indices[i]==1){h_facets.back().addVertex(initial_extreme_points[i]);}
    }
    if(LDEBUG){
      cerr << soliloquy << " initial facet[" << h_facets.size() << "] new point[" << h_facets.back().m_vertices.size() << "] ";
      cerr << "coords=" << m_points[h_facets.back().m_vertices.back().ch_index].h_coords << endl;
    }
    if(!h_facets.back().isValid(error)){throw CHullRuntimeError(soliloquy,"An initial facet cannot be created, invalid points input: "+error);}
    initializeFacet(h_facets.back(),false); //already validated
  }
  if(initial_extreme_points.size()==h_dim+1){if(LDEBUG){cerr << soliloquy << " initial simplex built" << endl;}}
  else if(initial_extreme_points.size()==h_dim){if(LDEBUG){cerr << soliloquy << " initial (single) facet built" << endl;}}
  else{throw CHullRuntimeError(soliloquy,"Not enough points to construct initial simplex/facet");}

  //if net distance, then it must be outside hull
  bool associated;
  FacetPoint f_point;
  for(uint i=0;i<h_points.size();i++){
    associated=false;
    if(LDEBUG){cerr << soliloquy << " associating point[" << h_points[i] << "] to a facet's outside set" << endl;}
    f_point.initialize(m_points[h_points[i]],h_points[i]);
    for(uint i_facet=0;i_facet<h_facets.size() && !associated;i_facet++){
      if(h_facets[i_facet].isPointOnFacet(f_point)){associated=true;} //skip the obvious
      if(!associated && h_facets[i_facet].isPointOutside(f_point)){
        h_facets[i_facet].f_outside_set.push_back(f_point);
        associated=true;
        if(LDEBUG){cerr << soliloquy << " associating point[" << h_points[i] << "] with facet[" << i_facet << "].f_outside_set" << endl;}
      }
    }
    if(!associated){
      if(LDEBUG){cerr << soliloquy << " NOT associating point[" << h_points[i] << "] with any facet outside set" << endl;}
    }
  }
  //get furthest point
  for(uint i_facet=0;i_facet<h_facets.size();i_facet++){
    if(LDEBUG){cerr << soliloquy << " facet[" << i_facet << "] has " << h_facets[i_facet].f_outside_set.size() << " outside points" << endl;}
    h_facets[i_facet].setFurthestPoint();
  }
  setNeighbors();
}

void ConvexHull::setVisibleFacets(uint i_facet){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setVisibleFacets():";
  if(i_facet>h_facets.size()-1){throw CHullLogicError(soliloquy,"Invalid index with h_facets");}
  //clean
  for(uint i=0;i<h_facets.size();i++){h_facets[i].f_visited=false;}
  h_visible_facets.clear();

  //initialize
  h_visible_facets.push_back(i_facet);
  h_facets[i_facet].f_visited=true;

  uint i_visible,i_neigh;
  for(uint i=0;i<h_visible_facets.size();i++){
    i_visible=h_visible_facets[i];
    for(uint j=0;j<h_facets[i_visible].f_neighbors.size();j++){
      i_neigh=h_facets[i_visible].f_neighbors[j];
      if(h_facets[i_neigh].f_visited){continue;}
      h_facets[i_neigh].f_visited=true;
      if(h_facets[i_neigh].isPointOutside(h_facets[i_facet].f_furthest_point)){h_visible_facets.push_back(i_neigh);}
    }
  }
  
  if(LDEBUG){
    cerr << soliloquy << " visible facets for facet[" << i_facet << "]: ";
    for(uint i=0;i<h_visible_facets.size();i++){cerr << h_visible_facets[i] << " ";}
    cerr << endl;
  }
}

void ConvexHull::setHorizonRidges(){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setHorizonRidges():";
  if(!h_visible_facets.size()){return;}
  h_horizon_ridges.clear();
  bool match;
  for(uint i1=0;i1<h_visible_facets.size();i1++){
    for(uint j1=0;j1<h_facets[h_visible_facets[i1]].m_ridges.size();j1++){
      match=false;
      for(uint i2=0;i2<h_visible_facets.size()&&!match;i2++){
        if(i1==i2){continue;}
        for(uint j2=0;j2<h_facets[h_visible_facets[i2]].m_ridges.size()&&!match;j2++){
          if(h_facets[h_visible_facets[i1]].m_ridges[j1].getCHIndices()==h_facets[h_visible_facets[i2]].m_ridges[j2].getCHIndices()){
            match=true;
          }
        }
      }
      if(!match){h_horizon_ridges.push_back(h_facets[h_visible_facets[i1]].m_ridges[j1]);}
    }
  }
  
  if(LDEBUG){
    cerr << soliloquy << " horizon ridges: ";
    for(uint i=0;i<h_horizon_ridges.size();i++){
      for(uint j=0;j<h_horizon_ridges[i].m_vertices.size();j++){
        cerr << h_horizon_ridges[i].m_vertices[j].ch_index << (j==h_horizon_ridges[i].m_vertices.size()-1?"":" ");
      }
      cerr << (i==h_horizon_ridges.size()-1?"":", ");
    }
    cerr << endl;
  }
}

uint ConvexHull::createNewFacets(FacetPoint furthest_point){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::createNewFacets():";
  if(furthest_point.ch_index>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index with furthest_point");}
  uint old_facet_count=h_facets.size();
  string error; //dummy so we don't recreate every time
  for(uint i=0;i<h_horizon_ridges.size();i++){
    //check obvious
    if(h_horizon_ridges[i].isPointOnFacet(furthest_point)){
      if(LDEBUG){cerr << soliloquy << " skipping new facet: duplicate point" << endl;}
      continue;
    }
    h_horizon_ridges[i].addVertex(furthest_point);
    if(LDEBUG){cerr << soliloquy << " furthest point for new facet: " << furthest_point.ch_index << " " << m_points[furthest_point.ch_index].h_coords << endl;}
    if(!h_horizon_ridges[i].isValid(error)){  //corner case, happens when creating new facets on edges or corners of hull
      if(LDEBUG){cerr << soliloquy << " skipping new facet: " << error << endl;}
      continue;
    }
    initializeFacet(h_horizon_ridges[i],false); //already validated
    h_facets.push_back(h_horizon_ridges[i]);
    if(LDEBUG){
      cerr << soliloquy << " new facet: ";
      for(uint j=0;j<h_facets.back().m_vertices.size();j++){cerr << m_points[h_facets.back().m_vertices[j].ch_index].h_coords << " | ";}
      cerr << endl;
    }
  }
  if(LDEBUG){cerr << soliloquy << " " << h_facets.size()-old_facet_count << " new facets" << endl;}
  return h_facets.size()-old_facet_count;
  //do neighbors at the end!
}

void ConvexHull::updateOutsideSet(uint new_facet_count){  //they are at the end of the list
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::updateOutsideSet():";
  //we're deleting visible planes soon, so we need to reassess/reassign outside points
  uint i_visible;
  bool associated;
  for(uint i=0;i<h_visible_facets.size();i++){
    i_visible=h_visible_facets[i];
    for(uint j=0;j<h_facets[i_visible].f_outside_set.size();j++){
      FacetPoint& f_point=h_facets[i_visible].f_outside_set[j];
      associated=false;
      if(LDEBUG){cerr << soliloquy << " re-associating point[" << f_point.ch_index << "] with a new facet" << endl;}
      for(uint i_facet=h_facets.size()-new_facet_count;i_facet<h_facets.size()&&!associated;i_facet++){
        if(h_facets[i_facet].isPointOnFacet(f_point)){associated=true;} //skip the obvious
        if(!associated && h_facets[i_facet].isPointOutside(f_point)){
          h_facets[i_facet].f_outside_set.push_back(f_point);
          associated=true;
          if(LDEBUG){cerr << soliloquy << " associating point[" << f_point.ch_index << "] with facet[" << i_facet << "].f_outside_set" << endl;}
        }
      }
    }
  }
  for(uint i_facet=h_facets.size()-new_facet_count;i_facet<h_facets.size();i_facet++){
    if(LDEBUG){cerr << soliloquy << " NEW facet[" << i_facet << "] has " << h_facets[i_facet].f_outside_set.size() << " outside points" << endl;}
    h_facets[i_facet].setFurthestPoint();
  }
}

void ConvexHull::deleteVisibleFacets() {
  //sort in descending order because all indices above the point of deletion change
  std::sort(h_visible_facets.rbegin(), h_visible_facets.rend());  //descending  //, std::greater<uint>());
  for(uint i=0;i<h_visible_facets.size();i++){h_facets.erase(h_facets.begin()+h_visible_facets[i]);}
}

void ConvexHull::removeDuplicateHullPoints() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::removeDuplicateHullPoints():";
  std::sort(h_points.begin(),h_points.end());
  h_points.erase( std::unique( h_points.begin(), h_points.end() ), h_points.end() );  //first remove duplicate indices

  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  vector<uint> indices_2_remove;
  for(uint i=0;i<h_points.size();i++){
    for(uint j=i+1;j<h_points.size();j++){
      if(identical(m_points[h_points[i]].h_coords,m_points[h_points[j]].h_coords,ZERO_TOL)){
        indices_2_remove.push_back(j);
      }
    }
  }
  if(LDEBUG){
    cerr << soliloquy << " removing points: ";
    for(uint i=0;i<indices_2_remove.size();i++){cerr << indices_2_remove[i] << " ";}
    cerr << endl;
  }
  std::sort(indices_2_remove.rbegin(),indices_2_remove.rend()); //descending
  for(uint i=0;i<indices_2_remove.size();i++){h_points.erase(h_points.begin()+indices_2_remove[i]);}
  if(LDEBUG){cerr << soliloquy << " done" << endl;}
}

void ConvexHull::calculateFacets() {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  //only copy those possibly on the hull (does not include endpoints)
  string soliloquy="ConvexHull::calculateFacets():";
  
  h_facets.clear();
  removeDuplicateHullPoints();
  if(!h_points.size()){throw CHullLogicError(soliloquy,"No points found on hull");}
  h_dim=m_points[h_points[0]].h_coords.rows;

  for(uint i=1;i<h_points.size();i++){
    if((uint)m_points[h_points[i]].h_coords.rows!=h_dim){throw CHullLogicError(soliloquy,"Invalid initialization of hull coordinates");}
  }

  if(LDEBUG){
    for(uint i=0;i<h_points.size();i++){
      cerr << soliloquy << " m_coords=" << m_points[h_points[i]].m_coords << "; h_coords=" << m_points[h_points[i]].h_coords << endl; //<< "; relevant " << m_points[h_points[i]].isRelevantPoint(elements_present) << endl;
    }
  }

  //main loop START - see algorithm here: 10.1145/235815.235821
  createInitializeSimplex();

  uint new_facet_count;
  for(uint i_facet=0;i_facet<h_facets.size();i_facet++){
    if(!h_facets[i_facet].f_outside_set.size()){continue;}  //the only way we exit this loop is if we continue for ALL facets
    setVisibleFacets(i_facet);
    setHorizonRidges();
    new_facet_count=createNewFacets(h_facets[i_facet].f_furthest_point);
    if(new_facet_count){
      updateOutsideSet(new_facet_count);  //redistribute outside set among new facets (visible planes will go soon)
      for(uint i_facet=h_facets.size()-new_facet_count;i_facet<h_facets.size();i_facet++){h_facets[i_facet].setFurthestPoint();}  //get furthest points for new facets
      deleteVisibleFacets();  //delete visible facets
      setNeighbors();
    }
    i_facet=-1; //restart full loop!
  }
  //main loop END - see algorithm here: 10.1145/235815.235821

  //resort points in facets with knowledge of normal
  //if normal is pointed down, sort in descending order
  bool sort_stoich_ascending;
  for(uint i=0;i<h_facets.size();i++){
    sort_stoich_ascending=!h_facets[i].m_in_lower_hemisphere;
    std::sort(h_facets[i].m_vertices.begin(),h_facets[i].m_vertices.end(),
        sortThermoPoints(sort_stoich_ascending,m_sort_energy_ascending));
  }
  std::sort(h_facets.begin(),h_facets.end(),sortFacetsByPoints(m_points));  //auto sort
  
  if(LDEBUG){
    cerr << soliloquy << " hull points:" << endl;
    for(uint i_facet=0;i_facet<h_facets.size();i_facet++){
      cerr << soliloquy << " facet " << i_facet << ": ";
      for(uint i=0;i<h_facets[i_facet].m_vertices.size();i++){
        cerr << m_points[h_facets[i_facet].m_vertices[i].ch_index].h_coords << " - auid " << m_points[h_facets[i_facet].m_vertices[i].ch_index].m_entry.auid << " | ";
      }
      cerr << "normal " << h_facets[i_facet].m_normal << " | angles " << aurostd::getGeneralAngles(h_facets[i_facet].m_normal,ZERO_TOL) << endl;//<< " | x " << cos(h_facets[i_facet].m_angle) << " | y " << sin(h_facets[i_facet].m_angle)  << endl;
    }
  }
}

const xvector<int>& ConvexHull::getElementsPresent(uint i_nary,uint i_alloy) const {
  string soliloquy="ConvexHull::setElementsPresent():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  return m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
}

void ConvexHull::setElementsPresent(uint i_nary,uint i_alloy){m_elements_present=getElementsPresent(i_nary,i_alloy);}

void ConvexHull::addRelevantUnaries(uint i_nary,uint i_alloy) {
  string soliloquy="ConvexHull::addRelevantUnaries():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  return addRelevantUnaries(m_naries[i_nary].m_alloys[i_alloy].m_elements_present);
}

void ConvexHull::addRelevantUnaries(xvector<int>& elements_present) {
  string soliloquy="ConvexHull::addRelevantUnaries():";
  uint i_nary=0;
  if((uint)elements_present.rows!=m_naries[i_nary].m_alloys.size()){throw CHullLogicError(soliloquy,"Unary alloy is missing from m_naries");}
  uint i_coord_group,i_point;
  for(uint i_alloy=0;i_alloy<(uint)elements_present.rows;i_alloy++){
    if(elements_present[i_alloy]==1){
      if(m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size()!=1){throw CHullLogicError(soliloquy,"Unexpected count of coordgroups for unaries, should only be 1");}
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[0];
      if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
      for(uint i=0;i<m_coord_groups[i_coord_group].m_hull_points.size();i++){
        i_point=m_coord_groups[i_coord_group].m_hull_points[i];
        addHullPoint(i_point,elements_present);
      }
    }
  }
}

void ConvexHull::addLowerDimensionHullMembers(uint i_nary_max){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::addLowerDimensionHullMembers():";
  if(i_nary_max>m_naries.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  //grab from m_naries[i_nary].m_alloys[i_alloy].m_facets
  //we already added unaries, so there will be duplicates, but we safely remove in calculateFacets()
  //don't worry about this yet
  uint i_point,i_facet;
  for(uint i_nary=1;i_nary<i_nary_max;i_nary++){
    if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
    for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
      if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
      for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_facets.size();i++){
        i_facet=m_naries[i_nary].m_alloys[i_alloy].m_facets[i];
        if(i_facet>m_facets.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_facets");}
        const ChullFacet& facet=m_facets[i_facet];
        for(uint j=0;j<facet.m_vertices.size();j++){
          i_point=facet.m_vertices[j].ch_index;
          addHullPoint(i_point,m_elements_present); //this is hull specific, and set with setElementsPresent()
        }
      }
    }
  }
  if(LDEBUG){cerr << soliloquy << " done" << endl;}
}

void ConvexHull::addHullPoint(uint i_point){
  string soliloquy="ConvexHull::addHullPoint():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  h_points.push_back(i_point);
  m_points[i_point].setHullCoords();
}

void ConvexHull::addHullPoint(uint i_point,xvector<int>& elements_present){
  string soliloquy="ConvexHull::addHullPoint():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  h_points.push_back(i_point);
  m_points[i_point].setHullCoords(elements_present);
}

void ConvexHull::prepareHullPoints(uint i_nary,uint i_alloy) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::prepareHullPoints():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  h_points.clear();
  addRelevantUnaries(i_nary,i_alloy);
  addLowerDimensionHullMembers(i_nary); //don't worry about adding unary duplicates, we remove them robustly in calculateFacets()
  uint i_coord_group,i_point;
  for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i++){
    i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
    if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
    for(uint j=0;j<m_coord_groups[i_coord_group].m_hull_points.size();j++){
      i_point=m_coord_groups[i_coord_group].m_hull_points[j];
      addHullPoint(i_point,m_naries[i_nary].m_alloys[i_alloy].m_elements_present);
    }
  }
  if(LDEBUG){cerr << soliloquy << " done" << endl;}
}

void ConvexHull::prepareHullPoints() {
  string soliloquy="ConvexHull::prepareHullPoints():";
  h_points.clear();
  //we already checked extremes in last (energy) direction, just add these to the hull
  //don't include those points in between
  uint i_point;
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
    for(uint i=0;i<m_coord_groups[i_coord_group].m_hull_points.size();i++){
      i_point=m_coord_groups[i_coord_group].m_hull_points[i];
      addHullPoint(i_point);
    }
  }
}

uint ConvexHull::getNearestFacetVertically(const vector<uint>& i_facets,const ChullPoint& point) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getNearestFacetVertically():";
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(LDEBUG){cerr << soliloquy << " m_coords=" << point.m_coords << ", h_coords=" << point.h_coords << endl;}
  return getNearestFacetVertically(i_facets,point.h_coords);
}

uint ConvexHull::getNearestFacetVertically(const vector<uint>& i_facets,const xvector<double>& point) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  //determines nearness by vertical distance
  string soliloquy="ConvexHull::getNearestFacetVertically():";
  uint i_facet,i_facet_min;
  uint i_facet_artificial=-1; //really large uint
  double vdist,dist=AUROSTD_MAX_DOUBLE;
  for(uint i=0;i<i_facets.size();i++){
    i_facet=i_facets[i];
    if(i_facet>m_facets.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_facets");}
    const ChullFacet& facet=m_facets[i_facet];
    if(!facet.m_initialized){throw CHullLogicError(soliloquy,"Facet not initialized");}
    if(facet.m_is_vertical){continue;}
    if(facet.m_is_artificial){
      i_facet_artificial=i_facet;
      continue;
    }
    if(LDEBUG){cerr << soliloquy << " looking at facet[" << i_facet << "]" << endl;}
    vdist=abs(facet.verticalDistance(point,true));  //abs, //(repetita iuvant)
    if(vdist<dist){
      i_facet_min=i_facet;
      dist=vdist;
    }
  }
  //safety, return artificial facet if no other facets available
  if(dist==AUROSTD_MAX_DOUBLE){
    if(i_facet_artificial>m_facets.size()-1){throw CHullLogicError(soliloquy,"No nearest facet found");}
    return i_facet_artificial;
  }
  return i_facet_min;
}

const vector<uint>& ConvexHull::getRelevantFacets(uint i_nary,uint i_alloy) const {
  string soliloquy="ConvexHull::getRelevantFacets():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  
  if(i_nary==0){  //unaries are special case
    //try m_facets, otherwise start from top and go down
    if(m_i_facets.size()){return m_i_facets;}
    for(uint i_nary=m_naries.size()-1;i_nary<m_naries.size();i_nary--){
      for(uint i_alloy=m_naries[i_nary].m_alloys.size()-1;i_alloy<=m_naries[i_nary].m_alloys.size();i_alloy--){
        if(m_naries[i_nary].m_alloys[i_alloy].m_facets.size()){return m_naries[i_nary].m_alloys[i_alloy].m_facets;}
      }
    }
  }else{
    if(m_naries[i_nary].m_alloys[i_alloy].m_facets.size()){return m_naries[i_nary].m_alloys[i_alloy].m_facets;}
  }
  throw CHullLogicError(soliloquy,"Facets not calculated");
}

void ConvexHull::setHullMembers() {return setHullMembers(m_i_facets);}
void ConvexHull::setHullMembers(uint i_nary,uint i_alloy) {
  string soliloquy="ConvexHull::setHullMembers():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);//m_naries[i_nary].m_alloys[i_alloy].m_facets;
  return setHullMembers(i_facets);
}

void ConvexHull::setHullMembers(const vector<uint>& i_facets) {
  string soliloquy="ConvexHull::setHullMembers():";
  if(!i_facets.size()){throw CHullLogicError(soliloquy,"Hull has yet to be calculated");}
  uint i_point,g_state,i_coord_group,i_facet;
  for(uint i=0;i<i_facets.size();i++){
    i_facet=i_facets[i];
    if(i_facet>m_facets.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_facets");}
    for(uint j=0;j<m_facets[i_facet].m_vertices.size();j++){
      i_point=m_facets[i_facet].m_vertices[j].ch_index;
      if(!getCoordGroupIndex(i_point,i_coord_group)){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
      //hull member == yes
      m_points[i_point].m_is_on_hull=true;
      m_coord_groups[i_coord_group].m_is_on_hull=true;
      if(m_thermo_hull){m_coord_groups[i_coord_group].m_hull_member=i_point;}  //very safe, only one hull-member per coordgroup
      //g-state == if not artificial point
      g_state=artificialMap(i_point);
      if(!m_points[g_state].m_is_artificial){m_points[g_state].m_is_g_state=true;}
    }
  }
}

void ConvexHull::setNearestFacet(uint i_nary,uint i_alloy,uint i_coord_group){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setNearestFacet():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(m_coord_groups[i_coord_group].m_is_on_hull){return;}
  if(m_coord_groups[i_coord_group].m_points.size()==0){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  
  uint i_point=m_coord_groups[i_coord_group].m_points[0];
  ChullPoint& point=m_points[i_point];
  //it's possible that h_coords has not been set (we only do it to points that make it to hull calc)
  //so set again (repetita iuvant)
  xvector<int>& elements_present=m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
  point.setHullCoords(elements_present);
  const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);//m_naries[i_nary].m_alloys[i_alloy].m_facets;
  uint i_facet=getNearestFacetVertically(i_facets,point);
  m_coord_groups[i_coord_group].m_nearest_facet=i_facet;
  if(LDEBUG){
    cerr << soliloquy << " nearest_facet[i_nary=" << i_nary << ",i_alloy=" << i_alloy << ",i_coord_group=" << i_coord_group;
    cerr << "]=" << m_coord_groups[i_coord_group].m_nearest_facet << endl;
  }
}

double ConvexHull::getDistanceToHull(uint i_point) const{
  string soliloquy="ConvexHull::getDistanceToHull():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  return getDistanceToHull(m_points[i_point]);
}

double ConvexHull::getDistanceToHull(const ChullPoint& point) const{
  string soliloquy="ConvexHull::getDistanceToHull():";
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  const vector<uint>& i_facets=m_i_facets;
  if(m_has_stoich_coords){
    uint i_nary,i_alloy;
    if(!getAlloyIndex(point,i_nary,i_alloy)){throw CHullLogicError(soliloquy,"Cannot get alloys index");}
    const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);
    uint i_facet=getNearestFacetVertically(i_facets,point);
    return m_facets[i_facet].verticalDistance(point,false);
  }
  uint i_facet=getNearestFacetVertically(i_facets,point);
  return m_facets[i_facet].verticalDistance(point,false);
}

void ConvexHull::setDistancesToHull(uint i_nary,uint i_alloy,uint i_coord_group) {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setDistancesToHull():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(m_coord_groups[i_coord_group].m_nearest_facet>m_naries[i_nary].m_alloys[i_alloy].m_facets.size()-1){setNearestFacet(i_nary,i_alloy,i_coord_group);}
  if(m_coord_groups[i_coord_group].m_points.size()==0){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}

  uint i_point=m_coord_groups[i_coord_group].m_points[0];
  i_point=artificialMap(i_point); //don't need to set distance for artificial point, re-scale to this point
  ChullPoint& point=m_points[i_point];
  double dist_2_hull=0.0;
  bool check_dist_2_hull=false;
  if(!m_coord_groups[i_coord_group].m_is_on_hull){ //off-hull
    uint i_facet=m_coord_groups[i_coord_group].m_nearest_facet;
    dist_2_hull=m_facets[i_facet].verticalDistance(point,false);  //do this "expensive" calculation only once, others are simply z-scaled
    if(LDEBUG){
      cerr << soliloquy << " dist[coord=" << point.h_coords << "]=" << dist_2_hull << endl;
      if(check_dist_2_hull){
        cerr << soliloquy << " comparing fast dist calculation = "  << dist_2_hull;
        cerr << " vs. slow dist calculation =" << getDistanceToHull(point) << endl;
      }
    }
    if(m_half_hull){  //tests of stupidity
      //do not use signbit, add tol to zero
      if(m_lower_hull){
        if(dist_2_hull>=ZERO_TOL){throw CHullLogicError(soliloquy,"(lower half hull) found point BELOW hull (entry="+point.m_entry.auid+",dist2Hull="+aurostd::utype2string(dist_2_hull,4)+")");}
      }else{
        if(dist_2_hull<-ZERO_TOL){throw CHullLogicError(soliloquy,"(upper half hull) found point ABOVE hull (entry="+point.m_entry.auid+",dist2Hull="+aurostd::utype2string(dist_2_hull,4)+")");}
      }
    }
  }
  dist_2_hull=abs(dist_2_hull); //force positive, the value is what we care about now
  point.m_dist_2_hull=m_coord_groups[i_coord_group].m_nearest_distance=dist_2_hull;
  if(LDEBUG){cerr << soliloquy << " |dist|=" << point.m_dist_2_hull << endl;}
  uint j_point;
  for(uint j=0;j<m_coord_groups[i_coord_group].m_points.size();j++){
    j_point=m_coord_groups[i_coord_group].m_points[j];
    j_point=artificialMap(j_point); //don't need to set distance for artificial point, re-scale to this point
    m_points[j_point].m_dist_2_hull=point.m_dist_2_hull;
    if(i_point!=j_point){m_points[j_point].m_dist_2_hull+=abs(point.getLastCoord()-m_points[j_point].getLastCoord());}
    //it's possible that h_coords has not been set (we only do it to points that make it to hull calc)
    //so set again (repetita iuvant)
    if(LDEBUG){
      xvector<int>& elements_present=m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
      m_points[j_point].setHullCoords(elements_present);
      cerr << soliloquy << " dist[coord=" << m_points[j_point].h_coords << "]=" << m_points[j_point].m_dist_2_hull << endl;
    }
  }
}

vector<uint> ConvexHull::extractDecompositionPhases(const ChullFacet& facet) const{
  string soliloquy="ConvexHull::extractDecompositionPhases():";
  uint i_point;
  vector<uint> decomp_phases;
  for(uint i=0;i<facet.m_vertices.size();i++){
    i_point=facet.m_vertices[i].ch_index;
    decomp_phases.push_back(i_point);
  }
  if(decomp_phases.size()==0){throw CHullLogicError(soliloquy,"No decomposition phases found");}
  std::sort(decomp_phases.begin(),
      decomp_phases.end(),
      sortCHullPoints(m_points,false,true)); //stoich sorting should be descending, energy sorting default okay here
  return decomp_phases;
}

vector<uint> ConvexHull::getDecompositionPhases(uint i_point) const{
  string soliloquy="ConvexHull::getDecompositionPhases():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  return getDecompositionPhases(m_points[i_point]);
}

vector<uint> ConvexHull::getDecompositionPhases(const ChullPoint& point) const{
  string soliloquy="ConvexHull::getDecompositionPhases():";
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(point.m_is_on_hull){throw CHullLogicError(soliloquy,"No decomposition coefficients for hull members");}
  const vector<uint>& i_facets=m_i_facets;  //default, most broad
  uint i_facet;
  if(m_has_stoich_coords){
    uint i_nary,i_alloy;
    if(!getAlloyIndex(point,i_nary,i_alloy)){throw CHullLogicError(soliloquy,"Cannot get alloys index");}
    const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);
    i_facet=getNearestFacetVertically(i_facets,point);
    return extractDecompositionPhases(m_facets[i_facet]);
  }
  i_facet=getNearestFacetVertically(i_facets,point);
  return extractDecompositionPhases(m_facets[i_facet]);
}

void ConvexHull::setDecompositionPhases(uint i_nary,uint i_alloy,uint i_coord_group){
  string soliloquy="ConvexHull::setDecompositionPhases():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(m_coord_groups[i_coord_group].m_is_on_hull){return;}
  if(m_coord_groups[i_coord_group].m_nearest_facet>m_naries[i_nary].m_alloys[i_alloy].m_facets.size()-1){setNearestFacet(i_nary,i_alloy,i_coord_group);}
  
  uint i_facet=m_coord_groups[i_coord_group].m_nearest_facet;
  ChullFacet& facet=m_facets[i_facet];
  m_coord_groups[i_coord_group].m_decomp_phases=extractDecompositionPhases(facet);
}

xvector<double> ConvexHull::getDecompositionCoefficients(uint i_point,bool reduce) const{
  string soliloquy="ConvexHull::getDecompositionCoefficients():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  return getDecompositionCoefficients(m_points[i_point],reduce);
}

xvector<double> ConvexHull::getDecompositionCoefficients(const ChullPoint& point,bool reduce) const{
  string soliloquy="ConvexHull::getDecompositionCoefficients():";
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(point.m_is_on_hull){throw CHullLogicError(soliloquy,"No decomposition coefficients for hull members");}
  if(m_has_stoich_coords){
    uint i_nary,i_alloy,i_coord_group;
    //could combine via getNariesIndex(), but keep separate for debugging purposes
    if(!getAlloyIndex(point,i_nary,i_alloy)){throw CHullLogicError(soliloquy,"Cannot get alloys index");}
    if(getCoordGroupIndex(point,i_coord_group)){
      if(m_coord_groups[i_coord_group].m_is_on_hull){throw CHullLogicError(soliloquy,"No decomposition coefficients for hull members");}
      if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
        return getDecompositionCoefficients(point,m_coord_groups[i_coord_group].m_decomp_phases,reduce);
      }
    }
  }
  return getDecompositionCoefficients(point,getDecompositionPhases(point),reduce);
}

xvector<double> ConvexHull::getDecompositionCoefficients(uint i_point,const vector<uint>& decomp_phases,bool reduce) const{
  string soliloquy="ConvexHull::getDecompositionCoefficients():";
  if(i_point>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  return getDecompositionCoefficients(m_points[i_point],decomp_phases,reduce);
}

xvector<double> ConvexHull::getDecompositionCoefficients(const ChullPoint& point,const vector<uint>& decomp_phases,bool reduce) const{
  string soliloquy="ConvexHull::getDecompositionCoefficients():";
  //do m_coords_group first (REDUCED)
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(!decomp_phases.size()){throw CHullLogicError(soliloquy,"No decomposition phases found");}
  vector<xvector<double> > lhs,rhs;
  //lhs
  lhs.push_back(point.getTruncatedComp(m_elements_present)); //getTruncatedStoich(m_elements_present)); //s_coords);
  //rhs
  for(uint i=0;i<decomp_phases.size();i++){
    if(decomp_phases[i]>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
    if(!m_points[decomp_phases[i]].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
    rhs.push_back(m_points[decomp_phases[i]].getTruncatedComp(m_elements_present));
  }
  xvector<double> coef=balanceChemicalEquation(lhs,rhs,reduce,true,ZERO_TOL);
  aurostd::shiftlrows(coef,0);
  return coef;
}

void ConvexHull::setDecompositionCoefficients(uint i_nary,uint i_alloy,uint i_coord_group){
  string soliloquy="ConvexHull::setDecompositionCoefficients():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(m_coord_groups[i_coord_group].m_is_on_hull){return;}
  if(m_coord_groups[i_coord_group].m_decomp_phases.size()==0){setDecompositionPhases(i_nary,i_alloy,i_coord_group);}
  
  //we get different coefficients between stoich and composition
  //ALWAYS use composition (even POCC, simply won't reduce), and do NOT mix stoich + composition
  uint i_point=m_coord_groups[i_coord_group].m_points[0];
  vector<uint>& decomp_phases=m_coord_groups[i_coord_group].m_decomp_phases;
  m_coord_groups[i_coord_group].m_decomp_coefs=getDecompositionCoefficients(i_point,decomp_phases,true);

  //now do individual coefficients, NO REDUCE
  for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
    i_point=m_coord_groups[i_coord_group].m_points[i];
    m_points[i_point].m_decomp_coefs=getDecompositionCoefficients(i_point,decomp_phases,false);
  }
}

void ConvexHull::setOffHullProperties(uint i_nary,uint i_alloy){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setOffHullProperties():";
  stringstream message;
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  
  message << "Gathering decomposition reaction data";
  if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
  else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

  uint i_coord_group;
  for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i++){
    i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
    if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
    if(!m_coord_groups[i_coord_group].m_initialized){continue;}
    if(m_coord_groups[i_coord_group].m_is_on_hull){continue;}
    if(LDEBUG){cerr << soliloquy << " looking at i_coord_group=" << i_coord_group << endl;}
    setNearestFacet(i_nary,i_alloy,i_coord_group);
    setDistancesToHull(i_nary,i_alloy,i_coord_group);
    setDecompositionPhases(i_nary,i_alloy,i_coord_group);
    setDecompositionCoefficients(i_nary,i_alloy,i_coord_group);
  }
}

vector<uint> ConvexHull::getAdjacentFacets(uint hull_member,bool ignore_vertical, bool ignore_artificial) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getAdjacentFacets():";
  if(hull_member>m_points.size()-1){throw CHullLogicError(soliloquy,"No hull member has been identified");}
  vector<uint> adjacent_i_facets;
  if(!m_points[hull_member].m_is_on_hull){return adjacent_i_facets;}
  
  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  
  uint i_nary=m_points[hull_member].m_i_nary;
  uint i_alloy=m_points[hull_member].m_i_alloy;
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);//m_naries[i_nary].m_alloys[i_alloy].m_facets;
  uint i_facet;
  for(uint i=0;i<i_facets.size();i++){
    i_facet=i_facets[i];
    if(i_facet>m_facets.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_facets");}
    if(ignore_vertical && m_facets[i_facet].m_is_vertical){continue;}
    if(ignore_artificial && m_facets[i_facet].m_is_artificial){continue;}
    if(m_facets[i_facet].isPointOnFacet(hull_member)){adjacent_i_facets.push_back(i_facet);}
  }
  if(adjacent_i_facets.size()==0){throw CHullLogicError(soliloquy,"No adjacent facets found");}
  if(LDEBUG){cerr << soliloquy << " stop" << endl;}
  return adjacent_i_facets;
}

vector<vector<uint> > ConvexHull::getEquilibriumPhases(uint hull_member) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getEquilibriumPhases():";
  if(hull_member>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  const ChullPoint& point=m_points[hull_member];
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(!point.m_is_on_hull){throw CHullLogicError(soliloquy,"No equilibrium phases for non hull members");}
  vector<vector<uint> > equilibrium_phases;
  
  vector<uint> adjacent_i_facets=getAdjacentFacets(hull_member,true,true);
  //make full copy of relevant facets so we can sort accordingly, ignore vertical and artificial facets
  vector<ChullFacet> adjacent_facets;
  for(uint i=0;i<adjacent_i_facets.size();i++){adjacent_facets.push_back(m_facets[adjacent_i_facets[i]]);}
  
  //sort
  for(uint i_facet=0;i_facet<adjacent_facets.size();i_facet++){
    std::sort(adjacent_facets[i_facet].m_vertices.begin(),adjacent_facets[i_facet].m_vertices.end(),
        sortThermoPoints(false,true)); //stoich sorting should be descending, energy sorting default okay here
  }
  std::sort(adjacent_facets.begin(),adjacent_facets.end(),
      sortFacetsByPoints(m_points,false,false,false,false));  //not auto sort, sort everything descending

  uint i_point;
  for(uint i_facet=0;i_facet<adjacent_facets.size();i_facet++){
    if(LDEBUG){cerr << soliloquy << " found new relevant facet[" << i_facet << "] with points: ";}
    equilibrium_phases.push_back(vector<uint>(0));
    for(uint i=0;i<adjacent_facets[i_facet].m_vertices.size();i++){
      i_point=adjacent_facets[i_facet].m_vertices[i].ch_index;
      equilibrium_phases.back().push_back(i_point);
      if(LDEBUG){cerr << m_points[i_point].h_coords << " [" << i_point << "]" << (i!=adjacent_facets[i_facet].m_vertices.size()-1?", ":"");}
    }
    if(LDEBUG){cerr << endl;}
  }
  return equilibrium_phases;
}

void ConvexHull::setEquilibriumPhases(uint i_nary,uint i_alloy,uint i_coord_group){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setEquilibriumPhases():";
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_is_on_hull){return;}
  if(m_coord_groups[i_coord_group].m_points.size()==0){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  
  //get hull-member and check that it's correct
  uint hull_member=m_coord_groups[i_coord_group].m_hull_member;
  if(hull_member>m_points.size()-1){throw CHullLogicError(soliloquy,"No hull member has been identified");}
  if(!m_points[hull_member].m_is_on_hull){return;}
  if(m_points[hull_member].isUnary()){return;} //others are in equilibrium with it, must be context of mixture!

  if(LDEBUG){cerr << soliloquy << " looking at hull-member[" << hull_member << "]=" << m_points[hull_member].h_coords << endl;}

  m_coord_groups[i_coord_group].m_equilibrium_phases=getEquilibriumPhases(hull_member);
  
  if(LDEBUG){cerr << soliloquy << " stop" << endl;}
}

//strict === strictly differ
//if we don't know, because of AUROSTD_NAN's or NOSG's, we may still return false anyway to 
//continue on to more strict determination later
bool ConvexHull::energiesDiffer(uint i_point1,uint i_point2,bool strict) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::energiesDiffer():";
  if(i_point1>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  if(i_point2>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}

  if(i_point1==i_point2){return false;}
  if(!m_points[i_point1].m_has_entry){return strict;}  //if strict, then return that they do differ (true)
  if(!m_points[i_point2].m_has_entry){return strict;}  //if strict, then return that they do differ (true)
  
  const double& energy1=m_points[i_point1].getEnergy();
  const double& energy2=m_points[i_point2].getEnergy();
  if(LDEBUG){cerr << soliloquy << energy1 << " vs. " << energy2 << endl;}
  if(energy1>=AUROSTD_NAN || energy2>=AUROSTD_NAN){return strict;} //if strict, then return that they do differ (true)

  bool differs=aurostd::isdifferent(energy1,energy2,ENERGY_TOL);
  if(LDEBUG){cerr << soliloquy << " energies do " << (differs?"":"NOT ") << "differ" << endl;}
  return differs;
}

//strict === strictly differ
//if we don't know, because of AUROSTD_NAN's or NOSG's, we may still return false anyway to 
//continue on to more strict determination later
bool ConvexHull::spacegroupsDiffer(uint i_point1,uint i_point2,bool strict) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::spacegroupsDiffer():";
  if(i_point1>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  if(i_point2>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}

  if(i_point1==i_point2){return false;}
  if(!m_points[i_point1].m_has_entry){return strict;}  //if strict, then return that they do differ (true)
  if(!m_points[i_point2].m_has_entry){return strict;}  //if strict, then return that they do differ (true)

  const string& sg1=m_points[i_point1].getSG();
  const string& sg2=m_points[i_point2].getSG();
  if(LDEBUG){cerr << soliloquy << sg1 << " vs. " << sg2 << endl;}
  if(sg1==NOSG || sg2==NOSG){return strict;}  //if strict, then return that they do differ (true)

  bool differs=(sg1!=sg2);
  if(LDEBUG){cerr << soliloquy << " spacegroups do " << (differs?"":"NOT ") << "differ" << endl;}
  return differs;
}

bool ConvexHull::structuresEquivalent(uint i_point1,uint i_point2) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::structuresEquivalent():";
  if(i_point1>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  if(i_point2>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}

  if(i_point1==i_point2){return true;}
  //we will not be so stringent on throwing errors here, if we cannot find/load structure, simply return false
  if(!m_points[i_point1].m_has_entry){return false;}
  if(!m_points[i_point2].m_has_entry){return false;}

  xstructure a,b;
  if(!m_points[i_point1].getMostRelaxedXstructure(a)){return false;}
  if(!m_points[i_point2].getMostRelaxedXstructure(b)){return false;}
  //if(!m_points[i_point1].loadXstructures(true)){return false;}
  //if(!m_points[i_point2].loadXstructures(true)){return false;}
  
  //const xstructure& a=m_points[i_point1].m_entry.vstr[0];
  //const xstructure& b=m_points[i_point2].m_entry.vstr[0];
  if(LDEBUG){
    cerr << soliloquy << " loaded both structures" << endl;
    cerr << soliloquy << " structure 1" << endl;
    cerr << a;
    cerr << soliloquy << " structure 2" << endl;
    cerr << b;
  }
  bool are_equivalent=compare::aflowCompareStructure(a,b,true,false,true); //match species and use fast match, but not scale volume, two structures with different volumes (pressures) are different! //DX 1/23/18 - added fast_match = true
  if(LDEBUG){cerr << soliloquy << " structures are " << (are_equivalent?"":"NOT ") << "equivalent" << endl;}
  return are_equivalent;
}

vector<uint> ConvexHull::getEquivalentGStates(uint g_state) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getEquivalentGStates():";
  if(g_state>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  const ChullPoint& point=m_points[g_state];
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(!point.m_is_g_state){throw CHullLogicError(soliloquy,"No equivalent g-states for non ground state structures");}
  uint i_coord_group;
  if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  if(!m_coord_groups[i_coord_group].m_is_on_hull){throw CHullLogicError(soliloquy,"Coordgroup is not on the hull");}
  bool perform_structure_comparison=(1&&!(m_cflags.flag("CHULL::SKIP_STRUCTURE_COMPARISON")||(m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));

  vector<uint> equivalent_g_states;
  
  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  uint i_point;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
    i_point=m_coord_groups[i_coord_group].m_points[i];
    if(g_state!=i_point){
      if(!m_points[i_point].m_has_entry){continue;}
      if(energiesDiffer(g_state,i_point,false)){continue;} //first filter by those with wildly different energies, not strict
      if(spacegroupsDiffer(g_state,i_point,false)){continue;} //first filter by those with wildly different spacegroups, not strict
      if(!perform_structure_comparison){continue;}
      if(!structuresEquivalent(g_state,i_point)){continue;}
    }
    equivalent_g_states.push_back(i_point);
  }
  if(LDEBUG){
    cerr << soliloquy << " g-state[" << g_state << "]=" << m_points[g_state].h_coords;
    cerr << " equivalent structures=";
    for(uint i=0;i<equivalent_g_states.size();i++){cerr << equivalent_g_states[i] << (i!=equivalent_g_states.size()-1?", ":"");}
    cerr << endl;
  }
  return equivalent_g_states;
}

void ConvexHull::setEquivalentGStates(uint i_nary,uint i_alloy,uint i_coord_group){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setEquivalentGStates():";
  m_coord_groups[i_coord_group].m_equivalent_g_states.clear();
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_is_on_hull){return;}
  if(m_coord_groups[i_coord_group].m_points.size()==0){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  
  //we need to do a structure comparison, so get artificial map (did already before)
  uint g_state=m_coord_groups[i_coord_group].m_ref_state;
  if(g_state>m_points.size()-1){return;}
  if(!m_points[g_state].m_has_entry){return;} //throw CHullLogicError(soliloquy,"No entry (structure) found");} //only point in coordgroup
  
  if(LDEBUG){cerr << soliloquy << " looking at g-state[" << g_state << "]=" << m_points[g_state].h_coords << endl;}
  m_coord_groups[i_coord_group].m_equivalent_g_states=getEquivalentGStates(g_state);
  uint i_point;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_equivalent_g_states.size();i++){
    i_point=m_coord_groups[i_coord_group].m_equivalent_g_states[i];
    m_points[i_point].m_is_equivalent_g_state=true; //g_state and equivalent_g_state should stay separate
  }
  if(LDEBUG){cerr << soliloquy << " stop" << endl;}
}

vector<uint> ConvexHull::getSymEquivalentGStates(uint g_state) const{
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getSymEquivalentGStates():";
  if(g_state>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  const ChullPoint& point=m_points[g_state];
  if(!point.m_initialized){throw CHullLogicError(soliloquy,"Uninitialized point");}
  if(!point.m_is_g_state){throw CHullLogicError(soliloquy,"No equivalent g-states for non ground state structures");}
  uint i_coord_group;
  if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}

  vector<uint> sym_equivalent_g_states;
  
  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  uint i_point;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
    i_point=m_coord_groups[i_coord_group].m_points[i];
    if(g_state!=i_point){if(spacegroupsDiffer(g_state,i_point,true)){continue;}}
    sym_equivalent_g_states.push_back(i_point);
  }
  if(LDEBUG){
    cerr << soliloquy << " g-state[" << g_state << "]=" << m_points[g_state].h_coords;
    cerr << " symmetrically equivalent structures=";
    for(uint i=0;i<sym_equivalent_g_states.size();i++){cerr << sym_equivalent_g_states[i] << (i!=sym_equivalent_g_states.size()-1?", ":"");}
    cerr << endl;
  }
  return sym_equivalent_g_states;
}

void ConvexHull::setSymEquivalentGStates(uint i_nary,uint i_alloy,uint i_coord_group){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setSymEquivalentGStates():";
  m_coord_groups[i_coord_group].m_sym_equivalent_g_states.clear();
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  if(i_coord_group>m_coord_groups.size()-1){throw CHullLogicError(soliloquy,"Invalid index within coordgroups");}
  if(!m_coord_groups[i_coord_group].m_is_on_hull){return;}
  if(m_coord_groups[i_coord_group].m_points.size()==0){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
  if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
  
  //we need to do a structure comparison, so get artificial map (did already before)
  uint g_state=m_coord_groups[i_coord_group].m_ref_state;
  if(g_state>m_points.size()-1){return;}
  if(!m_points[g_state].m_has_entry){return;} //throw CHullLogicError(soliloquy,"No entry (structure) found");} //only point in coordgroup
  
  if(LDEBUG){cerr << soliloquy << " looking at g-state[" << g_state << "]=" << m_points[g_state].h_coords << endl;}
  m_coord_groups[i_coord_group].m_sym_equivalent_g_states=getSymEquivalentGStates(g_state);
  uint i_point;
  for(uint i=0;i<m_coord_groups[i_coord_group].m_sym_equivalent_g_states.size();i++){
    i_point=m_coord_groups[i_coord_group].m_sym_equivalent_g_states[i];
    m_points[i_point].m_is_sym_equivalent_g_state=true; //g_state and sym_equivalent_g_state should stay separate
  }
  if(LDEBUG){cerr << soliloquy << " stop" << endl;}
}

void ConvexHull::setOnHullProperties(uint i_nary,uint i_alloy){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::setOnHullProperties():";
  stringstream message;
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  
  message << "Gathering equilibrium phases and determining equivalent ground states, please be patient";
  if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
  else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

  uint i_coord_group;
  for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i++){
    i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
    if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
    if(!m_coord_groups[i_coord_group].m_initialized){continue;}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){continue;}
    if(LDEBUG){cerr << soliloquy << " looking at i_coord_group=" << i_coord_group << endl;}
    setDistancesToHull(i_nary,i_alloy,i_coord_group);
    //very important that you do not simply go through all facet points and find equilibrium points
    //this will overwrite binary information with ternary information
    //proceed safely with i_coord_group's
    setEquilibriumPhases(i_nary,i_alloy,i_coord_group);
    setSymEquivalentGStates(i_nary,i_alloy,i_coord_group);
    setEquivalentGStates(i_nary,i_alloy,i_coord_group);
  }
}

void ConvexHull::storeHullData(uint i_nary,uint i_alloy){
  string soliloquy="ConvexHull::storeHullData():";
  stringstream message;
  if(!h_facets.size()){throw CHullLogicError(soliloquy,"Hull has yet to be calculated");}
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}
  
  m_naries[i_nary].m_alloys[i_alloy].m_facets.clear();
  for(uint i=0;i<h_facets.size();i++){
    m_facets.push_back(h_facets[i]);
    m_naries[i_nary].m_alloys[i_alloy].m_facets.push_back(m_facets.size()-1);
  }
  setHullMembers(i_nary,i_alloy);
  message << "Hull properties stored";
  if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
  else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
}

void ConvexHull::storeHullData() {
  for(uint i=0;i<h_facets.size();i++){
    m_facets.push_back(h_facets[i]);
    m_i_facets.push_back(m_facets.size()-1);
  }
  setHullMembers();
}

void ConvexHull::thermodynamicPostprocessing(uint i_nary,uint i_alloy){
  string soliloquy="ConvexHull::storeHullData():";
  stringstream message;
  if(!h_facets.size()){throw CHullLogicError(soliloquy,"Hull has yet to be calculated");}
  if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw CHullLogicError(soliloquy,"Invalid index within m_naries");}
  if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary");}
  if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized alloy");}

  bool perform_postprocessing=!m_cflags.flag("CHULL::SKIP_THERMO_POSTPROCESSING");
  if(!perform_postprocessing){return;}
  if(!m_thermo_hull){
    message << "Cannot perform postprocessing, thermodynamic hull NOT detected";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
    return;
  }
  
  message << "Thermodynamic hull detected, gathering on/off hull properties";
  if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
  else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
  setOffHullProperties(i_nary,i_alloy);
  setOnHullProperties(i_nary,i_alloy);
  
  message << "Thermodynamic post-processing completed";
  if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
  else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
}

void ConvexHull::calculate(){
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  stringstream message;
  string soliloquy="ConvexHull::calculate():";

  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized coordgroup");}
    for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
      m_points[m_coord_groups[i_coord_group].m_points[i]].m_is_on_hull=false; //completely refresh
    }
    m_coord_groups[i_coord_group].m_is_on_hull=false; //completely refresh
  }

  if(LDEBUG){cerr << soliloquy << " starting" << endl;}
  //we first run through alloy hulls IF stoich_coords, grabbing hull_members
  if(m_has_stoich_coords){
    message << "Stoichiometric coordinates detected, calculating the hull(s) in increasing dimensionality";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
    if(!m_naries.size()){throw CHullLogicError(soliloquy,"Points have yet to be structured");}
    for(uint i_nary=1;i_nary<m_naries.size();i_nary++){ //start at binaries
      for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
        message << "Calculating " << i_nary+1 << "-nary hull";
        if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
        else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
        cleanHull();
        setElementsPresent(i_nary,i_alloy); //m_stoich_coords only
        prepareHullPoints(i_nary,i_alloy);  //will have unary duplicates, but don't worry, we remove in calculateFacets()
        calculateFacets();
        message << i_nary+1 << "-nary hull calculated";
        if(m_velements.size()){message << " (" << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"") << ")";}
        else{message << " (" << i_nary+1 << "-nary,alloy=" << i_alloy+1 << ")";}
        pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
        storeHullData(i_nary,i_alloy);
        if(m_thermo_hull){thermodynamicPostprocessing(i_nary,i_alloy);}
      }
    }
    //set unary properties last
    //sort of a hack, but actually an intelligent solution
    //unary hull-members will be identified in higher dimensions
    //therefore, we simply need to calculate their properties
    if(m_thermo_hull){  //very safe, not sure how these algorithms perform outside of this domain, already know we have m_has_stoich_coords
      for(uint i_alloy=0;i_alloy<m_naries[0].m_alloys.size();i_alloy++){thermodynamicPostprocessing(0,i_alloy);} //knows to skip facet storage //setOnHullProperties(0,i_alloy);}
    }
  }else{
    message << "Entering default convex hull calculation (full-dimensional)";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
    cleanHull();
    prepareHullPoints();
    calculateFacets();
    message << "Hull calculated";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
  }
  storeHullData();  //that way, the largest dim facets get stored in m_facets!

  //resort within coord_groups to expose hull-members!
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    std::sort(m_coord_groups[i_coord_group].m_points.begin(),m_coord_groups[i_coord_group].m_points.end(),sortWithinCoordGroup(m_points,m_sort_energy_ascending));  //ascending order
  }
  if(LDEBUG){cerr << soliloquy << " done" << endl;}
}

void ConvexHull::cleanHull() {
  h_dim=0;
  m_elements_present.clear();
  h_points.clear();
  h_centroid.clear();
  h_reference.clear();
  h_facets.clear();
  h_visible_facets.clear();
  h_horizon_ridges.clear();
}

string ConvexHull::prettyPrintCompound(const ChullPoint& point,bool reduce,bool exclude1,char mode) const {  // overload
  if(!point.m_has_entry){
    string soliloquy="ConvexHull::prettyPrintCompound():";
    throw CHullLogicError(soliloquy,"No entry found");
  }
  return prettyPrintCompound(point.m_entry,reduce,exclude1,mode);
}

string ConvexHull::prettyPrintCompound(const aflowlib::_aflowlib_entry& entry,bool reduce,bool exclude1,char mode) const {  // overload
  if(entry.vspecies.size()!=entry.vcomposition.size()) {
    string soliloquy="ConvexHull::prettyPrintCompound():";
    stringstream message;
    message << "Entry (auid=" << entry.auid << ") is ill-defined: vspecies.size()!=vcomposition.size()";
    message << " (please report on AFLOW Forum: aflow.org/forum)";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
    return entry.compound;
  }
  return prettyPrintCompound(entry.vspecies,entry.vcomposition,reduce,exclude1,mode);
}

string ConvexHull::prettyPrintCompound(const vector<string>& vspecies,const vector<double>& vcomposition,bool reduce,bool exclude1,char mode) const {  // overload
  return prettyPrintCompound(vspecies,aurostd::vector2xvector<double>(vcomposition,0),reduce,exclude1,mode);
}

string ConvexHull::prettyPrintCompound(const vector<string>& vspecies,const xvector<double>& vcomposition,bool reduce,bool exclude1,char mode) const {  // main function
  // creates compound_label for LaTeX and text docs, like adding $_{}$
  // 2-D, we usually want reduce true for convex points, and off elsewhere
  string soliloquy = "chull::prettyPrintCompound():";
  uint precision=COEF_PRECISION;
  stringstream output;output.precision(precision);
  if(vspecies.size()!=(uint)vcomposition.rows) {throw CHullLogicError(soliloquy,"vspecies.size() != vcomposition.rows");}
  // special case, unary
  if(vspecies.size() == 1) {
    output << vspecies[0];
    if(!exclude1) {output << (reduce?1:vcomposition[0]);}
    return output.str();
  }
  xvector<double> comp=vcomposition;
  if(reduce){comp=aurostd::reduceByGCD(comp,ZERO_TOL);}
  if(abs(aurostd::sum(comp))<ZERO_TOL){throw CHullLogicError(soliloquy,"Empty composition");}
  for (uint i = 0; i < vspecies.size(); i++) {
    output << vspecies[i];
    if(!(exclude1 && aurostd::identical(comp[i],1.0,ZERO_TOL))) {
      if(mode==_latex_) {output << "$_{";
      }else if(mode==_gnuplot_){output<< "_{";}
      output << comp[i];
      if(mode==_latex_) {output << "}$";}
      else if(mode==_gnuplot_){output<< "}";}
    }
  }
  return output.str();
}

string ConvexHull::prettyPrintPrototype(const ChullPoint& point, bool double_back_slash) const {  // overload
  if(!point.m_has_entry){
    string soliloquy="ConvexHull::prettyPrintPrototype():";
    throw CHullLogicError(soliloquy,"No entry found");
  }
  return prettyPrintPrototype(point.m_entry,double_back_slash);
}

string ConvexHull::prettyPrintPrototype(const aflowlib::_aflowlib_entry& entry, bool double_back_slash) const {  // main function
// creates prototype_label for LaTeX ONLY, no use for this function otherwise
// escapes funny characters
  if(entry.prototype.empty()) {
    string soliloquy = "chull::prettyPrintPrototype():";
    stringstream message;
    message << "Entry (auid=" << entry.auid << ") is ill-defined: empty prototype";
    message << " (please report on AFLOW Forum: aflow.org/forum)";
    pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
    return entry.prototype;
  }
  bool fix_icsd_labels=true;
  string proto=entry.prototype;
  if(fix_icsd_labels&&aurostd::substring2bool(proto,"ICSD_")){
    vector<string> tokens;
    string string_to_fix;
    aurostd::string2tokens(proto,tokens,"_");
    if(tokens.size()==2){string_to_fix=tokens[1];} //aurostd::substring2bool(proto,"ICSD_")
    else if(tokens.size()==3&&aurostd::substring2bool(proto,"_ICSD_")){string_to_fix=tokens[2];}
    if(!string_to_fix.empty()){
      return "ICSD~\\#"+fixStringLatex(string_to_fix,double_back_slash,false);
    }
    //else, just leave alone
  }
  return fixStringLatex(proto,double_back_slash,false);
}

string ConvexHull::fixStringLatex(const string& input, bool double_back_slash,bool symmetry_string) const {
  // deals with special characters for LaTeX, like some characters in prototype
  // see http://tex.stackexchange.com/questions/34580/escape-character-in-latex
  // double_back_slash was needed SOMETIMES for gnuplot output, as one backslash
  // went away when writing to file, and  -- OBSOLETE NOW
  string soliloquy = "chull::fixStringLatex():";
  string output;
  vector<char> problem_characters;
  problem_characters.push_back('&');
  problem_characters.push_back('%');
  problem_characters.push_back('$');
  problem_characters.push_back('#');
  if(!symmetry_string) {
    problem_characters.push_back('_');
    problem_characters.push_back('{');
    problem_characters.push_back('}');
  }
  problem_characters.push_back('~');  // different fix
  problem_characters.push_back('^');  // different fix
  string solution_string;
  solution_string = "\\\\";  // has to be string, \\ char does not work
  bool found_escaped_char;
  bool found_hyphen_symmetry = false;
  bool solved_hyphen_symmetry = false;
  for (uint i = 0; i < input.length(); i++) {
    // we first enter this loop because symmetry_string and input[i]=='-'
    // second enter loop because symmetry_string and found_hyphen_symmetry
    if(symmetry_string && (input[i] == '-' || found_hyphen_symmetry)) {
      if(!found_hyphen_symmetry) {
        // first enter loop, come here
        found_hyphen_symmetry = true;
        output.append("\\overline{");
        // very important, we don't want to add hyphen, just replace
        // with overline, so continue
        continue;
      } else {
        // second enter loop, do nothing but turn this flag on
        // allow us to add input[i]
        found_hyphen_symmetry = false;
        solved_hyphen_symmetry = true;
      }
    } else {
      if(symmetry_string && solved_hyphen_symmetry) {
        // last step of symmetry_string fix, but we have to do this in part of
        // the loop to allow for next character to be identified as problem
        // character as well
        output.append(1, '}');
        solved_hyphen_symmetry = false;
      }
      // go through all problem characters
      for (uint j = 0; j < problem_characters.size(); j++) {
        if(input[i] == problem_characters[j]) {
          if(double_back_slash) {
            // if we find one, but it has double backslash, leave alone
            // doesn't matter what it is, if it has double backslash it's good
            // if we find one, but it only has single backslash, add one
            if(i && i - 1 && input.at(i - 1) == '\\' && input.at(i - 2) == '\\') {break;}
            else if(i && input.at(i - 1) == '\\') {
              output.append(1, '\\');  // just add one
              break;
            }
            // if we find one, give two backslashes
            output.append("\\\\");
            break;
          } else {
            // if we find one, but it has single backslash, leave alone
            // doesn't matter what it is, if it has single backslash it's good
            // if we find one, give single backslash
            if(i && input.at(i - 1) == '\\') {break;}  
            output.append(1, '\\');
            break;
          }
        }
      }
      // we also have to add {} for these characters
      if(input[i] == '~' || input[i] == '^') {output.append("{}");}
      found_escaped_char = false;
      if(input[i] == '\\') {
        for (uint j = 0; j < problem_characters.size(); j++) {
          // the only way this works if it's serving as an escape for a character
          // don't worry about double backslash here, we get to that when we find
          // the actual character
          if(i != (input.length() - 1) && input[i+1] == problem_characters[j]) {
            found_escaped_char = true;
            break;  // doesn't matter what it is, if it has backslash it's good
          }
        }
        // this is a problem, no way around it--we cannot output single backslash
        if(!found_escaped_char) {
          stringstream message;
          message << "Extraneous backslash found in \"" << input << "\" which may cause problems for LaTeX/gnuplot";
          pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_WARNING_);
          return input;
        }
      }
    }
    // add in character from input
    output.append(1, input[i]);
  }
  return output;
}

string ConvexHull::addHeaderStringLaTeX(char function_mode,bool display_color_gradient) const {
  // produces addplot latex string
  string soliloquy = "ConvexHull::addHeaderStringLaTeX():";
  stringstream message;
  stringstream addplot_output_ss;addplot_output_ss.str("");
  
  uint dimension=getDim();
  bool reverse_axes=DEFAULT_CHULL_LATEX_REVERSE_AXIS;

  // http://tex.stackexchange.com/questions/59070/pgfplots-remove-darker-borders-on-marks
  // this string WILL cause warnings when compiling, but it's correct, no way to
  // fix it with our current compiler
  stringstream tmp_dark_border_points_command;
  tmp_dark_border_points_command << "scatter/use mapped color={draw=black,fill=mapped color,solid}";

  string dark_border_points_command = tmp_dark_border_points_command.str();

  // first do a check that the function_mode is not out of scope
  if(dimension == 2) {
    if(function_mode != ADDPLOT_MODE_HULL_POINTS &&
        function_mode != ADDPLOT_MODE_OFF_HULL_POINTS &&
        function_mode != ADDPLOT_MODE_HULL_FACETS) {
      throw CHullLogicError(soliloquy,"Input dimension mode (2D) and function mode mismatch");
    }
    if(m_velements.size() != 2) {throw CHullLogicError(soliloquy,"Input dimension mode (2D) and elements.size() mismatch");}
  } else if(dimension == 3) {
    if(function_mode != ADDPLOT_MODE_HULL_POINTS &&
        function_mode != ADDPLOT_MODE_OFF_HULL_POINTS &&
        function_mode != ADDPLOT_MODE_HULL_FACETS &&
        function_mode != ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS &&
        function_mode != ADDPLOT_MODE_HEAT_MAPS) {
      throw CHullLogicError(soliloquy,"Input dimension mode (3D) and function mode mismatch");
    }
    if(m_velements.size() != 3) {throw CHullLogicError(soliloquy,"Input dimension mode (3D) and elements.size() mismatch");}
  } else {throw CHullLogicError(soliloquy,"Input dimension mode out of scope");}

  // main addplot function
  if(dimension == 2) {addplot_output_ss << "\\addplot+[" << endl;}
  else {  // dimension==3
    if(function_mode == ADDPLOT_MODE_HEAT_MAPS) {addplot_output_ss << "\\addplot3[" << endl;}
    else{addplot_output_ss << "\\addplot3+[" << endl;}
  }

  if(function_mode == ADDPLOT_MODE_HULL_FACETS ||
      function_mode == ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS) {
    addplot_output_ss << "mark=none," << endl;
    if(function_mode == ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS) {
      addplot_output_ss << "color=white," << endl;
      addplot_output_ss << "solid," << endl;
      addplot_output_ss << "line width=2.0pt," << endl;
    } else {  // function_mode==ADDPLOT_MODE_HULL_FACETS
      addplot_output_ss << "color=black," << endl;
      addplot_output_ss << "solid," << endl;
      if(dimension == 3) {addplot_output_ss << "line width=2pt," << endl;}
    }
    addplot_output_ss << "] table ";
    if(dimension == 2) {
      if(reverse_axes){addplot_output_ss << "[x=" << m_velements[0];}
      else{addplot_output_ss << "[x=" << m_velements[1];}
      if(m_formation_energy_hull) {addplot_output_ss << ",y=Hform";}
      else{addplot_output_ss << ",y=Ts";}
      addplot_output_ss << "]";
    } else {  // dimension==3
      addplot_output_ss << "[x=" << m_velements[1];
      addplot_output_ss << ",y=" << m_velements[0];
      addplot_output_ss << ",z=" << m_velements[2] << "]";  // flipping x and y
    }
  } else {  // function_mode==ADDPLOT_MODE_HULL_POINTS||function_mode==ADDPLOT_MODE_OFF_HULL_POINTS||function_mode==ADDPLOT_MODE_HEAT_MAPS
    if(function_mode == ADDPLOT_MODE_HEAT_MAPS) {
      addplot_output_ss << "patch," << endl;
      addplot_output_ss << "patch type=triangle," << endl;
      addplot_output_ss << "shader=interp," << endl;
    } else {
      addplot_output_ss << "only marks," << endl;  // IMPORTANT, no lines
      if(function_mode == ADDPLOT_MODE_HULL_POINTS) {
        addplot_output_ss << "mark=*," << endl;
        if(dimension == 2) {addplot_output_ss << "mark size=4," << endl;}
        else {  // dimension==3
          addplot_output_ss << "mark size=5," << endl;
          addplot_output_ss << "line width=2pt," << endl;
        }
      } else {  // function_mode==ADDPLOT_MODE_OFF_HULL_POINTS
        addplot_output_ss << "mark=x," << endl;
        addplot_output_ss << "mark options={scale=2,line width=2,solid";
      }
    }
    if(display_color_gradient || function_mode == ADDPLOT_MODE_HEAT_MAPS) {  
      // this OR statement doesn't practically matter, since one does not work without the other, 
      // but I keep it here so that the output of the string is complete
      if(function_mode == ADDPLOT_MODE_OFF_HULL_POINTS) {addplot_output_ss << "}," << endl;}
      if(m_formation_energy_hull) {
        addplot_output_ss << "point meta=\\thisrow{Hform}," << endl;  // uses point meta as color data
        addplot_output_ss << "nodes near coords*={}," << endl;  // no labels, but we need this for colors
        // GOT IT! // http://tex.stackexchange.com/questions/59070/pgfplots-remove-darker-borders-on-marks
        if(function_mode == ADDPLOT_MODE_HULL_POINTS) {addplot_output_ss << dark_border_points_command << "," << endl;}
        addplot_output_ss << "visualization depends on={\\thisrow{Hform} \\as \\Hform}," << endl;  // defines visualization dependency
      } else {
        addplot_output_ss << "point meta=\\thisrow{Ts}," << endl;  // uses point meta as color data
        addplot_output_ss << "nodes near coords*={}," << endl;  // no labels, but we need this for colors
        // GOT IT! // http://tex.stackexchange.com/questions/59070/pgfplots-remove-darker-borders-on-marks
        if(function_mode == ADDPLOT_MODE_HULL_POINTS) {addplot_output_ss << dark_border_points_command << "," << endl;}
        addplot_output_ss << "visualization depends on={\\thisrow{Ts} \\as \\Ts}," << endl;  // defines visualization dependency
      }
    } else {
      if(function_mode == ADDPLOT_MODE_HULL_POINTS) {addplot_output_ss << "mark options={draw=black,fill=blue,solid}," << endl;}
      else {addplot_output_ss << ",draw=red}," << endl;}// function_mode==ADDPLOT_MODE_OFF_HULL_POINTS
    }
    addplot_output_ss << "] table ";
    if(dimension == 2) {
      if(reverse_axes){addplot_output_ss << "[x=" << m_velements[0];}
      else{addplot_output_ss << "[x=" << m_velements[1];}
      if(m_formation_energy_hull) {addplot_output_ss << ",y=Hform";}
      else{addplot_output_ss << ",y=Ts";}
      addplot_output_ss << "]";
    } else {  // dimension==3
      addplot_output_ss << "[x=" << m_velements[1];
      addplot_output_ss << ",y=" << m_velements[0];
      addplot_output_ss << ",z=" << m_velements[2] << "]";  // flipping x and y
    }
  }
  addplot_output_ss << "{" << endl;
  for (uint i = 0; i < m_velements.size(); i++){addplot_output_ss << aurostd::PaddedPOST(m_velements[i], 30);}
  addplot_output_ss << aurostd::PaddedPOST("Hform", 30);
  addplot_output_ss << aurostd::PaddedPOST("Ts", 30);
  addplot_output_ss << aurostd::PaddedPOST("Dist2hull", 30);
  addplot_output_ss << endl;

  return addplot_output_ss.str();
}

string ConvexHull::addPointContentLaTeX(const ChullPoint& point,bool zero_end_point,bool zero_dist_2_hull) const {  //true,false
  string soliloquy = "ConvexHull::addPointContentLaTeX():";

  // initializations
  stringstream addplot_output_ss;
  // no precision
  stringstream num_ss;

  // explicit dimensions
  for (uint i = 0; i < (uint)point.s_coords.rows; i++) {
    addplot_output_ss << aurostd::PaddedPOST(aurostd::utype2string(point.s_coords[i],FULL_PRECISION), 30);
  }
  // enthalpy of formation, row 4
  // fix for unaries, set to 0
  if((zero_end_point && point.isUnary()) || !point.m_has_entry) {  // IMPORTANT, these must go through 0
    // no need for precision for next few columns, leave it same way as received from AFLOW
    addplot_output_ss << aurostd::PaddedPOST(0, 30); //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);
    // entropic temperature, row 5
    addplot_output_ss << aurostd::PaddedPOST(0, 30); //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);
  } else {
    // no need for precision for next few columns, leave it same way as received from AFLOW
    num_ss << chull::Hf_atom(point, _m_);
    addplot_output_ss << aurostd::PaddedPOST(num_ss.str(), 30);
    num_ss.str("");
    // entropic temperature, row 5
    num_ss << chull::Ts(point);
    addplot_output_ss << aurostd::PaddedPOST(num_ss.str(), 30);
    num_ss.str("");
  }
  // dist_2_hull, row 6
  if(zero_dist_2_hull) {addplot_output_ss << aurostd::PaddedPOST(0, 30);} //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);}
  else {addplot_output_ss << aurostd::PaddedPOST(aurostd::utype2string(chull::dist2Hull(point,_m_),CHULL_PRECISION), 30);}
  // end line
  addplot_output_ss << endl;
  return addplot_output_ss.str();
}

string ConvexHull::getNodeCoordPosition(const ChullPoint& point) const {
  if(!point.m_has_entry){
    string soliloquy="ConvexHull::getNodeCoordPosition():";
    throw CHullLogicError(soliloquy,"No entry found");
  }
  return getNodeCoordPosition(point.m_entry,point.m_coords);
}

string ConvexHull::getNodeCoordPosition(const aflowlib::_aflowlib_entry& entry,const xvector<double>& coord) const {
  // produces node latex output
  string soliloquy = "chull::getNodeCoordPosition():";
  stringstream message;

  double sum_C;
  stringstream output;
  // no precision
  stringstream num_ss;

  uint dimension=getDim();
  bool reverse_axes=DEFAULT_CHULL_LATEX_REVERSE_AXIS;

  // first do a check that the function_mode is not out of scope
  if(dimension == 2) {
    if(coord.rows != 2) {throw CHullLogicError(soliloquy,"Input dimension mode (2D) and coordinate size mismatch");}
  } else if(dimension == 3) {
    if(coord.rows != 3) {throw CHullLogicError(soliloquy,"Input dimension mode (3D) and coordinate size mismatch");}
  } else{throw CHullLogicError(soliloquy,"Input dimension mode out of scope");}

  output << "axis cs:";  // define axis as relevant "coordinate system"

  if(dimension == 2) {
    // don't need for loop, just 1 coord
    if(!reverse_axes) {output << aurostd::utype2string(1.0 - coord(0),FULL_PRECISION);}
    else {output << aurostd::utype2string(coord(0),FULL_PRECISION);}
    output << ",";
    if(m_formation_energy_hull) {
      num_ss << chull::Hf_atom(entry, _m_);
      output << num_ss.str();
      num_ss.str("");
    } else {
      num_ss << chull::Ts(entry);
      output << num_ss.str();
      num_ss.str("");
    }
  } else {  // dimension==3
    sum_C = 0.0;
    for(uint j=coord.rows-2; j<(uint)coord.rows;j--) {
      output << aurostd::utype2string(coord(j),FULL_PRECISION);
      output << ",";
      sum_C += coord(j);
    }
    output << aurostd::utype2string(1.0-sum_C,FULL_PRECISION);
  }
  return output.str();
}

string ConvexHull::nodeCreator(stringstream& option, stringstream& position, stringstream& content) const {
  string _option = option.str();
  string _position = position.str();
  string _content = content.str();
  option.str("");
  position.str("");
  content.str("");
  return nodeCreator(_option, _position, _content);
}

string ConvexHull::nodeCreator(const string& option, const string& position, const string& content) const {
  // produces node latex output
  stringstream output;
  output << "\\node ";
  if(!option.empty()) {output << "[" << option << "] ";}
  if(!position.empty()) {output << "at (" << position << ") ";}
  if(!content.empty()) {output << "{" << content << "};";}
  output << endl;
  return output.str();
}

bool ConvexHull::unwantedFacetLine(uint vi,uint vj,bool check_border) const {  //bool check_border = true;
  vector<vector<uint> > facet_lines;
  return unwantedFacetLine(vi, vj, facet_lines, check_border);
}

bool ConvexHull::unwantedFacetLine(uint vi,uint vj,vector<vector<uint> >& facet_lines,bool check_border) const {  //bool check_border = true;
  // checks if the facet created by this combination of chullPoints is necessary
  // for 3D hull
  bool LDEBUG = (FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::unwantedFacetLine():";
  if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
  if(vi>m_points.size()-1 || vj>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index within points");}
  if(check_border) {
    const ChullPoint& ci=m_points[vi];
    const ChullPoint& cj=m_points[vj];
    const xvector<double>& coordAR = ci.getTruncatedGenCoords();
    const xvector<double>& coordBR = cj.getTruncatedGenCoords();
    bool endpointA = ci.isUnary();
    bool endpointB = cj.isUnary();
    const aflowlib::_aflowlib_entry& entryA = ci.m_entry;
    const aflowlib::_aflowlib_entry& entryB = cj.m_entry;
    // unary to unary
    if(endpointA && endpointB) {
      if(LDEBUG) {cerr << soliloquy << " unary to unary" << endl;}
      return true;
    }
    // unary to binary, only if dot product of coords is not 0 (unary to crossing binary line)
    if(endpointA && entryB.vspecies.size() == 2 && scalar_product(coordAR, coordBR) >= ZERO_TOL) {
      if(LDEBUG) {cerr << soliloquy << " unary to binary" << endl;}
      return true;
    }
    // binary to unary, only if dot product of coords is not 0 (unary to crossing binary line)
    if(entryA.vspecies.size() == 2 && endpointB && scalar_product(coordAR, coordBR) >= ZERO_TOL) {
      if(LDEBUG) {cerr << soliloquy << " binary to unary" << endl;}
      return true;
    }
    // binary to binary, if same species
    if(entryA.vspecies.size() == 2 && entryA.vspecies == entryB.vspecies) {
      if(LDEBUG) {cerr << soliloquy << " binary to binary" << endl;}
      return true;
    }
  }
  // check that this combination is unique,
  // only pairs inside facet_lines!!!
  // chullPoints, so we're only interested in compositional components of
  // xvector, not the energy
  for (uint i = 0; i < facet_lines.size(); i++) {
    if(facet_lines[i][0]==vi && facet_lines[i][1]==vj){
      if(LDEBUG) {
        cerr << soliloquy << " found match! ";
        cerr << facet_lines[i][0] << "==" << vi;
        cerr << ", ";
        cerr << facet_lines[i][1] << "==" << vj;
        cerr << endl;
      }
      return true;
    }
    if(facet_lines[i][0]==vj && facet_lines[i][1]==vi){
      if(LDEBUG) {
        cerr << soliloquy << " found match! ";
        cerr << facet_lines[i][0] << "==" << vj;
        cerr << ", ";
        cerr << facet_lines[i][1] << "==" << vi;
        cerr << endl;
      }
      return true;
    }
  }
  facet_lines.push_back(vector<uint>(0));
  facet_lines.back().push_back(vi);
  facet_lines.back().push_back(vj);
  if(LDEBUG) {cerr << soliloquy << " saving facet lines: " << vi << "," << vj << endl;}
  return false;
}

void ConvexHull::writePDF() const {
  bool LDEBUG = (FALSE || XHOST.DEBUG);
  string soliloquy = "chull::ConvexHull::writePDF():";
  stringstream message;
  if(!aurostd::IsCommandAvailable("pdflatex")) {throw CHullRuntimeError(soliloquy,"\"pdflatex\" needs to be in your path");}
  message << "Starting LaTeX PDF generator";
  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

  //////////////////////////////////////////////////////////////////////////////
  // START Getting hull attributes
  //////////////////////////////////////////////////////////////////////////////

  uint dimension=getDim();
  vector<uint> hull_points=getHullPoints(false);
  bool draw_all_facet_lines=false;  //only draw uniques, keep FALSE
  bool include_equilibrium_phases=true; //keep true
  
  //USER INPUTS
  bool doc_only=m_cflags.flag("CHULL::DOC_ONLY");
  bool no_doc=m_cflags.flag("CHULL::NO_DOC");
  bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
  bool light_contrast=m_cflags.flag("CHULL::LIGHT_CONTRAST");
  bool large_font=m_cflags.flag("CHULL::LARGE_FONT");
  bool keep_tex=m_cflags.flag("CHULL::KEEP_TEX");
  bool show_latex_output=m_cflags.flag("CHULL::LATEX_OUTPUT");
  bool latex_interactive_mode=m_cflags.flag("CHULL::LATEX_INTERACTIVE");
  
  //FROM AFLOWRC
  bool print_aflow_logo=true;
  bool no_banner=(DEFAULT_CHULL_LATEX_BANNER==0);
  bool small_banner=(DEFAULT_CHULL_LATEX_BANNER==2);
  bool compounds_column_report=DEFAULT_CHULL_LATEX_COMPOUNDS_COLUMN;
  bool composition_header_report=DEFAULT_CHULL_LATEX_COMPOSITION_HEADER;
  bool plot_endpoints=DEFAULT_CHULL_LATEX_PLOT_ENDPOINTS;
  bool filter_by_z=(!DEFAULT_CHULL_LATEX_FILTER_SCHEME.empty() && (aurostd::toupper(DEFAULT_CHULL_LATEX_FILTER_SCHEME)[0]=='Z' || aurostd::toupper(DEFAULT_CHULL_LATEX_FILTER_SCHEME)[0]=='E'));
  bool filter_by_distance=(!DEFAULT_CHULL_LATEX_FILTER_SCHEME.empty() && aurostd::toupper(DEFAULT_CHULL_LATEX_FILTER_SCHEME)[0]=='D');
  double filter_cutoff=DEFAULT_CHULL_LATEX_FILTER_VALUE;
  
  int plot_off_hull_setting=DEFAULT_CHULL_LATEX_PLOT_OFF_HULL;     //does not include unstable
  bool plot_off_hull;
  if(plot_off_hull_setting==-1){plot_off_hull=(getDim()==2?true:false);}
  else{plot_off_hull=(plot_off_hull_setting==0?false:true);}
  if(filter_by_z||filter_by_distance){plot_off_hull=true;}

  bool plot_unstable=DEFAULT_CHULL_LATEX_PLOT_UNSTABLE;
  bool reverse_axes=DEFAULT_CHULL_LATEX_REVERSE_AXIS;
  
  bool display_color_gradient=DEFAULT_CHULL_LATEX_COLOR_GRADIENT;
  bool include_color_bar=DEFAULT_CHULL_LATEX_COLOR_BAR;
  bool show_heat_map=DEFAULT_CHULL_LATEX_HEAT_MAP;
  if(!display_color_gradient){
    include_color_bar=false;
    show_heat_map=false;
  }
  
  bool hull_drop_shadow=DEFAULT_CHULL_LATEX_FACET_LINE_DROP_SHADOW;  //gus paper
  
  string ternary_label_color_setting=DEFAULT_CHULL_LATEX_TERNARY_LABEL_COLOR;
  string ternary_label_color=(ternary_label_color_setting.empty()?"white":ternary_label_color_setting);
  if(hull_drop_shadow&&ternary_label_color=="white"){ternary_label_color="yellow";} //white doesn't work here
  if(!show_heat_map&&(ternary_label_color=="white"||ternary_label_color=="yellow")){ternary_label_color="black";} //white/yellow doesn't work here
  
  string color_map_setting=DEFAULT_CHULL_LATEX_COLOR_MAP;
  string color_map=(color_map_setting.empty()?"rgb(0pt)=(0,0,1); rgb(63pt)=(1,0.644,0)":color_map_setting);
  
  //links options
  int links_setting=DEFAULT_CHULL_LATEX_LINKS;
  bool kill_all_links=(links_setting==0);  //no links whatsoever
  bool no_links=(links_setting==2);        //no jumping
  bool no_hyperlinks=(links_setting==3);   //no weblinks
  if(image_only){kill_all_links=true;}
  if(kill_all_links){
    no_links=true;      //no jumping
    no_hyperlinks=true; //no weblinks
  }
  if(no_doc){no_links=true;}

  //labels options
  bool labels_off_hull=DEFAULT_CHULL_LATEX_LABELS_OFF_HULL;
  bool meta_labels=DEFAULT_CHULL_LATEX_META_LABELS;
  bool no_labels=false;
  bool compound_labels=true;  //default is to show compound labels only, for binaries this will be ground state dependent
  bool prototype_labels=(getDim()==2 && labels_off_hull); //default is to show prototype labels for binaries, with compounds labels on ground states for reference
  string label_options=DEFAULT_CHULL_LATEX_LABEL_NAME;
  bool plot_labels=(!label_options.empty());           //overarching flag, mostly for getting options
  if(plot_labels){
    compound_labels=prototype_labels=false; //kill defaults
    vector<string> vlabelstring;
    aurostd::string2tokens(label_options,vlabelstring, ",");
    for (uint i = 0; i < vlabelstring.size(); i++) {
      if(vlabelstring[i][0] == 'B' || vlabelstring[i][0] == 'b') {  // both
        compound_labels=true;
        prototype_labels=true;
        no_labels=false;
        break;
      } else if(vlabelstring[i][0] == 'N' || vlabelstring[i][0] == 'n' || vlabelstring[i][0] == 'O' || vlabelstring[i][0] == 'o') {  // none,off
        compound_labels=false;
        prototype_labels=false;
        meta_labels=false;
        no_labels=true;
        break;
      } else if(vlabelstring[i][0] == 'C' || vlabelstring[i][0] == 'c') {  // compound
        compound_labels=true;
        no_labels=false;
      } else if(vlabelstring[i][0] == 'P' || vlabelstring[i][0] == 'p') {  // prototype
        prototype_labels=true;
        no_labels=false;
      } else {throw CHullLogicError(soliloquy,"Incorrect input for plot labels \""+vlabelstring[i]+"\"");}
    }
  }
  if(labels_off_hull){
    plot_off_hull=true;
    no_labels=false;
  }
  if(meta_labels){no_labels=false;}

  int plot_reduce_composition_setting=DEFAULT_CHULL_LATEX_PLOT_REDUCE_COMPOSITION;
  bool plot_reduce_composition;
  if(plot_reduce_composition_setting==-1){plot_reduce_composition=(!(getDim()==2&&compound_labels&&plot_labels));}
  else{plot_reduce_composition=(plot_reduce_composition_setting==0?false:true);}
  if(plot_reduce_composition){no_labels=false;}
  bool helvetica_font=DEFAULT_CHULL_LATEX_HELVETICA_FONT;
  string font_size=DEFAULT_CHULL_LATEX_FONT_SIZE;
  bool rotate_labels=DEFAULT_CHULL_LATEX_ROTATE_LABELS;
  if(rotate_labels){no_labels=false;}

  bool bold_labels=DEFAULT_CHULL_LATEX_BOLD_LABELS;
  
  //override with user inputs
  if(light_contrast){color_map="rgb(0pt)=(0.035,0.270,0.809); rgb(63pt)=(1,0.644,0)";}
  if(large_font) {
    if(helvetica_font) {font_size="huge";}
    else {font_size="Large";}
  } else {font_size="large";} //safely, I can do large


  //////////////////////////////////////////////////////////////////////////////
  // START Getting hull attributes
  //////////////////////////////////////////////////////////////////////////////

  if(dimension>3) {
    doc_only=true;
    message << "CHULL::DOC_ONLY set to TRUE (dimension>3)";
    pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
  }

  // initializing stringstreams to use
  stringstream doc_header_TEX_ss, _doc_header_TEX_ss;               // latex header commands
  stringstream tikzpic_settings_TEX_ss,_tikzpic_settings_TEX_ss;    // settings in tikzpic
  stringstream tikzpic_TEX_ss;                         // tikzpicture commands
  stringstream convex_hull_facets_TEX_ss;              // never empty
  stringstream convex_hull_vertices_TEX_ss;            // never empty
  stringstream convex_hull_facets_drop_shadow_TEX_ss;  // never empty
  stringstream common_settings_TEX_ss;                    // use for common settings to reduce redundancy
  stringstream unary_label_TEX_ss;               // unary tikzpicture label commands
  stringstream heat_map_TEX_ss;                  // heatmap stuff
  stringstream points_data_ss, _points_data_ss;  // points commands
  stringstream labels_data_ss;
  stringstream report_data_ss, _report_data_ss;
  stringstream equilibrium_phases_TEX_ss;
  stringstream equilibrium_phases_header_TEX_ss;
  stringstream reaction_chem_eq_TEX_ss;
  stringstream main_TEX_ss;
  stringstream node_option_ss;
  stringstream node_position_ss;
  stringstream node_content_ss;
  stringstream misc_ss;
  // no precision
  stringstream num_ss;

  // initializing some strings
  string main_TEX_file, main_PDF_file;
  string main_file;
  string input;

  // creating name of output file
  input=aurostd::joinWDelimiter(m_velements,"");
  main_file="aflow_"+input+"_hull";
  if(image_only) {main_TEX_file = main_file + "_IMAGEONLY.tex";}
  else{main_TEX_file = main_file + ".tex";}
  main_PDF_file = main_file + ".pdf";
  string aflow_logo_file = "aflow_logo.pdf";

  // other initialization
  uint plot_points_count;                // points to put on ternary plot
  uint plot_points_count_no_end_points;  // mostly for count purposes
  vector<uint> chull_points;
  double min_point = 0.0, max_point = 0.0, z_range = 0.0;  // saves min/max energy value to determine if we can
  // have a colorbar
  double z_filter_cutoff, dist_filter_cutoff;
  string plot_command;
  string output_name;
  string misc;
  vector<string> files_2_move, sg_tokens;
  stringstream command;
  uint num_horizontal_planes = 0;  // to determine whether or not we should have heatmaps
  uint count_entries = 0;

  //////////////////////////////////////////////////////////////////////////////
  // START Document header
  //////////////////////////////////////////////////////////////////////////////

  doc_header_TEX_ss << "\\documentclass[12pt]{article}" << endl;
  doc_header_TEX_ss << "\\usepackage[utf8x]{inputenc}" << endl;
  doc_header_TEX_ss << "\\usepackage[table]{xcolor}" << endl;
  if(helvetica_font) {
    doc_header_TEX_ss << "\\usepackage[scaled]{helvet}" << endl;
    doc_header_TEX_ss << "\\renewcommand\\familydefault{\\sfdefault}" << endl;
    doc_header_TEX_ss << "\\usepackage{sansmath}" << endl;
    doc_header_TEX_ss << "\\sansmath" << endl; //enable sans-serif math for rest of document
  }
  doc_header_TEX_ss << "\\usepackage[T1]{fontenc}" << endl;  // accents https://tex.stackexchange.com/questions/664/why-should-i-use-usepackaget1fontenc
  doc_header_TEX_ss << "\\usepackage{anyfontsize}" << endl;  // arbitrary font sizes
  doc_header_TEX_ss << "\\usepackage{lmodern}" << endl;  // high quality fonts
  if(image_only || no_doc) {doc_header_TEX_ss << "\\usepackage[margin=0cm]{geometry}" << endl;}
  else{
    // geometry package
    doc_header_TEX_ss << "\\usepackage[includeheadfoot,headheight=";
    //if(XHOST.hostname == "aflowlib.mems.duke.edu" &&
    if(print_aflow_logo) {doc_header_TEX_ss << "70pt";}
    else{doc_header_TEX_ss << "40pt";}
    doc_header_TEX_ss << ",headsep=0.1in,top=0.5in,bottom=0.75in,left=0.5in,right=0.5in,footskip=0.5in]{geometry}" << endl;
    // geometry package
    if(!no_doc) {
      doc_header_TEX_ss << "\\usepackage{longtable}" << endl;
      doc_header_TEX_ss << "\\usepackage{tabu}" << endl;
      doc_header_TEX_ss << "\\usepackage{booktabs} \%midrule and toprule" << endl;
      //http://tex.stackexchange.com/questions/167948/package-rerunfilecheck-warning-file-out-has-changed
      doc_header_TEX_ss << "\\usepackage{fancyhdr} \%column header" << endl;
      doc_header_TEX_ss << "\\usepackage{multirow} \%column header" << endl;
    }
  }
  if(!kill_all_links) {
    doc_header_TEX_ss << "\\usepackage{hyperref} \\hypersetup{colorlinks=true,citecolor=blue,linkcolor=blue,urlcolor=blue}" << endl;
    doc_header_TEX_ss << "\\usepackage{bookmark} \%hyperref without .out" << endl;
  }

  // things to add later, depending on we include hull image on first page
  _doc_header_TEX_ss << "\\begin{document}" << endl;
  // BEAUTIFUL SOLUTION to use links with labels
  if(!plot_endpoints &&!no_doc) {
    _doc_header_TEX_ss << "\\newcommand{\\hyperrefTitle}[2]{\\hyperref[#1]{#2}} \%we need this because axis doesn't like []" << endl;
  }

  //////////////////////////////////////////////////////////////////////////////
  // END Document header (for now)
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // START Get count_entries
  //////////////////////////////////////////////////////////////////////////////

  count_entries=getEntriesCount();

  //////////////////////////////////////////////////////////////////////////////
  // END Get count_entries
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // START Image on first page
  //////////////////////////////////////////////////////////////////////////////

  if(!doc_only && (dimension == 2 || dimension == 3)) {
    ////////////////////////////////////////////////////////////////////////////
    // START More header commands specific to tikz pic
    ////////////////////////////////////////////////////////////////////////////

    doc_header_TEX_ss << "\\usepackage{pgfplots}" << endl;
    doc_header_TEX_ss << "\\usepackage{pdflscape}" << endl;
    doc_header_TEX_ss << "\\pgfplotsset{compat=1.10}" << endl;
    doc_header_TEX_ss << "\\usepgfplotslibrary{ternary,units}" << endl;
    doc_header_TEX_ss << "\\usetikzlibrary{decorations.pathmorphing,pgfplots.units,backgrounds}" << endl;
    doc_header_TEX_ss << "\\usepackage[yyyymmdd,hhmmss]{datetime}" << endl;
    doc_header_TEX_ss << "\\usepackage{tikz}" << endl;
    doc_header_TEX_ss << "\\usetikzlibrary{positioning}" << endl;

    if(dimension == 3) {
      doc_header_TEX_ss << "\\usetikzlibrary{pgfplots.ternary}" << endl;
    }
    if(image_only) {
      doc_header_TEX_ss << "\\pgfrealjobname{CHull}" << endl;  // dummy name
    }
    doc_header_TEX_ss << "\\pgfdeclarelayer{background}" << endl;
    doc_header_TEX_ss << "\\pgfdeclarelayer{foreground}" << endl;
    doc_header_TEX_ss << "\\pgfsetlayers{background,main,foreground}" << endl;
    doc_header_TEX_ss << _doc_header_TEX_ss.str();
    _doc_header_TEX_ss.str("");  // don't repeat
    if(image_only) {
      doc_header_TEX_ss << "\\beginpgfgraphicnamed{aflow_" << input << "_hull}" << endl;
    } else {
      if(!no_doc) {doc_header_TEX_ss << "\\newgeometry{margin=0cm}" << endl;}
      doc_header_TEX_ss << "\\thispagestyle{empty}" << endl;
      doc_header_TEX_ss << "\\begin{landscape}" << endl;
      doc_header_TEX_ss << "\\centering" << endl;
      doc_header_TEX_ss << "{" << endl;
      doc_header_TEX_ss << "\\topskip0pt" << endl;
      doc_header_TEX_ss << "\\vspace*{\\fill}" << endl;
    }

    ////////////////////////////////////////////////////////////////////////////
    // END More header commands specific to tikz pic
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // START Z and DIST filter
    ////////////////////////////////////////////////////////////////////////////

    // we need to handle filters first, so we can test to see if a colorbar is
    // possible
    if(filter_by_z || !plot_unstable) {
      z_filter_cutoff = 0.0;  //default
      if(filter_by_z) {
        z_filter_cutoff = filter_cutoff;
        //let's automatically override plot_unstable if z_filter_cutoff is set appropriately
        bool plot_unstable_old=plot_unstable;
        if(m_formation_energy_hull){if(z_filter_cutoff > 0.0){plot_unstable=true;}}
        else{if(z_filter_cutoff < 0.0){plot_unstable=true;}}
        if(plot_unstable_old!=plot_unstable){
          message << "CHULL::PLOT_UNSTABLE set to TRUE, z_filter_cutoff=" << z_filter_cutoff;
          pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        }
        //[OBSOLETE CO 180227]if(!plot_unstable) {
        //[OBSOLETE CO 180227]  if(m_formation_energy_hull){if(z_filter_cutoff > 0.0){z_filter_cutoff = 0.0;}}
        //[OBSOLETE CO 180227]  else{if(z_filter_cutoff < 0.0){z_filter_cutoff = 0.0;}}
        //[OBSOLETE CO 180227]}
      }//[OBSOLETE CO 180227]else{z_filter_cutoff = 0.0;}
      if(LDEBUG) {cerr << soliloquy << " z_filter_cutoff=" << z_filter_cutoff << endl;}
    }
    if(filter_by_distance) {
      dist_filter_cutoff = filter_cutoff; 
      if(LDEBUG) {cerr << soliloquy << " DIST dist_filter_cutoff=" << dist_filter_cutoff << endl;}
      if((abs(dist_filter_cutoff)<ZERO_TOL) && plot_off_hull) {
        plot_off_hull=false;
        message << "CHULL::OFF_HULL set to FALSE, filter_by_distance=0.0";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      }
    }

    ////////////////////////////////////////////////////////////////////////////
    // END Z and DIST filter
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // START Gathering points for plotting
    ////////////////////////////////////////////////////////////////////////////

    vector<uint> plot_points;
    plot_points_count = 0;
    plot_points_count_no_end_points = 0;
    uint i_point;
    // no way to avoid this, we need to figure out if we can have a colorbar before
    // we go through the rest of the loops
    // so let's avoid double filtering, do it once and store to plot_points
    
    bool point_added;
    bool unary_g_state_unstable=false;  //the only way this is true is if we plot the unary g_state and it's unstable
    for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
      point_added=false;
      for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size()&&!(dimension==3&&point_added);i++){  //we only add one point per coordgroup for 3D
        i_point=m_coord_groups[i_coord_group].m_points[i];
        const ChullPoint& point=m_points[i_point];
        if(!point.m_has_entry){continue;}
        if(!plot_endpoints && point.isUnary()){continue;}
        if(!plot_off_hull && !point.m_is_g_state){continue;}  //if point.isUnary() and it gets here, only pass g-state
        if(!point.m_is_g_state){
          if(filter_by_z || !plot_unstable) {
            if(m_formation_energy_hull) {
              if(chull::Hf_atom(point, _m_) > z_filter_cutoff) {
                if(filter_by_z) {
                  message << "Excluding entry " << point.m_entry.auid;
                  message << " with H_form = " << chull::Hf_atom(point, _m_);
                  message << " (meV/atom) from plot";
                  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_,!filter_by_z);  // too much output to screen
                }
                continue;
              }
            } else {
              if(chull::Ts(point) < z_filter_cutoff) {
                if(filter_by_z) {
                  message << "Excluding entry " << point.m_entry.auid;
                  message << " with Ts = " << chull::Ts(point);
                  message << " (K) from plot";
                  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_,!filter_by_z);  // too much output to screen
                }
                continue;
              }
            }
          }
          if(filter_by_distance) {
            if(m_formation_energy_hull) {
              if(chull::dist2Hull(point, _m_) > dist_filter_cutoff) {
                message << "Excluding entry " << point.m_entry.auid;
                message << " with enthalpy_formation_atom_difference = " << aurostd::utype2string(chull::dist2Hull(point,_m_),CHULL_PRECISION);
                message << " (meV/atom) from plot";
                pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);  // too much output to screen
                continue;
              }
            } else {
              if(chull::dist2Hull(point, _std_) < dist_filter_cutoff) {
                message << "Excluding entry " << point.m_entry.auid;
                message << " with entropic_temperature_difference = " << aurostd::utype2string(chull::dist2Hull(point),CHULL_PRECISION);
                message << " (K) from plot";
                pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);  // too much output to screen
                continue;
              }
            }
          }
        }
        if(point.getLastCoord()<min_point){min_point=point.getLastCoord();}
        if(point.getLastCoord()>max_point){max_point=point.getLastCoord();}
        if(point.isUnary()){
          if(m_formation_energy_hull) {if(chull::Hf_atom(point, _m_) > z_filter_cutoff) {unary_g_state_unstable=true;}}
          else{if(chull::Ts(point) < z_filter_cutoff) {unary_g_state_unstable=true;}}
        }else{plot_points_count_no_end_points++;}
        plot_points_count++;
        plot_points.push_back(i_point);
        point_added=true;
      }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // END Gathering points for plotting
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // START Determining if points range enough to have color/heat map
    // functionality
    ////////////////////////////////////////////////////////////////////////////

    if(m_formation_energy_hull) {
      min_point = chull::convertUnits(min_point, _m_);
      max_point = chull::convertUnits(max_point, _m_);
    }
    z_range = max_point - min_point;
    if(LDEBUG) {
      cerr << soliloquy << " range" << endl;
      cerr << soliloquy << " max:     " << max_point << endl;
      cerr << soliloquy << " min:     " << min_point << endl;
      cerr << soliloquy << " z_range: " << z_range << endl;
    }

    // range functionality
    // http://tex.stackexchange.com/questions/69248/set-ticklabels-for-colorbar

    if(dimension == 2) {
      include_color_bar=false;
      message << "CHULL::COLOR_BAR set to FALSE (dimension==2)";
      pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      
      show_heat_map=false;
      message << "CHULL::HEAT_MAP set to FALSE (dimension==2)";
      pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
    }
    // determine whether we can have a colorbar
    if((!plot_points_count || (dimension == 3 && !plot_points_count_no_end_points)) || (abs(z_range) < ZERO_TOL)) {
      include_color_bar=false;
      show_heat_map=true;
      display_color_gradient=false;
      if(LDEBUG) {
        cerr << soliloquy << " plot points count = " << plot_points_count << endl;
        cerr << soliloquy << " plot points count no end points = " << plot_points_count_no_end_points << endl;
      }
      if(!plot_points_count) {
        message << "CHULL::COLOR_BAR set to FALSE, no entries found";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        message << "CHULL::COLOR_GRADIENT set to FALSE, no entries found";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        message << "CHULL::HEAT_MAP set to FALSE, no entries found";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      }else if(!plot_points_count_no_end_points) {
        message << "CHULL::COLOR_BAR set to FALSE, no non-unary entries found";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        message << "CHULL::COLOR_GRADIENT set to FALSE, no non-unary entries found";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        message << "CHULL::HEAT_MAP set to FALSE, no non-unary entries found";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      }
      if(abs(z_range)<ZERO_TOL) {
        message << "CHULL::COLOR_BAR set to FALSE, hull has no depth";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        message << "CHULL::NO_COLOR_GRADIENT set to TRUE, hull has no depth";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        message << "CHULL::HEAT_MAP set to FALSE, hull has no depth";
        pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      }
    }

    ////////////////////////////////////////////////////////////////////////////
    // END Determining if points range enough to have color/heat map
    // functionality
    ////////////////////////////////////////////////////////////////////////////

    // doc_header_TEX_ss ends here, we need to get data first, see
    // unary_label_TEX_ss (hrefs)

    ////////////////////////////////////////////////////////////////////////////
    // START Tikz pic settings
    ////////////////////////////////////////////////////////////////////////////

    //_tikzpic_settings_TEX_ss comes before tikzpic_TEX_ss
    if(image_only) {_tikzpic_settings_TEX_ss << "\\begin{tikzpicture}[font=\\Huge";}
    else {_tikzpic_settings_TEX_ss << "\\begin{tikzpicture}[font=\\Large";}
    _tikzpic_settings_TEX_ss << "]";
    _tikzpic_settings_TEX_ss << endl;
    // end of _tikzpic_settings_TEX_ss, we need to get data first, see
    // unary_label_TEX_ss (hrefs)
    // common settings between two axes
    bool set_max_tic_spacing_2D=true;  //CO 180227
    double ymin2D=-ZERO_RANGE_TOL;
    double ymax2D=ZERO_RANGE_TOL;
    if(dimension==2){
      if((!plot_points_count) || (abs(z_range) < ZERO_RANGE_TOL)) {
        set_max_tic_spacing_2D=false;  //CO 180227
        ymin2D=-ZERO_RANGE_TOL;
        ymax2D=ZERO_RANGE_TOL;
        //[OBSOLETE CO 180227]common_settings_TEX_ss << "ymin=" << -ZERO_RANGE_TOL << "," << endl;
        //[OBSOLETE CO 180227]common_settings_TEX_ss << "ymax=" << ZERO_RANGE_TOL << "," << endl;
      } else {
        // easier to figure out ranges in meV, stays meV
        double order_of_mag = pow(10, (ceil(log10(z_range)) - 1.0)) / 2.0;  // 1 for 10, 10 for 100, 100 for 1000
        if(LDEBUG) {
          cerr << soliloquy << " z_range                                        = " << z_range << endl;
          cerr << soliloquy << " min_point                                      = " << min_point << endl;
          cerr << soliloquy << " max_point                                      = " << max_point << endl;
          cerr << soliloquy << " order_of_mag                                   = " << order_of_mag << endl;
          cerr << soliloquy << " roundDouble(min_point, order_of_mag, false)    = " << roundDouble(min_point, order_of_mag, false) << endl;
          cerr << soliloquy << " roundDouble(max_point, order_of_mag, true)     = " << roundDouble(max_point, order_of_mag, true) << endl;
          cerr << soliloquy << " roundDouble((z_range)*0.2, order_of_mag, true) = " << roundDouble((z_range)*0.2, order_of_mag, true) << endl;
          //cerr << soliloquy << " log(z_range)         = " << log10(z_range) << endl;
        }
        // between lowest label and bottom line, increase if need more
        // we might have hull endpoints higher than 0
        if(!m_formation_energy_hull && !(plot_endpoints && unary_g_state_unstable) && (!plot_unstable || abs(min_point) < ZERO_TOL)) {
          ymin2D=0;
          //[OBSOLETE CO 180227]common_settings_TEX_ss << "ymin=" << 0 << "," << endl;
        } else {
          //[OBSOLETE CO 180227]common_settings_TEX_ss << "ymin=";
          ymin2D=roundDouble(min_point, order_of_mag, false);
          if(m_formation_energy_hull){ymin2D-=roundDouble((z_range)*0.2, order_of_mag, true);}  //CO 180227 - we need to avoid labels here, 0.2 should be enough spacing
          //[OBSOLETE CO 180227]common_settings_TEX_ss << ymin << "," << endl;
        }
        // between highest label and top line, increase if need more
        // we might have hull endpoints higher than 0
        if(m_formation_energy_hull && !(plot_endpoints && unary_g_state_unstable) && (!plot_unstable || abs(max_point) < ZERO_TOL)) {
          ymax2D=0;
          //[OBSOLETE CO 180227]common_settings_TEX_ss << "ymax=" << 0 << "," << endl;
        } else {
          //[OBSOLETE CO 180227]common_settings_TEX_ss << "ymax=";
          ymax2D=roundDouble(max_point, order_of_mag, true);
          if(!m_formation_energy_hull){ymax2D+=roundDouble((z_range)*0.2, order_of_mag, true);} //CO 180227 - we need to avoid labels here, 0.2 should be enough spacing
          //[OBSOLETE CO 180227]common_settings_TEX_ss << ymax << "," << endl;
        }
      }
      common_settings_TEX_ss << "ymin=" << ymin2D << "," << endl;
      common_settings_TEX_ss << "ymax=" << ymax2D << "," << endl;
    }
    common_settings_TEX_ss << "clip=false," << endl;  // for labels
    common_settings_TEX_ss << "width=";
    if(dimension == 2) {common_settings_TEX_ss << 21;}
    else {  // dimension==3
      if(include_color_bar) {
        if(image_only) {common_settings_TEX_ss << 21;}
        else{common_settings_TEX_ss << 20;}  // only time we change size
      }else{common_settings_TEX_ss << 21;}
    }
    common_settings_TEX_ss << "cm," << endl;
    if(dimension == 2) {
      if(image_only) {common_settings_TEX_ss << "height=0.8\\hsize," << endl;}
      else {common_settings_TEX_ss << "height=0.6\\hsize," << endl;}
    } else {
      common_settings_TEX_ss << "height=\\hsize," << endl;
      common_settings_TEX_ss << "axis line style={line width=3pt}," << endl;
    }
    common_settings_TEX_ss << "grid=none," << endl;
    common_settings_TEX_ss << "axis on top," << endl;  // prevents heat map overlap issues

    ////////////////////////////////////////////////////////////////////////////
    // START Axis
    ////////////////////////////////////////////////////////////////////////////

    uint g_state;
    if(dimension == 2) {
      uint top_axis_point, bottom_axis_point;
      if(!reverse_axes) {
        top_axis_point = 0;
        bottom_axis_point = 1;
      } else {
        top_axis_point = 1;
        bottom_axis_point = 0;
      }
      // put top axis first, bunch up with unaryLabel since it goes first
      unary_label_TEX_ss << "\\begin{axis}[" << endl;
      unary_label_TEX_ss << "xlabel={\\fontsize{25}{30}\\selectfont{";
      g_state=getUnaryGState(top_axis_point);
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {
          unary_label_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}{";
        } else if(no_doc && !no_hyperlinks) {
          unary_label_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}{";
        }
      }
      unary_label_TEX_ss << m_velements.at(top_axis_point) << "}";
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {unary_label_TEX_ss << "}";}
        else if(no_doc && !no_hyperlinks) {unary_label_TEX_ss << "}";}
      }
      unary_label_TEX_ss << "}," << endl;
      //add "max space between ticks=60" to change colorbar tick density
      unary_label_TEX_ss << "xticklabel shift=6pt," << endl;
      unary_label_TEX_ss << "yticklabel shift=6pt," << endl;
      unary_label_TEX_ss << "axis x line*=top," << endl;
      unary_label_TEX_ss << "axis y line*=right," << endl;
      unary_label_TEX_ss << "x dir=reverse," << endl;
      unary_label_TEX_ss << "xmin=0," << endl;
      unary_label_TEX_ss << "xmax=1," << endl;
      unary_label_TEX_ss << "xtick={1,0.8,0.6,0.4,0.2,0}," << endl;
      unary_label_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5";
      if(set_max_tic_spacing_2D){unary_label_TEX_ss << ",max space between ticks=" << int(abs(ymax2D-ymin2D)/4);}  //CO 180227, lower to get fewer tics
      unary_label_TEX_ss << "}," << endl;
      unary_label_TEX_ss << "scaled y ticks=false," << endl;
      // insert common settings
      unary_label_TEX_ss << common_settings_TEX_ss.str();
      unary_label_TEX_ss << "]" << endl;
      unary_label_TEX_ss << "\\end{axis}" << endl;
      // real axis
      unary_label_TEX_ss << "\\begin{axis}[" << endl;
      unary_label_TEX_ss << "xlabel={\\fontsize{25}{30}\\selectfont{";
      g_state=getUnaryGState(bottom_axis_point);
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {
          unary_label_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}{";
        } else if(no_doc && !no_hyperlinks) {
          unary_label_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}{";
        }
      }
      unary_label_TEX_ss << m_velements.at(bottom_axis_point) << "}";
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {unary_label_TEX_ss << "}";}
        else if(no_doc && !no_hyperlinks) {unary_label_TEX_ss << "}";}
      }
      unary_label_TEX_ss << "}," << endl;
      unary_label_TEX_ss << "ylabel={\\fontsize{25}{30}\\selectfont";
      if(m_formation_energy_hull) {unary_label_TEX_ss << "{formation enthalpy (meV/atom)}";}
      else{unary_label_TEX_ss << "{entropic temperature (K)}";}
      unary_label_TEX_ss << "}," << endl;
      //add "max space between ticks=60" to change colorbar tick density
      unary_label_TEX_ss << "xticklabel shift=6pt," << endl;
      unary_label_TEX_ss << "yticklabel shift=6pt," << endl;
      unary_label_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5";
      if(set_max_tic_spacing_2D){unary_label_TEX_ss << ",max space between ticks=" << int(abs(ymax2D-ymin2D)/4);}  //CO 180227, lower to get fewer tics
      unary_label_TEX_ss << "}," << endl;
      unary_label_TEX_ss << "scaled y ticks=false," << endl;
    } else {  // dimension==3
      unary_label_TEX_ss << "\\begin{ternaryaxis}[" << endl;
      // Ylabel
      unary_label_TEX_ss << "ylabel={\\fontsize{35}{40}\\selectfont{";  // flipping x and y
      g_state=getUnaryGState(0);
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {
          unary_label_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}{";
        } else if(no_doc && !no_hyperlinks) {
          unary_label_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}{";
        }
      }
      unary_label_TEX_ss << m_velements[0] << "}";
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {unary_label_TEX_ss << "}";}
        else if(no_doc && !no_hyperlinks) {unary_label_TEX_ss << "}";}
      }
      unary_label_TEX_ss << "}," << endl;
      unary_label_TEX_ss << "ylabel style={at={(axis cs:0,1,0)},anchor=north east,below=0.5cm,left=0.5cm}," << endl;
      // Xlabel
      unary_label_TEX_ss << "xlabel={\\fontsize{35}{40}\\selectfont{";  // flipping x and y
      g_state=getUnaryGState(1);
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {
          unary_label_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}{";
        } else if(no_doc && !no_hyperlinks) {
          unary_label_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}{";
        }
      }
      unary_label_TEX_ss << m_velements[1] << "}";
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {unary_label_TEX_ss << "}";}
        else if(no_doc && !no_hyperlinks) {unary_label_TEX_ss << "}";}
      }
      unary_label_TEX_ss << "}," << endl;
      unary_label_TEX_ss << "xlabel style={at={(axis cs:1,0,0)},anchor=south,above=0.7071cm}," << endl;
      // Zlabel
      unary_label_TEX_ss << "zlabel={\\fontsize{35}{40}\\selectfont{";  // flipping x and y
      g_state=getUnaryGState(2);
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {
          unary_label_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}{";
        } else if(no_doc && !no_hyperlinks) {
          unary_label_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}{";
        }
      }
      unary_label_TEX_ss << m_velements[2] << "}";
      if(!plot_endpoints && isViableGState(g_state)) {
        if(!no_links) {unary_label_TEX_ss << "}";}
        else if(no_doc && !no_hyperlinks) {unary_label_TEX_ss << "}";}
      }
      unary_label_TEX_ss << "}," << endl;
      unary_label_TEX_ss << "zlabel style={at={(axis cs:0,0,1)},anchor=north west,below=0.5cm,right=0.5cm}," << endl;
    }
    // tikzpic_settings_TEX starts here
    tikzpic_settings_TEX_ss << "xmin=0," << endl;
    tikzpic_settings_TEX_ss << "xmax=1," << endl;
    if(dimension == 2) {
      tikzpic_settings_TEX_ss << "xtick={1,0.8,0.6,0.4,0.2,0}," << endl;
      tikzpic_settings_TEX_ss << "axis x line*=bottom," << endl;
    } else {  // dimension==3
      tikzpic_settings_TEX_ss << "ymin=0," << endl;
      tikzpic_settings_TEX_ss << "ymax=1," << endl;
      tikzpic_settings_TEX_ss << "zmin=0," << endl;
      tikzpic_settings_TEX_ss << "zmax=1," << endl;
      tikzpic_settings_TEX_ss << "ticks=none," << endl;
    }
    tikzpic_settings_TEX_ss << common_settings_TEX_ss.str();

    ////////////////////////////////////////////////////////////////////////////
    // END Tikz pic settings
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // START Colorbar settings
    ////////////////////////////////////////////////////////////////////////////

    // won't enter if dimension==2, colorbar automatically turned off
    // start colorbar
    // http://tex.stackexchange.com/questions/73025/how-to-change-label-and-ticks-of-a-pgfplots-colorbar
    if(display_color_gradient) {
      if(include_color_bar) {
        tikzpic_settings_TEX_ss << "colorbar," << endl;
        tikzpic_settings_TEX_ss << "colorbar style={" << endl;
        if(m_formation_energy_hull) {
          tikzpic_settings_TEX_ss << "ylabel=formation enthalpy (meV/atom)," << endl;
        } else {
          tikzpic_settings_TEX_ss << "ylabel=entropic temperature (K)," << endl;
        }
        tikzpic_settings_TEX_ss << "ylabel style={font=\\LARGE},";
        // ytick={18,20,25,...,45}
        tikzpic_settings_TEX_ss << "yticklabel style={font=\\LARGE,/pgf/number format/fixed,/pgf/number format/precision=5}," << endl;
        tikzpic_settings_TEX_ss << "yticklabel shift=6pt," << endl;
        tikzpic_settings_TEX_ss << "scaled y ticks=false," << endl;
        tikzpic_settings_TEX_ss << "}," << endl;
      }
      // end colorbar
      tikzpic_settings_TEX_ss << "colormap={mymap}{" << color_map << "}," << endl;  // https://www.sharelatex.com/learn/Pgfplots_package
      // tikzpic_settings_TEX_ss << "colorbar, colormap/jet," << endl;
    }
    tikzpic_settings_TEX_ss << "]" << endl;

    ////////////////////////////////////////////////////////////////////////////
    // END Colorbar settings
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // START Plotting everything on the hull (facet lines, colors, etc.)
    ////////////////////////////////////////////////////////////////////////////

    // for 2d, we go through points2d (in order by stoichiometry), otherwise, we
    // go through planes (order doesn't matter)
    if(dimension == 2) {
      // we use vertices vs. hull_points for facets because vertices
      // contain artificial end points for plotting

      tikzpic_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_FACETS,display_color_gradient);
      for (uint i = 0; i < hull_points.size(); i++) {tikzpic_TEX_ss << addPointContentLaTeX(m_points[hull_points[i]], true, true);}
      tikzpic_TEX_ss << "};" << endl;

      // we plot hullpoints for points on hull ONLY (not lines)
      tikzpic_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_POINTS,display_color_gradient);
      for (uint i = 0; i < hull_points.size(); i++) {
        const ChullPoint point=m_points[hull_points[i]];
        if(!point.m_has_entry) {continue;}
        if(!plot_endpoints && point.isUnary()) {continue;}
        tikzpic_TEX_ss << addPointContentLaTeX(point, false, true);
      }
      tikzpic_TEX_ss << "};" << endl;

      // header for points off hull
      if(plot_off_hull) {_points_data_ss << addHeaderStringLaTeX(ADDPLOT_MODE_OFF_HULL_POINTS,display_color_gradient);}
    } else {  // dimension==3
      // add in endpoints first, if desired
      if(plot_endpoints) {
        for(uint i=0;i<dimension;i++) {
          g_state=getUnaryGState(i);
          if(g_state>m_points.size()-1){continue;}
          const ChullPoint& point = m_points[g_state];
          if(!point.m_has_entry) {continue;}
          convex_hull_vertices_TEX_ss << addPointContentLaTeX(point, false, true);
        }
      }

      //////////////////////////////////////////////////////////////////////////
      // START 3D Heat maps and facet lines
      //////////////////////////////////////////////////////////////////////////

      // this option allows for overlapping facet lines (may or may not be desired)
      if(draw_all_facet_lines) {
        for (uint i = 0; i < m_i_facets.size(); i++) {
          const ChullFacet& facet=m_facets[m_i_facets[i]];
          if(facet.m_is_artificial){continue;}
          if(facet.m_is_vertical) {
            if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
          }else{
            if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
            num_horizontal_planes++;
          }
          chull_points = facet.getCHIndices();
          chull_points.push_back(chull_points[0]);  // that way we get full facet
          for(uint j=0;j<chull_points.size();j++) {
            const ChullPoint& point = m_points[chull_points[j]];
            // keep first coord
            if(j == 0) {
              // convex hull facets color
              heat_map_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HEAT_MAPS,display_color_gradient);
              // convex hull facets (lines)
              convex_hull_facets_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_FACETS,display_color_gradient);
              // thick white line for contrast
              convex_hull_facets_drop_shadow_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS,display_color_gradient);
            }
            convex_hull_facets_TEX_ss << addPointContentLaTeX(point, true, true);
            convex_hull_facets_drop_shadow_TEX_ss << addPointContentLaTeX(point, true, true);
            if(j!=chull_points.size()-1) {  // heatmap doesn't need first coord repeated
              heat_map_TEX_ss << addPointContentLaTeX(point, true, true);
            }
          }
          // end line for connecting facet lines
          convex_hull_facets_TEX_ss << "};" << endl;
          convex_hull_facets_drop_shadow_TEX_ss << "};" << endl;
          heat_map_TEX_ss << "};" << endl;
        }
      } else {
        // no choice but to go through planes twice, once for
        // heatmap, the other for facet lines/drop shadows

        // heatmap
        if(show_heat_map) {
          for (uint i = 0; i < m_i_facets.size(); i++) {
            const ChullFacet& facet=m_facets[m_i_facets[i]];
            if(facet.m_is_artificial){continue;}
            if(facet.m_is_vertical) {
              if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
            }else{
              if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
              num_horizontal_planes++;
            }
            chull_points = facet.getCHIndices();
            for (uint j = 0; j < chull_points.size(); j++) {
              const ChullPoint& point = m_points[chull_points[j]];
              // convex hull facets color
              if(j == 0) {heat_map_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HEAT_MAPS,display_color_gradient);}
              heat_map_TEX_ss << addPointContentLaTeX(point, true, true);
            }
            heat_map_TEX_ss << "};" << endl;
          }
        }
        // save time by not saving WHOLE chullPoints, just compositional part of
        // xvector for facet lines
        //vector<vector<xvector<double> > > facet_lines, facet_lines_dropshadow;
        //fix UNWANTEDFACETLINE to check indices, not actual coords
        vector<vector<uint> > facet_lines, facet_lines_dropshadow;
        for (uint i = 0; i < m_i_facets.size(); i++) {
          const ChullFacet& facet=m_facets[m_i_facets[i]];
          if(facet.m_is_artificial){continue;}
          if(facet.m_is_vertical) {
            if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
          }else{
            if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
            num_horizontal_planes++;
          }
          chull_points = facet.getCHIndices();
          chull_points.push_back(chull_points[0]);  // that way we get full facet
          if(LDEBUG) {cerr << soliloquy << " looking for all unwanted facets" << endl;}
          for (uint l = 0; l < chull_points.size() - 1; l++) {
            if(LDEBUG) {cerr << soliloquy << " looking at point l=" << l << " and l=" << l + 1 << endl;}
            if(!unwantedFacetLine(chull_points[l], chull_points[l+1], facet_lines, true)) {
              if(LDEBUG) {cerr << soliloquy << " plotting point l=" << l << " and l=" << l + 1 << endl;}
              // convex hull facets (lines)
              convex_hull_facets_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_FACETS,display_color_gradient);
              for (uint j = 0; j < 2; j++) {
                const ChullPoint& point = m_points[chull_points[l+j]];
                convex_hull_facets_TEX_ss << addPointContentLaTeX(point, true, true);
              }
              // end line for connecting facet lines
              convex_hull_facets_TEX_ss << "};" << endl;
            } else {
              if(LDEBUG) {
                cerr << soliloquy << " skipping l=" << l << " and l=" << l + 1 << endl;
                cerr << soliloquy << " l=" << l << " is " << m_points[chull_points[l]].m_coords << endl;
                cerr << soliloquy << " l=" << l+1 << " is " << m_points[chull_points[l+1]].m_coords << endl;
              }
            }
            if(hull_drop_shadow) {
              if(!unwantedFacetLine(chull_points[l], chull_points[l+1], facet_lines_dropshadow, false)){
                if(LDEBUG) {cerr << soliloquy << " plotting drop shadow l=" << l << " and l=" << l + 1 << endl;}
                // thick white line for contrast
                convex_hull_facets_drop_shadow_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS,display_color_gradient);
                for (uint j = 0; j < 2; j++) {
                  const ChullPoint& point = m_points[chull_points[l+j]];
                  convex_hull_facets_drop_shadow_TEX_ss << addPointContentLaTeX(point, true, true);
                }
                // end line for connecting facet lines
                convex_hull_facets_drop_shadow_TEX_ss << "};" << endl;
              } else {
                if(LDEBUG) {
                  cerr << soliloquy << " skipping drop shadow l=" << l << " and l=" << l + 1 << endl;
                  cerr << soliloquy << " l=" << l << " is " << m_points[chull_points[l]].m_coords << endl;
                  cerr << soliloquy << " l=" << l+1 << " is " << m_points[chull_points[l+1]].m_coords << endl;
                }
              }
            }
          }
        }
      }

      //////////////////////////////////////////////////////////////////////////
      // END 3D Heat maps and facet lines
      //////////////////////////////////////////////////////////////////////////

      // hullPoints only, so they don't repeat
      convex_hull_vertices_TEX_ss << addHeaderStringLaTeX(ADDPLOT_MODE_HULL_POINTS,display_color_gradient);
      for (uint i = 0; i < hull_points.size(); i++) {
        const ChullPoint& point = m_points[hull_points[i]];
        if(!point.m_has_entry) {continue;}
        if(!plot_endpoints && point.isUnary()) {continue;}
        convex_hull_vertices_TEX_ss << addPointContentLaTeX(point, false, true);
      }
      convex_hull_vertices_TEX_ss << "};" << endl;

      // big merge
      // white lines first, then black
      if(hull_drop_shadow) {tikzpic_TEX_ss << convex_hull_facets_drop_shadow_TEX_ss.str();}
      tikzpic_TEX_ss << convex_hull_facets_TEX_ss.str();
      tikzpic_TEX_ss << convex_hull_vertices_TEX_ss.str();
      convex_hull_facets_TEX_ss.str("");
      convex_hull_vertices_TEX_ss.str("");
      convex_hull_facets_drop_shadow_TEX_ss.str("");

      // points off hull
      if(plot_off_hull) {_points_data_ss << addHeaderStringLaTeX(ADDPLOT_MODE_OFF_HULL_POINTS,display_color_gradient);}
    }

    ////////////////////////////////////////////////////////////////////////////
    // END Plotting everything on the hull (facet lines, colors, etc.)
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    // START Plotting off hull points
    ////////////////////////////////////////////////////////////////////////////

    if(plot_off_hull || !no_labels || !no_links || no_doc) {
      for(uint i=0;i<plot_points.size();i++){
        const ChullPoint& point=m_points[plot_points[i]];
        const aflowlib::_aflowlib_entry& entry = point.m_entry;
        // get coords for table
        if(plot_off_hull) {
          if(!point.m_is_on_hull) {  // we already plotted these points
            points_data_ss << addPointContentLaTeX(point, false, false);
          }
        }
        if(!plot_off_hull && !point.m_is_on_hull) {continue;}

        //////////////////////////////////////////////////////////////////////
        // START Creating clickable links at points
        //////////////////////////////////////////////////////////////////////

        if(!no_links || (no_doc && !no_hyperlinks)) {
          node_option_ss << "opacity=0.0";// get node option
          node_position_ss << getNodeCoordPosition(point); // get node position
          // get node content
          node_content_ss << "\\tiny";
          node_content_ss << "{";
          if(no_doc && !no_hyperlinks) {node_content_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << entry.auid << "}";}
          else {
            uint i_coord_group;
            if(getCoordGroupIndex(point,i_coord_group)){
              uint ref_state=m_coord_groups[i_coord_group].m_ref_state;
              if(isViablePoint(ref_state)){
                node_content_ss << "\\hyperref[" << input << "_" << m_points[ref_state].m_entry.auid << "]";  // for hyperref to right part of document
              }
            }
          }
          node_content_ss << "{O}";
          node_content_ss << "}";
          labels_data_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss); // create node
        }

        //////////////////////////////////////////////////////////////////////
        // END Creating clickable links at points
        //////////////////////////////////////////////////////////////////////

        // now we create labels
        // do not create another node for unaries unless metalabels or
        // protolables
        string compound_label;
        if(!no_labels && !(!labels_off_hull && !point.m_is_on_hull) && !(point.isUnary() && !(meta_labels || prototype_labels))) {
          ////////////////////////////////////////////////////////////////////
          // START Meta-labels (lots of info)
          ////////////////////////////////////////////////////////////////////

          if(meta_labels) {
            // no node option

            // get node position
            node_position_ss << getNodeCoordPosition(point);

            // get node content
            if(dimension == 3 && entry.vspecies.size() == 3) {node_content_ss << "\\color{" << ternary_label_color << "}";}

            node_content_ss << "\\tiny{";
            node_content_ss << "\\shortstack{";
            compound_label = prettyPrintCompound(point,plot_reduce_composition,true,_latex_);  // don't print prototype if not
            node_content_ss << compound_label;
            // equal to compound
            output_name=prettyPrintPrototype(point,false);  // only one backslash needed
            if(compound_label != output_name) {
              node_content_ss << "::";
              node_content_ss << output_name;
            }
            // shortstack newline
            node_content_ss << "\\\\";
            // enthalpy of formation, row 4
            // no need for precision for next few columns, leave it same way
            // as received from AFLOW
            num_ss << chull::Hf_atom(point,_m_);
            node_content_ss << "$H_{\\mathrm{F}}$=" << num_ss.str() << " meV/atom";
            num_ss.str("");
            // shortstack newline
            node_content_ss << "\\\\";
            // entropic temperature, row 5
            num_ss << chull::Ts(point);
            node_content_ss << "$T_{\\mathrm{S}}$=" << num_ss.str() << " K";
            num_ss.str("");
            // dist_2_hull, row 6
            if(!point.isGState()) {
              // shortstack newline
              node_content_ss << "\\\\";
              if(m_formation_energy_hull) {
                node_content_ss << "$\\Delta H_{\\mathrm{F}}$=" << aurostd::utype2string(chull::dist2Hull(point,_m_),CHULL_PRECISION) << " meV/atom";
              } else {
                node_content_ss << "$\\Delta T_{\\mathrm{S}}$=" << aurostd::utype2string(chull::dist2Hull(point),CHULL_PRECISION) << " K";
              }
            }
            node_content_ss << "}";
            node_content_ss << "}";
            // create node
            labels_data_ss << nodeCreator(node_option_ss, node_position_ss,node_content_ss);

            //////////////////////////////////////////////////////////////////
            // END Meta-labels (lots of info)
            //////////////////////////////////////////////////////////////////

          } else {  // no metadata
            // special case
            // create two nodes, one with compound name below ground state
            // node, another with prototype above each node

            //////////////////////////////////////////////////////////////////
            // START Special case labels (2D with prototypes)
            //////////////////////////////////////////////////////////////////

            if(dimension == 2 && !plot_labels && prototype_labels && rotate_labels) {
              if(point.m_is_g_state && !point.isUnary()) {
                // get node option
                node_option_ss << "rotate=90,anchor=" << (m_formation_energy_hull?"east":"west");
                // get node position
                node_position_ss << getNodeCoordPosition(point);
                // get node content
                if(image_only) {node_content_ss << "\\large{";}
                else {node_content_ss << "\\footnotesize{";}
                if(bold_labels/* && !helvetica_font*/) {node_content_ss << "\\textbf{";}
                if(!m_formation_energy_hull){node_content_ss << "~~";}   //pre - 1
                node_content_ss << prettyPrintCompound(point,plot_reduce_composition,true,_latex_);
                if(m_formation_energy_hull){node_content_ss << "~~";}  //post - 2: only works if we put two?
                if(bold_labels/* && !helvetica_font*/) {node_content_ss << "}";}
                node_content_ss << "}";
                // create node
                labels_data_ss << nodeCreator(node_option_ss, node_position_ss,node_content_ss);
              }
              // prototype label
              // get node option
              if(point.isUnary()) {
                if(entry.vspecies[0] == m_velements[0]) {node_option_ss << "anchor=east";}
                else {node_option_ss << "anchor=west";}
              } else {node_option_ss << "anchor=" << (m_formation_energy_hull?"south,above=0.1cm":"north,below=0.1cm");}
              // get node position
              node_position_ss << getNodeCoordPosition(point);
              // get node content
              node_content_ss << "\\scriptsize{";
              output_name=prettyPrintPrototype(point,false);  // only one backslash needed
              if(point.isUnary() && entry.vspecies[0] == m_velements[1]) {node_content_ss << "~~";}
              node_content_ss << output_name;
              if(point.isUnary() && entry.vspecies[0] == m_velements[0]) {node_content_ss << "~~";}
              // enclose brackets
              node_content_ss << "}";
              // create node
              labels_data_ss << nodeCreator(node_option_ss, node_position_ss,node_content_ss);

              ////////////////////////////////////////////////////////////////
              // END Special case labels (2D with prototypes)
              ////////////////////////////////////////////////////////////////

            } else {  // normal case

              ////////////////////////////////////////////////////////////////
              // START Normal labels
              ////////////////////////////////////////////////////////////////

              // get node option
              if(rotate_labels) {
                if(dimension == 2) {
                  if(!point.isUnary()) {  //deal with unaries later
                    if(point.m_is_g_state) {node_option_ss << "rotate=90,anchor=" << (m_formation_energy_hull?"east":"west");}
                    else {node_option_ss << "anchor=" << (m_formation_energy_hull?"south,above=0.1cm":"north,below=0.1cm");}
                  }
                } else {  // dimension==3
                  // ordered to optimize speed (binaries are bulk, then
                  // ternaries, then unaries)
                  if(entry.vspecies.size() == 2) {
                    // / side of triangle
                    if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[1]) {
                      node_option_ss << "rotate=-30,anchor=east";
                      // \ side of triangle
                    } else if(entry.vspecies[0] == m_velements[1] && entry.vspecies[1] == m_velements[2]) {
                      node_option_ss << "rotate=30,anchor=west";
                      // _ side of triangle
                    } else if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[2]) {
                      node_option_ss << "rotate=90,anchor=east";
                    }
                  } else if(entry.vspecies.size() == 3) {
                    if(!show_heat_map) {node_option_ss << "anchor=south,above=0.1cm";}
                  } else if(entry.vspecies.size() == 1) {
                    // bottom two edges of triangle
                    if(entry.vspecies[0] == m_velements[0] || entry.vspecies[0] == m_velements[2]) {
                      node_option_ss << "anchor=north,below=0.1cm";
                      // top of triangle
                    }else{node_option_ss << "anchor=south,above=0.1cm";}
                  }
                }
              }
              if(dimension == 2) {  //deal with unaries separately
                if(point.isUnary()) {
                  if(entry.vspecies[0] == m_velements[0]) {node_option_ss << "anchor=east";}
                  else {node_option_ss << "anchor=west";}
                }
              }
              // get node position
              node_position_ss << getNodeCoordPosition(point);
              // get node content
              if(dimension == 3 && entry.vspecies.size() == 3) {node_content_ss << "\\color{" << ternary_label_color << "}";}
              if(compound_labels && prototype_labels) {
                node_content_ss << "\\scriptsize{";
              } else {
                // 8.5x11 page can only be so big, but IMAGE_ONLY can be as
                // big as it wants to be
                //if(image_only) {
                //    if(helvetica_font) {
                //  node_content_ss
                //      << "\\huge{";  // https://en.wikibooks.org/wiki/LaTeX/Fonts#Arbitrary_font_size
                //    } else {
                //  node_content_ss
                //      << "\\Large{";  // https://en.wikibooks.org/wiki/LaTeX/Fonts#Arbitrary_font_size
                //} else {
                node_content_ss << "\\" << font_size << "{";
              }
              //}
              if(bold_labels/* && !helvetica_font*/) { node_content_ss << "\\textbf{";}
              
              // add space for rotation
              if(rotate_labels) {
                if(dimension == 2) {
                  if(!point.isUnary()){ //handle unaries later
                    if(!m_formation_energy_hull && point.m_is_g_state){node_content_ss << "~";}
                  }
                } else {  // dimension==3
                  if(entry.vspecies.size() == 2) {
                    // \ side of triangle
                    if(entry.vspecies[0] == m_velements[1] && entry.vspecies[1] == m_velements[2]) {
                      node_content_ss << "~";
                    }
                  }
                }
              }
              if(dimension == 2) {
                if(point.isUnary()){  //unaries
                  if(entry.vspecies[0] == m_velements[1]) {node_content_ss << "~";}
                }
              }

              if(compound_labels) {
                compound_label = prettyPrintCompound(point,plot_reduce_composition,true,_latex_);  // don't print prototype if
                node_content_ss << compound_label;
                // equal to compound
              }
              if(prototype_labels) {
                output_name=prettyPrintPrototype(point,false);  // only one backslash needed
                if(compound_labels) {
                  if(compound_label != output_name) {
                    node_content_ss << "::";
                    node_content_ss << output_name;
                  }
                }else{node_content_ss << output_name;}
              }

              if(rotate_labels) {
                if(dimension == 2) {
                  if(!point.isUnary()){ //handle unaries later
                    if(m_formation_energy_hull && point.m_is_g_state){node_content_ss << "~~";} // only works if we put two?
                  }
                } else {  // dimension==3
                  if(entry.vspecies.size() == 2) {
                    // / side of triangle
                    if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[1]) {
                      node_content_ss << "~~";  // only works if we put two?
                      // _ side of triangle
                    } else if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[2]) {
                      node_content_ss << "~~";  // only works if we put two?
                    }
                  }
                }
              }
              if(dimension == 2) {
                if(point.isUnary()){ //unaries
                  if(entry.vspecies[0] == m_velements[0]) {node_content_ss << "~~";}
                }
              }

              // enclose brackets
              if(bold_labels/* && !helvetica_font*/) {node_content_ss << "}";}
              node_content_ss << "}";
              // create node
              labels_data_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

              ////////////////////////////////////////////////////////////////
              // END Normal labels
              ////////////////////////////////////////////////////////////////
            }
          }
        }
      }
      // merge labels data
      if(plot_off_hull && !points_data_ss.str().empty()) {points_data_ss << "};" << endl;}
      if(!points_data_ss.str().empty()) {tikzpic_TEX_ss << _points_data_ss.str() << points_data_ss.str();}
      if(!labels_data_ss.str().empty()) {
        tikzpic_TEX_ss << "\\begin{pgfonlayer}{foreground}" << endl;  // for overlap
        tikzpic_TEX_ss << labels_data_ss.str();
        tikzpic_TEX_ss << "\\end{pgfonlayer}{foreground}" << endl;
      }
    }

    ////////////////////////////////////////////////////////////////////////////
    // END Plotting off hull points
    ////////////////////////////////////////////////////////////////////////////

    if(dimension == 2) {tikzpic_TEX_ss << "\\end{axis}" << endl;}
    else{tikzpic_TEX_ss << "\\end{ternaryaxis}" << endl;}

    ////////////////////////////////////////////////////////////////////////////
    // END Axis
    ////////////////////////////////////////////////////////////////////////////

    if(!no_banner) {
      if(dimension == 2) {
        ////////////////////////////////////////////////////////////////////////
        // START Logo on top left
        ////////////////////////////////////////////////////////////////////////

        //if(XHOST.hostname == "aflowlib.mems.duke.edu" &&
        if(print_aflow_logo) {
          if(image_only) {
            tikzpic_TEX_ss << "\\begin{scope}[remember picture]" << endl;
            if(!small_banner) {
              // get node option
              node_option_ss << "shift={(2.75cm,0.25cm)}";
              // get node position
              node_position_ss << "current bounding box.north west";
            }
          } else {
            tikzpic_TEX_ss << "\\begin{scope}[remember picture,overlay]" << endl;
            if(!small_banner) {
              // get node option
              node_option_ss << "shift={(2cm,0cm)}";
              // get node position
              node_position_ss << "current bounding box.north west";
            }
          }
          if(!small_banner) {
            // get node content
            if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
            node_content_ss << "{\\includegraphics[scale=0.2]{" << aflow_logo_file << "}}";
          }
        } else {
          if(image_only) {
            tikzpic_TEX_ss << "\\begin{scope}[remember picture]" << endl;
            if(!small_banner) {
              // get node option
              node_option_ss << "shift={(3.5cm,0cm)}";
              // get node position
              node_position_ss << "current bounding box.north west";
            }
          } else {
            tikzpic_TEX_ss << "\\begin{scope}[remember picture,overlay]" << endl;
            if(!small_banner) {
              // get node option
              node_option_ss << "shift={(2.5cm,0.25cm)}";
              // get node position
              node_position_ss << "current bounding box.north west";
            }
          }
          if(!small_banner) {
            // get node content
            node_content_ss << "\\shortstack[l]{";
            if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
            node_content_ss << "{\\huge AFLOW V" << string(AFLOW_VERSION) << "}";
            node_content_ss << "\\\\";
            node_content_ss << "{\\normalsize Stefano Curtarolo}}";
          }
        }
        if(!small_banner) {
          // create node
          tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
        }

        ////////////////////////////////////////////////////////////////////////
        // END Logo on top left
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        // START AFLOW.org on top right
        ////////////////////////////////////////////////////////////////////////

        if(image_only) {
          // get node option
          if(!small_banner) {node_option_ss << "shift={(-2cm,-0.75cm)}";}
          else {node_option_ss << "shift={(-2cm,0cm)}";}
          // get node position
          node_position_ss << "current bounding box.north east";
        } else {
          // get node option
          node_option_ss << "shift={(-0.5cm,0.25cm)}";
          // get node position
          node_position_ss << "current bounding box.north east";
        }
        // get node content
        node_content_ss << "\\large";
        node_content_ss << "{\\fontfamily{phv}\\selectfont";
        if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
        node_content_ss << "{" << AFLOWLIB_MATERIALS_SERVER << "}}";
        // create node
        tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

        ////////////////////////////////////////////////////////////////////////
        // END AFLOW.org on top right
        ////////////////////////////////////////////////////////////////////////

        if(!small_banner) {
          //////////////////////////////////////////////////////////////////////
          // START Count on bottom left
          //////////////////////////////////////////////////////////////////////

          if(image_only) {
            // get node option
            node_option_ss << "shift={(2.5cm,-0.5cm)}";
            // get node position
            node_position_ss << "current bounding box.south west";
          } else {
            // get node option
            node_option_ss << "shift={(1cm,-0.1cm)}";
            // get node position
            node_position_ss << "current bounding box.south west";
          }
          // get node content
          node_content_ss << "Count=" << count_entries;
          // create node
          tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

          //////////////////////////////////////////////////////////////////////
          // END Count on bottom left
          //////////////////////////////////////////////////////////////////////

          //////////////////////////////////////////////////////////////////////
          // START Date on bottom right
          //////////////////////////////////////////////////////////////////////

          if(image_only) {
            // get node option
            node_option_ss << "shift={(-4.25cm,0.5cm)}";
            // get node position
            node_position_ss << "current bounding box.south east";
          } else {
            // get node option
            node_option_ss << "shift={(-2cm,-0.1cm)}";
            // get node position
            node_position_ss << "current bounding box.south east";
          }
          // get node content
          node_content_ss << "\\today~\\currenttime";
          // create node
          tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

          //////////////////////////////////////////////////////////////////////
          // END Date on bottom right
          //////////////////////////////////////////////////////////////////////
        }
        tikzpic_TEX_ss << "\\end{scope}" << endl;
      } else {  // dimension==3

        ////////////////////////////////////////////////////////////////////////
        // START Full banner on left (logo,count,date)
        ////////////////////////////////////////////////////////////////////////

        tikzpic_TEX_ss << "\\begin{scope}[remember picture,overlay]" << endl;
        if(!small_banner) {
          if(include_color_bar) {
            if(print_aflow_logo) {
              if(image_only) {
                // get node option
                node_option_ss << "shift={(3.75cm,-2.5cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              } else {
                // get node option
                node_option_ss << "shift={(3.25cm,-1.5cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              }
              // get node content
              node_content_ss << "\\shortstack[l]{";
              if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
              node_content_ss << "{\\includegraphics[scale=0.25]{" << aflow_logo_file << "}}";
            } else {
              if(image_only) {
                // get node option
                node_option_ss << "shift={(4cm,-2.25cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              } else {
                // get node option
                node_option_ss << "shift={(3.25cm,-1.25cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              }
              // get node content
              node_content_ss << "\\shortstack[l]{";
              if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
              node_content_ss << "{\\huge AFLOW V" << string(AFLOW_VERSION) << "}";
              node_content_ss << "\\\\";
              node_content_ss << "{\\normalsize Stefano Curtarolo}";
            }
          } else {
            if(print_aflow_logo) {
              if(image_only) {
                // get node option
                node_option_ss << "shift={(3.25cm,-2.25cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              } else {
                // get node option
                node_option_ss << "shift={(2.25cm,-1.5cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              }
              // get node content
              node_content_ss << "\\shortstack[l]{";
              if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
              node_content_ss << "{\\includegraphics[scale=0.25]{" << aflow_logo_file << "}}";
            } else {
              if(image_only) {
                // get node option
                node_option_ss << "shift={(4cm,-2.25cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              } else {
                // get node option
                node_option_ss << "shift={(2cm,-1.5cm)}";
                // get node position
                node_position_ss << "current bounding box.north west";
              }
              // get node content
              node_content_ss << "\\shortstack[l]{";
              if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
              node_content_ss << "{\\huge AFLOW V" << string(AFLOW_VERSION) << "}";
              node_content_ss << "\\\\";
              node_content_ss << "{\\normalsize Stefano Curtarolo}";
            }
          }
          // get node content
          node_content_ss << "\\\\";
          node_content_ss << "\\\\";
          node_content_ss << "\\large Count=" << count_entries;
          node_content_ss << "\\\\";
          node_content_ss << "\\large \\today~\\currenttime";
          node_content_ss << "}";
          // create node
          tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
        }
        ////////////////////////////////////////////////////////////////////////
        // END Full banner on top left (logo,count,date)
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        // START AFLOW.org on top right
        ////////////////////////////////////////////////////////////////////////

        if(include_color_bar) {
          if(image_only) {
            // get node option
            node_option_ss << "shift={(-2cm,-0.75cm)}";
            // get node position
            node_position_ss << "current bounding box.north east";
          } else {
            // get node option
            node_option_ss << "shift={(-1.5cm,-0.5cm)}";
            // get node position
            node_position_ss << "current bounding box.north east";
          }
        } else {
          if(image_only) {
            // get node option
            node_option_ss << "shift={(-2.5cm,-1.25cm)}";
            // get node position
            node_position_ss << "current bounding box.north east";
          } else {
            // get node option
            node_option_ss << "shift={(-0.25cm,-0.5cm)}";
            // get node position
            node_position_ss << "current bounding box.north east";
          }
        }
        // get node content
        node_content_ss << "\\shortstack[l]{";
        node_content_ss << "{\\large";
        node_content_ss << "{\\fontfamily{phv}\\selectfont";
        if(!no_hyperlinks) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
        node_content_ss << "{" << AFLOWLIB_MATERIALS_SERVER << "}}";
        node_content_ss << "}";
        node_content_ss << "}";
        // create node
        tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

        ////////////////////////////////////////////////////////////////////////
        // END AFLOW.org on top right
        ////////////////////////////////////////////////////////////////////////

        tikzpic_TEX_ss << "\\end{scope}" << endl;
      }
    }
    tikzpic_TEX_ss << "\\end{tikzpicture}" << endl;
    if(image_only) {tikzpic_TEX_ss << "\\endpgfgraphicnamed" << endl;}
    else {
      tikzpic_TEX_ss << "\\vspace*{\\fill}" << endl;
      tikzpic_TEX_ss << "}" << endl;
      tikzpic_TEX_ss << "\\end{landscape}" << endl;
      if(!no_doc) {tikzpic_TEX_ss << "\\restoregeometry" << endl;}
    }
  } else {
    // make sure to add this in
    doc_header_TEX_ss << "\\usepackage{graphicx}" << endl;
    // contains begin{document}, which needs to go in sooner
    doc_header_TEX_ss << _doc_header_TEX_ss.str();
    _doc_header_TEX_ss.str("");
  }

  // BIG MERGE
  main_TEX_ss << doc_header_TEX_ss.str();
  doc_header_TEX_ss.str("");

  if(!doc_only && (dimension == 2 || dimension == 3)) {
    main_TEX_ss << _tikzpic_settings_TEX_ss.str();
    _tikzpic_settings_TEX_ss.str("");
    main_TEX_ss << unary_label_TEX_ss.str();
    unary_label_TEX_ss.str("");
    main_TEX_ss << tikzpic_settings_TEX_ss.str();
    tikzpic_settings_TEX_ss.str("");
    if(show_heat_map && num_horizontal_planes > 1) {
      main_TEX_ss << heat_map_TEX_ss.str();
      heat_map_TEX_ss.str("");
    }
    main_TEX_ss << tikzpic_TEX_ss.str();
    tikzpic_TEX_ss.str("");
  }

  //////////////////////////////////////////////////////////////////////////////
  // END Image on first page
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // START Report
  //////////////////////////////////////////////////////////////////////////////

  if(!no_doc && !image_only) {
    if(!doc_only) {main_TEX_ss << "\\newpage" << endl;}
    ////////////////////////////////////////////////////////////////////////////
    // START Column header setup
    ////////////////////////////////////////////////////////////////////////////
    main_TEX_ss << "\\newlength{\\headerwidth}" << endl;
    main_TEX_ss << "\\setlength{\\headerwidth}{\\textwidth}" << endl;
    main_TEX_ss << "\\newsavebox{\\aflowLogo}" << endl;
    main_TEX_ss << "\\begin{lrbox}{\\aflowLogo}" << endl;
    main_TEX_ss << "\\begin{tabu}{X[1,l,m]X[1,r,m]}" << endl;
    if(!no_hyperlinks) {main_TEX_ss << "\\href{" << AFLOW_WEB << "}";}
    //if(XHOST.hostname == "aflowlib.mems.duke.edu" &&
    if(print_aflow_logo) {
      main_TEX_ss << "{\\includegraphics[scale=0.25]{" << aflow_logo_file << "}}";
    } else {
      main_TEX_ss << "{\\large AFLOW V" << string(AFLOW_VERSION) << "}";
      main_TEX_ss << " \\large{-- Stefano Curtarolo}";
    }
    main_TEX_ss << " & ";
    //{\\large Materials Snapshot}" << endl;
    //include small redundant header - START
    main_TEX_ss << "\\begin{tabular}[x]{@{}r@{}}";
    main_TEX_ss << "\\large Materials Snapshot";
    main_TEX_ss << "\\\\";
    main_TEX_ss << "\\large Count=" << count_entries;
    main_TEX_ss << "\\\\\\large \\today~\\currenttime";
    main_TEX_ss << "\\end{tabular}" << endl;
    main_TEX_ss << "\\end{tabu}" << endl;
    //include small redundant header - END
    main_TEX_ss << "\\end{lrbox}" << endl;
    main_TEX_ss << "\\newsavebox{\\myheader}" << endl;
    main_TEX_ss << "\\begin{lrbox}{\\myheader}" << endl;
    if(compounds_column_report) {
      main_TEX_ss << "\\begin{tabu}{|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|}" << endl;
      main_TEX_ss << "\\toprule" << endl;
      main_TEX_ss << aurostd::PaddedPOST("\\rowcolor{white}", 30);
      main_TEX_ss << aurostd::PaddedPOST("{\\small Compound}", 80);
      main_TEX_ss << " & ";
    } else {
      main_TEX_ss << "\\begin{tabu}{|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|X[1,c,m]|}" << endl;
      main_TEX_ss << "\\toprule" << endl;
      main_TEX_ss << aurostd::PaddedPOST("\\rowcolor{white}", 30);
    }
    main_TEX_ss << aurostd::PaddedPOST("{\\small prototype}", 80);
    main_TEX_ss << " & ";
    main_TEX_ss << aurostd::PaddedPOST("{\\small $SG_{\\mathrm{pre}}$}", 30);
    main_TEX_ss << " & ";
    main_TEX_ss << aurostd::PaddedPOST("{\\small $SG_{\\mathrm{post}}$}", 30);
    main_TEX_ss << " & ";
    main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small spin $\\left(\\mu_{\\mathrm{B}}\\mathrm{/atom}\\right)$}", 30);
    main_TEX_ss << " & ";
    main_TEX_ss << aurostd::PaddedPOST("{\\small $H_{\\mathrm{F}}$ (meV/atom)}", 30);
    main_TEX_ss << " & ";
    main_TEX_ss << aurostd::PaddedPOST("{\\small $T_{\\mathrm{S}}$ (K)}", 30);
    main_TEX_ss << " & ";
    if(m_formation_energy_hull) {main_TEX_ss << aurostd::PaddedPOST("{\\small $\\Delta H_{\\mathrm{F}}$ (meV/atom)}", 30);}
    else{main_TEX_ss << aurostd::PaddedPOST("{\\small $\\Delta T_{\\mathrm{S}}$ (K)}", 30);}
    main_TEX_ss << " \\\\";
    main_TEX_ss << endl;
    main_TEX_ss << "\\midrule" << endl;
    main_TEX_ss << "\\end{tabu}" << endl;
    main_TEX_ss << "\\end{lrbox}" << endl;
    // fancypagestyle1 for first page of report
    main_TEX_ss << "\\fancypagestyle{style1}{" << endl;
    main_TEX_ss << "\\fancyhf{}" << endl;
    main_TEX_ss << "\\fancyhead[C]{\\usebox{\\aflowLogo}}" << endl;
    main_TEX_ss << "\\fancyfoot[C]{\\thepage}" << endl;
    main_TEX_ss << "\\renewcommand{\\headrulewidth}{0pt}     \% size of header line" << endl;
    main_TEX_ss << "\\renewcommand{\\footrulewidth}{0pt}     \% size of header line" << endl;
    main_TEX_ss << "}" << endl;
    // fancypagestyle1 for beyond first page
    main_TEX_ss << "\\fancypagestyle{style2}{" << endl;
    main_TEX_ss << "\\fancyhf{}" << endl;
    main_TEX_ss << "\\fancyhead[C]{\\usebox{\\myheader}}" << endl;
    main_TEX_ss << "\\fancyfoot[C]{\\thepage}" << endl;
    main_TEX_ss << "\\renewcommand{\\headrulewidth}{0pt}     \% size of header line" << endl;
    main_TEX_ss << "\\renewcommand{\\footrulewidth}{0pt}     \% size of header line" << endl;
    main_TEX_ss << "}" << endl;

    main_TEX_ss << "\\thispagestyle{style1}" << endl;
    main_TEX_ss << "\\pagestyle{style2}" << endl;

    //citation
    main_TEX_ss << "\\noindent Use of this data welcomes reference to the following publication:" << endl;
    main_TEX_ss << "\\begin{quote}" << endl;
    main_TEX_ss << CHULL_AUTHORS << ", ";
    main_TEX_ss << "\\textit{" << CHULL_TITLE << "}, ";
    main_TEX_ss << CHULL_JOURNAL << "." << endl;
    main_TEX_ss << "\\end{quote}" << endl;

    ////////////////////////////////////////////////////////////////////////////
    // END Column header setup
    ////////////////////////////////////////////////////////////////////////////

    uint counter;
    bool putColumnHeader = true;  // only put it for the first reported stoich
    vector<vector<uint> > equilibrium_phases;
    vector<vector<ChullPoint> > equilibrium_phases_CP;
    vector<ChullPoint> dummyDCP;
    vector<string> equilibrium_phases_vs, _equilibrium_phases_vs;
    vector<uint> decomposition_phases;
    xvector<double> decomposition_coefficients;
    vector<string> decompositionCoefPhase_vs;  // combined coef * phase
    string misc;
    uint i_phase;

    ////////////////////////////////////////////////////////////////////////////
    // START Stoichiometry group loop
    ////////////////////////////////////////////////////////////////////////////

    for (uint i = 0; i < m_coord_groups.size(); i++) {
      counter = 0;

      //////////////////////////////////////////////////////////////////////////
      // START Stoichiometry group points loop
      //////////////////////////////////////////////////////////////////////////

      for (uint j = 0; j < m_coord_groups[i].m_points.size(); j++) {
        ////////////////////////////////////////////////////////////////////////
        // START Entries filter
        ////////////////////////////////////////////////////////////////////////

        const ChullPoint& point = m_points[m_coord_groups[i].m_points[j]];
        if(!point.m_has_entry) {continue;}
        const aflowlib::_aflowlib_entry& entry = point.m_entry;

        ////////////////////////////////////////////////////////////////////////
        // END Entries filter
        ////////////////////////////////////////////////////////////////////////

        if(!counter) {
          //////////////////////////////////////////////////////////////////////
          // START Concentration label
          //////////////////////////////////////////////////////////////////////

          if(composition_header_report) {
            for (uint j = 0; j < (uint)point.m_elements_present.rows; j++) {
              if(point.m_elements_present[j]==1){
                _report_data_ss << m_velements[j] << "$_{" << aurostd::utype2string(point.s_coords[j],COEF_PRECISION) << "}$";
              }
            }
          } else {_report_data_ss << prettyPrintCompound(entry,true,true,_latex_);}

          //////////////////////////////////////////////////////////////////////
          // START Concentration label
          //////////////////////////////////////////////////////////////////////

          //////////////////////////////////////////////////////////////////////
          // START Gathering info about equilibrium phases / decomposition
          // reaction
          //////////////////////////////////////////////////////////////////////

          if(m_coord_groups[i].m_is_on_hull) {

            const vector<vector<uint> >& equilibrium_phases=m_coord_groups[i].m_equilibrium_phases;
            //nice fast way to toggle equivalent_phases on/off
            //if(include_equilibrium_phases) {equilibrium_phases = m_coord_groups[i].m_equilibrium_phases;}
            //else {equilibrium_phases.clear();}

            if(include_equilibrium_phases && !equilibrium_phases.empty()) {
              for (uint k = 0; k < equilibrium_phases.size(); k++) {
                for (uint l = 0; l < equilibrium_phases[k].size(); l++) {
                  i_phase=artificialMap(equilibrium_phases[k][l]);
                  const ChullPoint& eq_phase=m_points[i_phase];
                  if(!eq_phase.m_has_entry) {
                    // we need to adjust for missing unaries
                    // look for coords
                    output_name=aurostd::joinWDelimiter(alloyToElements(eq_phase),"");
                  } else {
                    const aflowlib::_aflowlib_entry& equation_entry = eq_phase.m_entry;

                    output_name=prettyPrintCompound(equation_entry,true,true,_latex_);
                    // do not hyperlink current point (pointless)
                    if(!aurostd::identical(point.getTruncatedGenCoords(), eq_phase.getTruncatedGenCoords(), ZERO_TOL)) {
                      if(!no_links) {
                        misc_ss << "\\hyperref[" << input << "_" << equation_entry.auid << "]{";
                        misc_ss << output_name;
                        misc_ss << "}";
                        output_name = misc_ss.str();
                        misc_ss.str("");
                      }
                    }
                  }
                  _equilibrium_phases_vs.push_back(output_name);
                }
                if(m_coord_groups[i].getDim() > 6) {equilibrium_phases_vs.push_back(aurostd::joinWDelimiter(_equilibrium_phases_vs, " -- "));}  // that way, we don't run off the line
                else {equilibrium_phases_vs.push_back(aurostd::joinWDelimiter(_equilibrium_phases_vs, "--"));}
                _equilibrium_phases_vs.clear();
              }
              equilibrium_phases_TEX_ss << aurostd::joinWDelimiter(equilibrium_phases_vs, ", ", " and ", ", and ");
              equilibrium_phases_vs.clear();
              equilibrium_phases_CP.clear();
              //get header
              //misc = prettyPrintCompound(entry,true,true,_latex_);
              equilibrium_phases_header_TEX_ss << m_coord_groups[i].getDim() << "-phase equilibria";
              //equilibrium_phases_header_TEX_ss << " with " << misc;
              equilibrium_phases_header_TEX_ss << ":";
            }
          } else {
            // decomposition equation
            const vector<uint>& decomposition_phases = m_coord_groups[i].m_decomp_phases;
            const xvector<double>& decomposition_coefficients = m_coord_groups[i].m_decomp_coefs;
            if(!decomposition_phases.empty() && scalar_product(decomposition_coefficients, decomposition_coefficients) >= ZERO_TOL) {
              if(decomposition_phases.size() != (uint)decomposition_coefficients.rows-1) {
                throw CHullLogicError(soliloquy,"Size of decomposition phases != size of decomposition coefficients for coordgroup["+aurostd::utype2string(i)+"]");
              }
              // write out decomposition equation
              reaction_chem_eq_TEX_ss << prettyPrintCompound(entry,true,true,_latex_);
              reaction_chem_eq_TEX_ss << " $\\to$ ";
              for (uint k = 0; k < decomposition_phases.size(); k++) {
                if(abs(decomposition_coefficients[k+1]) < ZERO_TOL) {continue;}
                i_phase=artificialMap(decomposition_phases[k]);
                const ChullPoint& dc_phase=m_points[i_phase];
                if(!dc_phase.m_has_entry) {
                  // we need to adjust for missing unaries
                  // look for coords
                  output_name=aurostd::joinWDelimiter(alloyToElements(dc_phase),"");
                } else {
                  const aflowlib::_aflowlib_entry& equation_entry = dc_phase.m_entry;
                  output_name=prettyPrintCompound(equation_entry,true,true,_latex_);
                  if(!no_links) {
                    misc_ss << "\\hyperref[" << input << "_" << equation_entry.auid << "]{";
                    misc_ss << output_name;
                    misc_ss << "}";
                    output_name = misc_ss.str();
                    misc_ss.str("");
                  }
                }
                misc_ss << aurostd::utype2string(abs(decomposition_coefficients[k+1]),COEF_PRECISION) << "~";
                misc_ss << output_name;
                decompositionCoefPhase_vs.push_back(misc_ss.str());
                misc_ss.str("");
              }
              reaction_chem_eq_TEX_ss << aurostd::joinWDelimiter(decompositionCoefPhase_vs, " + ");
              decompositionCoefPhase_vs.clear();
            }
          }

          //////////////////////////////////////////////////////////////////////
          // END Gathering info about equilibrium phases / decomposition
          // reaction
          //////////////////////////////////////////////////////////////////////
        }

        ////////////////////////////////////////////////////////////////////////
        // START Row properties set up
        ////////////////////////////////////////////////////////////////////////

        sg_tokens=entry.vsg;
        //if(!entry.sg.empty()) {
        //  aurostd::string2tokens(entry.sg, sg_tokens, ",");
          //  if(sg_tokens.size() != 3) {
          //    continue;
          //  }
        //}
        if(point.isGState()) {report_data_ss << aurostd::PaddedPOST("\\rowcolor{green!85!blue} ", 30);} //red!25
        else if(point.m_is_sym_equivalent_g_state) {report_data_ss << aurostd::PaddedPOST("\\rowcolor{orange!85} ", 30);}  // odd should be white
        else if(counter % 2) {report_data_ss << aurostd::PaddedPOST("\\rowcolor{white} ", 30);}  // odd should be white
        else {report_data_ss << aurostd::PaddedPOST("\\rowcolor{gray!25} ", 30);}
        misc = "";
        if(compounds_column_report) {
          misc=prettyPrintCompound(entry,false,true,_latex_);
          if(!no_hyperlinks) {
            misc_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << entry.auid << "}{";
            misc_ss << misc;
            misc_ss << "}";
            //if(point.isGState()){misc_ss << "$^{**}$";}
            report_data_ss << aurostd::PaddedPOST(misc_ss.str(), 100);
            misc_ss.str("");
          } else{report_data_ss << aurostd::PaddedPOST(misc, 30);}
          report_data_ss << " & ";
        }
        misc = "";
        if(!entry.prototype.empty()) {
          misc=prettyPrintPrototype(entry,false);
          if(!no_hyperlinks) {
            misc_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << entry.auid << "}{";
            misc_ss << misc;
            misc_ss << "}";
            //if(point.isGState()){misc_ss << "$^{**}$";}
            report_data_ss << aurostd::PaddedPOST(misc_ss.str(), 100);
            misc_ss.str("");
          } else { report_data_ss << aurostd::PaddedPOST(misc, 30);}
        } else { report_data_ss << aurostd::PaddedPOST(" ", 30);}

        ////////////////////////////////////////////////////////////////////////
        // END Row properties set up
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        // START Entry properties output
        ////////////////////////////////////////////////////////////////////////

        misc = "";
        report_data_ss << " & ";
        if(!entry.sg.empty()) {
          // pre
          misc=fixStringLatex(sg_tokens.front(),false,true);
          //put in math mode
          report_data_ss << aurostd::PaddedPOST("$" + misc + "$", 30);
          report_data_ss << " & ";
          // post
          misc=fixStringLatex(sg_tokens.back(),false,true);
          //put in math mode
          report_data_ss << aurostd::PaddedPOST("$" + misc + "$", 30);
        } else {
          report_data_ss << aurostd::PaddedPOST(" ", 30);
          report_data_ss << " & ";
          report_data_ss << aurostd::PaddedPOST(" ", 30);
        }
        report_data_ss << " & ";
        report_data_ss << aurostd::PaddedPOST(aurostd::utype2string(entry.spin_atom,2,true,ROUNDOFF_TOL,FIXED_STREAM), 30);
        report_data_ss << " & ";
        report_data_ss << aurostd::PaddedPOST(aurostd::utype2string(chull::Hf_atom(entry,_m_),0,true,ROUNDOFF_TOL,FIXED_STREAM), 30);
        report_data_ss << " & ";
        report_data_ss << aurostd::PaddedPOST(aurostd::utype2string(chull::Ts(entry),0,true,ROUNDOFF_TOL,FIXED_STREAM), 30);
        report_data_ss << " & ";
        if(m_formation_energy_hull) {report_data_ss << aurostd::PaddedPOST(aurostd::utype2string(chull::dist2Hull(point,_m_),0,true,ROUNDOFF_TOL,FIXED_STREAM), 30);}
        else {report_data_ss << aurostd::PaddedPOST(aurostd::utype2string(chull::dist2Hull(point),0,true,ROUNDOFF_TOL,FIXED_STREAM), 30);}
        report_data_ss << " \\\\" << endl;
        counter++;
      }

      //////////////////////////////////////////////////////////////////////////
      // END Entry properties output
      //////////////////////////////////////////////////////////////////////////

      //////////////////////////////////////////////////////////////////////////
      // START Entry table creation
      //////////////////////////////////////////////////////////////////////////

      if(!report_data_ss.str().empty()) {
        if(compounds_column_report) {
          main_TEX_ss << "{\\fontsize{6}{9}\\selectfont" << endl;
          main_TEX_ss << "\\begin{longtabu}{|X[1,l,m]|X[1,l,m]|X[1,l,m]|X[1,l,m]|X[1,r,m]|X[1,r,m]|X[1,r,m]|X[1,r,m]|}" << endl;
          if(putColumnHeader) {
            main_TEX_ss << "\\toprule" << endl;
            main_TEX_ss << aurostd::PaddedPOST("\\rowcolor{white}", 30);
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small Compound}",80);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small prototype}",30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $SG_{\\mathrm{pre}}$}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $SG_{\\mathrm{post}}$}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small spin $\\left(\\mu_{\\mathrm{B}}\\mathrm{/atom}\\right)$}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $H_{\\mathrm{F}}$ (meV/atom)}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $T_{\\mathrm{S}}$ (K)}", 30);
            main_TEX_ss << " & ";
            if(m_formation_energy_hull) {
              main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $\\Delta H_{\\mathrm{F}}$ (meV/atom)}", 30);
            } else {
              main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $\\Delta T_{\\mathrm{S}}$ (K)}", 30);
            }
            main_TEX_ss << " \\\\";
            main_TEX_ss << endl;
            main_TEX_ss << "\\midrule" << endl;
          }
          putColumnHeader = false;
          if(!no_links && isViablePoint(m_coord_groups[i].m_ref_state)) {
            uint ref_state=m_coord_groups[i].m_ref_state;
            main_TEX_ss << "\\multicolumn{8}{l}{\\phantomsection\\label{"+input + "_" + m_points[ref_state].m_entry.auid + "}} \\\\[0.1cm]" << endl;
          } else {main_TEX_ss << "\\multicolumn{8}{l}{} \\\\[0.1cm]" << endl;}
          if(m_coord_groups[i].m_is_on_hull) {_report_data_ss << " " << "(ground state)";}
          // compound name
          main_TEX_ss << "\\multicolumn{8}{l}{";
          main_TEX_ss << "\\cellcolor{white}\\normalsize{" + _report_data_ss.str();
          main_TEX_ss << "}} \\\\[0.1cm]" << endl;
        } else {
          main_TEX_ss << "{\\fontsize{5}{7}\\selectfont" << endl;
          main_TEX_ss << "\\begin{longtabu}{|X[1,l,m]|X[1,l,m]|X[1,l,m]|X[1,r,m]|X[1,r,m]|X[1,r,m]|X[1,r,m]|}" << endl;
          if(putColumnHeader) {
            main_TEX_ss << "\\toprule" << endl;
            main_TEX_ss << aurostd::PaddedPOST("\\rowcolor{white}", 30);
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small prototype}", 80);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $SG_{\\mathrm{pre}}$}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $SG_{\\mathrm{post}}$}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small spin $\\left(\\mu_{\\mathrm{B}}\\mathrm{/atom}\\right)$}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $H_{\\mathrm{F}}$ (meV/atom)}", 30);
            main_TEX_ss << " & ";
            main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $T_{\\mathrm{S}}$ (K)}", 30);
            main_TEX_ss << " & ";
            if(m_formation_energy_hull) {main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $\\Delta H_{\\mathrm{F}}$ (meV/atom)}", 30);}
            else {main_TEX_ss << aurostd::PaddedPOST("\\centering{\\small $\\Delta T_{\\mathrm{S}}$ (K)}", 30);}
            main_TEX_ss << " \\\\";
            main_TEX_ss << endl;
            main_TEX_ss << "\\midrule" << endl;
          }
          putColumnHeader = false;
          if(!no_links && isViablePoint(m_coord_groups[i].m_ref_state)) {
            uint ref_state=m_coord_groups[i].m_ref_state;
            main_TEX_ss << "\\multicolumn{7}{l}{\\phantomsection\\label{" +input + "_" + m_points[ref_state].m_entry.auid + "}} \\\\[0.1cm]" << endl;
          } else {main_TEX_ss << "\\multicolumn{7}{l}{} \\\\[0.1cm]" << endl;}
          if(m_coord_groups[i].m_is_on_hull) {_report_data_ss << " " << "(ground state)";}
          // compound name
          main_TEX_ss << "\\multicolumn{7}{l}{";
          main_TEX_ss << "\\cellcolor{white}\\normalsize{" + _report_data_ss.str();
          main_TEX_ss << "}} \\\\[0.1cm]" << endl;
        }
        main_TEX_ss << "\\hline" << endl;
        main_TEX_ss << report_data_ss.str();
        main_TEX_ss << "\\hline" << endl;
        main_TEX_ss << "\\end{longtabu}" << endl;
        main_TEX_ss << "}" << endl;

        ////////////////////////////////////////////////////////////////////////
        // END Entry table creation
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        // START Equilibrium phases / decomposition reaction table
        ////////////////////////////////////////////////////////////////////////

        if(!(equilibrium_phases_header_TEX_ss.str().empty() && equilibrium_phases_TEX_ss.str().empty() && reaction_chem_eq_TEX_ss.str().empty())) {
          main_TEX_ss << "\\vspace{-20pt}" << endl;
          main_TEX_ss << "\\begin{longtabu}{X[1,l]X[3,r]}" << endl;
          if(m_coord_groups[i].m_is_on_hull) {
            if(include_equilibrium_phases && !(equilibrium_phases_header_TEX_ss.str().empty() && equilibrium_phases_TEX_ss.str().empty())) {
              main_TEX_ss << equilibrium_phases_header_TEX_ss.str();
              main_TEX_ss << " & ";
              main_TEX_ss << equilibrium_phases_TEX_ss.str() << endl;
            }
          } else {
            if(!reaction_chem_eq_TEX_ss.str().empty()) {
              main_TEX_ss << "decomposition reaction: & ";
              main_TEX_ss << reaction_chem_eq_TEX_ss.str() << endl;
            }
          }
          main_TEX_ss << "\\end{longtabu}" << endl;
        }

        ////////////////////////////////////////////////////////////////////////
        // END Equilibrium phases / decomposition reaction table
        ////////////////////////////////////////////////////////////////////////

        equilibrium_phases_header_TEX_ss.str("");
        equilibrium_phases_TEX_ss.str("");
        reaction_chem_eq_TEX_ss.str("");
        if(i != m_coord_groups.size() - 1) {main_TEX_ss << "\\vspace{-20pt}" << endl;}
      }
      _report_data_ss.str("");
      report_data_ss.str("");
      reaction_chem_eq_TEX_ss.str("");
    }

    ////////////////////////////////////////////////////////////////////////////
    // END Stoichiometry group points loop
    ////////////////////////////////////////////////////////////////////////////
  }
  //////////////////////////////////////////////////////////////////////////////
  // END Stoichiometry group loop
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // END Report
  //////////////////////////////////////////////////////////////////////////////

  main_TEX_ss << "\\end{document}" << endl;

  //////////////////////////////////////////////////////////////////////////////
  // START Create tmp directory for compilation of .tex document
  //////////////////////////////////////////////////////////////////////////////

  string PWD = aurostd::execute2string(XHOST.command("pwd")) + "/";
  string path = getPath(m_cflags,*p_FileMESSAGE, *p_oss);
  string destination = path+main_PDF_file;
  string LATEX_dir = aurostd::TmpDirectoryCreate("chullLATEX");
  chdir(LATEX_dir.c_str());
  aurostd::stringstream2file(main_TEX_ss, main_TEX_file);
  if(!aurostd::FileExist(main_TEX_file)) {
    chdir(PWD.c_str());
    aurostd::RemoveDirectory(LATEX_dir);
    throw CHullRuntimeError(soliloquy,"Could not write "+main_TEX_file+" to "+LATEX_dir);
  }
  if(print_aflow_logo) {
    aurostd::base642bin(_AFLOW_LOGO_BASE64_, aflow_logo_file);
    if(!aurostd::FileExist(aflow_logo_file)) {
      chdir(PWD.c_str());
      aurostd::RemoveDirectory(LATEX_dir);
      throw CHullRuntimeError(soliloquy,"Could not write "+aflow_logo_file+" to "+LATEX_dir);
    }
  }
  command.str("");
  stringstream rawPDFLaTeXCommand;
  uint num_compile;
  command << XHOST.command("pdflatex") << " ";
  rawPDFLaTeXCommand << XHOST.command("pdflatex") << " ";
  if(!show_latex_output) {command << "-interaction=batchmode ";}
  if(image_only) {
    command << "--jobname=" << main_file << " " << main_TEX_file << " ";
    rawPDFLaTeXCommand << "--jobname=" << main_file << " " << main_TEX_file << " ";
    num_compile = 1;
  } else {
    command << main_TEX_file << " ";
    rawPDFLaTeXCommand << main_TEX_file << " ";

    //if(doc_only && no_links) {
    if(no_links) {num_compile = 1;}
    else {num_compile = 2;}
  }
  if(!show_latex_output) {command << "1>/dev/null ";}
  message << "Attempting to compile " << main_TEX_file;  //CO 180220 //the .tex file";
  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

  if(show_latex_output) {
    if(latex_interactive_mode) {
      // will not save output, allows you to interact with LaTEX
      for (uint i = 0; i < num_compile; i++) {aurostd::execute(command.str());}
      // saves output
    } else {
      for (uint i = 0; i < num_compile; i++) {*p_oss << aurostd::execute2string(command.str()) << endl;}
    }
  } else {
    // no output to save
    for (uint i = 0; i < num_compile; i++) {aurostd::execute(command.str());}
  }
  if(!aurostd::FileExist(main_PDF_file)) {
    message << main_PDF_file << " was not created successfully, likely a LaTeX issue";
    pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_ERROR_);
    message << "Moving " << main_TEX_file;
    if(print_aflow_logo){message << " and " << aflow_logo_file;}
    message << " to " << path; //CO 180220 - current directory";
    pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
    message << "Try running \"" << aurostd::RemoveWhiteSpacesFromTheBack(rawPDFLaTeXCommand.str()) << "\"";
    pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
    files_2_move.clear(); //only move these files
    files_2_move.push_back(main_TEX_file);
    if(print_aflow_logo){files_2_move.push_back(aflow_logo_file);}
    aurostd::MoveFiles(files_2_move, path);
    chdir(PWD.c_str());
    aurostd::RemoveDirectory(LATEX_dir);
    throw CHullRuntimeError(soliloquy,"Issues compiling .tex file");
  }
  files_2_move.push_back(main_PDF_file);
  if(keep_tex) {
    files_2_move.push_back(main_TEX_file);
    if(print_aflow_logo){files_2_move.push_back(aflow_logo_file);}
    message << "Moving " << main_TEX_file << " and " << aflow_logo_file << " to " << path; //CO 180220 - current directory";
    pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
  }
  if(!aurostd::MoveFiles(files_2_move, path)) {
    chdir(PWD.c_str());
    aurostd::RemoveDirectory(LATEX_dir);
    throw CHullRuntimeError(soliloquy,"Unable to move files out of temporary compilation directory");
  }
  chdir(PWD.c_str());
  aurostd::RemoveDirectory(LATEX_dir);
  if(!aurostd::FileExist(destination)){throw CHullRuntimeError(soliloquy,"Unable to write "+main_PDF_file+" to "+path);}
  message << main_PDF_file << " was created successfully, see destination=" << path;
  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_COMPLETE_);

  //////////////////////////////////////////////////////////////////////////////
  // END Create tmp directory for compilation of .tex document
  //////////////////////////////////////////////////////////////////////////////
}

string ConvexHull::getPlainTextHeader() const {
  stringstream main_text_ss;main_text_ss.str("");
  stringstream misc_ss;misc_ss.str("");
  const uint width_page = 130;   // helps with formatting of output
  misc_ss << "AFLOW V" << string(AFLOW_VERSION) << " Materials Snapshot";
  main_text_ss << aurostd::PaddedPOST(misc_ss.str(), width_page / 2); misc_ss.str("");
  misc_ss << AFLOW_WEB;
  main_text_ss << aurostd::PaddedPRE(misc_ss.str(), width_page / 2); misc_ss.str("");
  main_text_ss << endl;

  main_text_ss << aurostd::PaddedPOST(aurostd::get_datetime_formatted(true), width_page / 2);
  misc_ss << "count=" << getEntriesCount();
  main_text_ss << aurostd::PaddedPRE(misc_ss.str(), width_page / 2); misc_ss.str("");
  main_text_ss << endl;
  
  //cite as
  main_text_ss << endl;
  main_text_ss << "Use of this data welcomes reference to the following publication:" << endl;
  main_text_ss << "    " << CHULL_AUTHORS << "," << endl;
  main_text_ss << "    " << CHULL_TITLE << "," << endl;
  main_text_ss << "    " << CHULL_JOURNAL << "." << endl;
  main_text_ss << endl;
  return main_text_ss.str();
}

string ConvexHull::getJSONHeader() const {
  vector<string> vout;
  stringstream misc_ss;misc_ss.str("");
  
  misc_ss << "\"aflow_version\":\"aflow" << string(AFLOW_VERSION) << "\"";
  vout.push_back(misc_ss.str()); misc_ss.str("");

  misc_ss << "\"aflow_website\":\"" << AFLOW_WEB << "\"";
  vout.push_back(misc_ss.str()); misc_ss.str("");

  misc_ss << "\"datetime\":\"" << aurostd::get_datetime_formatted(false) << "\"";
  vout.push_back(misc_ss.str()); misc_ss.str("");
  
  misc_ss << "\"count\":\"" << getEntriesCount() << "\"";
  vout.push_back(misc_ss.str()); misc_ss.str("");
  
  misc_ss << "\"publication\":\"";
  misc_ss << CHULL_AUTHORS << ", ";
  misc_ss << CHULL_TITLE << ", ";
  misc_ss << CHULL_JOURNAL;
  misc_ss << "\"";
  vout.push_back(misc_ss.str()); misc_ss.str("");
  
  return aurostd::wrapString(aurostd::joinWDelimiter(vout,","),"{","}");
}

string ConvexHull::grabCHPointProperty(const ChullPoint& point,const string& property,char mode) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::grabCHPointProperty():";
  uint precision=COEF_PRECISION;
  string value="";
  string equilibrium_phases_delimiter="-";
  string string_wrapper="";
  string list_prefix="";
  string list_suffix="";
  string null_value="-";
  if(mode==_json_){
    equilibrium_phases_delimiter=",";
    string_wrapper="\"";
    list_prefix="[";
    list_suffix="]";
    null_value="null";
  }
  if(LDEBUG){cerr << soliloquy << " starting property=" << property << endl;}
  if(property=="compound"){value=aurostd::wrapString(point.m_entry.compound,string_wrapper);}
  else if(property=="prototype"){value=aurostd::wrapString(point.m_entry.prototype,string_wrapper);}
  else if(property=="auid"){value=aurostd::wrapString(point.m_entry.auid,string_wrapper);}
  else if(property=="aurl"){value=aurostd::wrapString(point.m_entry.aurl,string_wrapper);}
  else if(property=="url_entry_page"){value=aurostd::wrapString(ENTRY_PAGE_URL_PREFIX+point.m_entry.auid,string_wrapper);}
  else if(property=="space_group_orig"){value=aurostd::wrapString(point.m_entry.vsg.front(),string_wrapper);}
  else if(property=="space_group_relax"){value=aurostd::wrapString(point.m_entry.vsg.back(),string_wrapper);}
  else if(property=="spin_atom"){value=aurostd::utype2string(point.m_entry.spin_atom,precision,true,ROUNDOFF_TOL,FIXED_STREAM);}
  else if(property=="enthalpy_formation_atom"){value=aurostd::utype2string(Hf_atom(point,_m_),precision,true,ROUNDOFF_TOL,FIXED_STREAM);}
  else if(property=="entropic_temperature"){value=aurostd::utype2string(point.m_entry.entropic_temperature,precision,true,ROUNDOFF_TOL,FIXED_STREAM);}
  else if(property=="ground_state"){value=(point.isGState()?"true":"false");}
  else if(property=="phases_equilibrium_compound"){
    if(point.isGState()&&!point.isUnary()){ //unaries are always gstates, but do NOT have any mixture context
      //need to grab from coord_group
      uint i_coord_group;
      if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Coordgroup index not set");}
      if(m_coord_groups[i_coord_group].m_equilibrium_phases.size()==0){throw CHullLogicError(soliloquy,"Equilibrium phases not set");}
      vector<string> compounds,_compounds;
      uint i_point;
      const vector<vector<uint> >& equilibrium_phases=m_coord_groups[i_coord_group].m_equilibrium_phases;
      if(equilibrium_phases.size()){
        for(uint i=0;i<equilibrium_phases.size();i++){
          if(equilibrium_phases[i].size()==0){compounds.push_back(null_value);continue;}
          _compounds.clear();
          for(uint j=0;j<equilibrium_phases[i].size();j++){
            i_point=artificialMap(equilibrium_phases[i][j]);
            if(m_points[i_point].m_has_entry){
              _compounds.push_back(aurostd::wrapString(m_points[i_point].m_entry.compound,string_wrapper));
            }else{_compounds.push_back(null_value);}
          }
          compounds.push_back(aurostd::wrapString(aurostd::joinWDelimiter(_compounds,equilibrium_phases_delimiter),list_prefix,list_suffix));
        }
        value=aurostd::wrapString(aurostd::joinWDelimiter(compounds,","),list_prefix,list_suffix);
      }
    }
  }
  else if(property=="phases_equilibrium_auid"){
    if(point.isGState()&&!point.isUnary()){
      //need to grab from coord_group
      uint i_coord_group;
      if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Coordgroup index not set");}
      if(m_coord_groups[i_coord_group].m_equilibrium_phases.size()==0){throw CHullLogicError(soliloquy,"Equilibrium phases not set");}
      vector<string> auids,_auids;
      uint i_point;
      const vector<vector<uint> >& equilibrium_phases=m_coord_groups[i_coord_group].m_equilibrium_phases;
      if(equilibrium_phases.size()){
        for(uint i=0;i<equilibrium_phases.size();i++){
          if(equilibrium_phases[i].size()==0){auids.push_back(null_value);continue;}
          _auids.clear();
          for(uint j=0;j<equilibrium_phases[i].size();j++){
            i_point=artificialMap(equilibrium_phases[i][j]);
            if(m_points[i_point].m_has_entry){
              _auids.push_back(aurostd::wrapString(m_points[i_point].m_entry.auid,string_wrapper));
            }else{_auids.push_back(null_value);}
          }
          auids.push_back(aurostd::wrapString(aurostd::joinWDelimiter(_auids,equilibrium_phases_delimiter),list_prefix,list_suffix));
        }
        value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
      }
    }
  }
  else if(property=="phases_decomposition_compound"){
    if(!point.isGState()){
      //need to grab from coord_group
      uint i_coord_group;
      if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Coordgroup index not set");}
      if(!m_coord_groups[i_coord_group].m_is_on_hull){
        if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
          vector<string> compounds;
          uint i_point;
          for(uint i=0;i<m_coord_groups[i_coord_group].m_decomp_phases.size();i++){
            i_point=artificialMap(m_coord_groups[i_coord_group].m_decomp_phases[i]);
            if((i+1<(uint)point.m_decomp_coefs.rows)&&(point.m_decomp_coefs[i+1]>=ZERO_TOL)){
              if(m_points[i_point].m_has_entry){
                compounds.push_back(aurostd::wrapString(m_points[i_point].m_entry.compound,string_wrapper));
              }else{compounds.push_back(null_value);} //already did artificialMap()
            } //else{compounds.push_back(null_value);}
          }
          value=aurostd::wrapString(aurostd::joinWDelimiter(compounds,","),list_prefix,list_suffix);
        }
      }
    }
  }
  else if(property=="phases_decomposition_auid"){
    if(!point.isGState()){
      //need to grab from coord_group
      uint i_coord_group;
      if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Coordgroup index not set");}
      if(!m_coord_groups[i_coord_group].m_is_on_hull){
        if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
          vector<string> auids;
          uint i_point;
          for(uint i=0;i<m_coord_groups[i_coord_group].m_decomp_phases.size();i++){
            i_point=artificialMap(m_coord_groups[i_coord_group].m_decomp_phases[i]);
            if((i+1<(uint)point.m_decomp_coefs.rows)&&(point.m_decomp_coefs[i+1]>=ZERO_TOL)){
              if(m_points[i_point].m_has_entry){
                auids.push_back(aurostd::wrapString(m_points[i_point].m_entry.auid,string_wrapper));
              }else{auids.push_back(null_value);} //already did artificialMap()
            } //else{auids.push_back(null_value);}
          }
          value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
        }
      }
    }
  }
  else if(property=="phases_decomposition_coefficient"){
    if(!point.isGState()){
      //need to grab from coord_group
      uint i_coord_group;
      if(!getCoordGroupIndex(point,i_coord_group)){throw CHullLogicError(soliloquy,"Coordgroup index not set");}
      if(!m_coord_groups[i_coord_group].m_is_on_hull){
        if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
          vector<double> nonzero_coefs;
          for(int i=point.m_decomp_coefs.lrows;i<=point.m_decomp_coefs.urows;i++){
            if(point.m_decomp_coefs[i]>=ZERO_TOL){nonzero_coefs.push_back(point.m_decomp_coefs[i]);}
          }
          value=aurostd::wrapString(aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(aurostd::vector2xvector<double>(nonzero_coefs),precision,true,ROUNDOFF_TOL,FIXED_STREAM),","),list_prefix,list_suffix);
        }
      }
    }
  }
  //COREY YOU ARE HERE, YOU HAVE TO FIX THIS TO INCLUDE FIXED FORMAT
  else if(property=="enthalpy_formation_atom_difference"){value=aurostd::utype2string(dist2Hull(point,_m_),precision,true,ROUNDOFF_TOL,FIXED_STREAM);}
  else if(property=="entropic_temperature_difference"){value=aurostd::utype2string(dist2Hull(point,_m_),precision,true,ROUNDOFF_TOL,FIXED_STREAM);}
  else{throw CHullLogicError(soliloquy,"Unknown property");}
  if(value.empty()){value=null_value;}
  return value;
}

string ConvexHull::grabCHFacetProperty(const ChullFacet& facet,const string& property,char mode) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::grabCHPointProperty():";
  uint precision=COEF_PRECISION;
  string value="";
  string vector_delimiter=";";
  string string_wrapper="";
  string list_prefix="";
  string list_suffix="";
  string null_value="-";
  if(mode==_json_){
    vector_delimiter=",";
    string_wrapper="\"";
    list_prefix="[";
    list_suffix="]";
    null_value="null";
  }
  if(LDEBUG){cerr << soliloquy << " starting property=" << property << endl;}
  if(property=="vertices_position"){
    vector<string> vstr;
    for(uint i=0;i<facet.m_vertices.size();i++){
      vstr.push_back(aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(facet.m_vertices[i].ch_point.h_coords,precision,true,ROUNDOFF_TOL,FIXED_STREAM),vector_delimiter));
    }
    value=aurostd::wrapString(aurostd::joinWDelimiter(aurostd::wrapVecEntries(vstr,"[","]"),","),list_prefix,list_suffix);
  }
  else if(property=="vertices_compound"){
    vector<string> compounds;
    for(uint i=0;i<facet.m_vertices.size();i++){
      if(facet.m_vertices[i].ch_point.m_has_entry){
        if(!m_points[facet.m_vertices[i].ch_index].m_entry.compound.empty()){
          compounds.push_back(aurostd::wrapString(m_points[facet.m_vertices[i].ch_index].m_entry.compound,string_wrapper));
        }else{compounds.push_back(null_value);}
      }
      else if(facet.m_vertices[i].ch_point.m_is_artificial){
        uint i_nary=facet.m_vertices[i].ch_point.m_i_nary;
        uint i_alloy=facet.m_vertices[i].ch_point.m_i_alloy;
        string elements=aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"");
        compounds.push_back(aurostd::wrapString("artificial:"+elements,string_wrapper));
      }else{throw CHullLogicError(soliloquy,"Unknown print setting");}
    }
    value=aurostd::wrapString(aurostd::joinWDelimiter(compounds,","),list_prefix,list_suffix);
  }
  else if(property=="vertices_auid"){
    vector<string> auids;
    for(uint i=0;i<facet.m_vertices.size();i++){
      if(facet.m_vertices[i].ch_point.m_has_entry){
        if(!m_points[facet.m_vertices[i].ch_index].m_entry.auid.empty()){
          auids.push_back(aurostd::wrapString(m_points[facet.m_vertices[i].ch_index].m_entry.auid,string_wrapper));
        }else{auids.push_back(null_value);}
      }
      else if(facet.m_vertices[i].ch_point.m_is_artificial){
        uint i_nary=facet.m_vertices[i].ch_point.m_i_nary;
        uint i_alloy=facet.m_vertices[i].ch_point.m_i_alloy;
        string elements=aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"");
        auids.push_back(aurostd::wrapString("artificial:"+elements,string_wrapper));
      }else{throw CHullLogicError(soliloquy,"Unknown print setting");}
    }
    value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
  }
  else if(property=="normal"){value="["+aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(facet.m_normal,precision,true,ROUNDOFF_TOL,FIXED_STREAM),vector_delimiter)+"]";}
  else if(property=="offset"){value=aurostd::utype2string(facet.m_offset,precision,true,ROUNDOFF_TOL,FIXED_STREAM);}
  else if(property=="centroid"){value="["+aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(facet.m_facet_centroid,precision,true,ROUNDOFF_TOL,FIXED_STREAM),vector_delimiter)+"]";}
  else if(property=="vertical"){value=(facet.m_is_vertical?"true":"false");}
  else if(property=="artificial"){value=(facet.m_is_artificial?"true":"false");}
  else{throw CHullLogicError(soliloquy,"Unknown property");}
  if(value.empty()){value=null_value;}
  return value;
}

vector<vector<string> > ConvexHull::getPointsData(const string& properties_str,vector<string>& headers,char mode) const {
  string soliloquy="ConvexHull::getPointsData():";
  stringstream message;

  vector<string> vproperties;
  uint i_point;
  string value;
  
  vector<vector<string> > ventries;
  aurostd::string2tokens(properties_str,vproperties,",");
  for(uint i_coord_group=0;i_coord_group<m_coord_groups.size();i_coord_group++){
    if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
    if(!m_coord_groups[i_coord_group].m_initialized){throw CHullLogicError(soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is not initialized");}
    for(uint i=0;i<m_coord_groups[i_coord_group].m_points.size();i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      const ChullPoint& point=m_points[i_point];
      if(!point.m_initialized){throw CHullLogicError(soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      if(!point.m_has_entry){continue;}
      ventries.push_back(vector<string>(0));
      for(uint j=0;j<vproperties.size();j++){
        value=grabCHPointProperty(point,vproperties[j],mode);
        ventries.back().push_back(value);
      }
    }
  }
  
  string header;
  headers.clear();
  if(mode==_json_){
  //for json response, we want TRUE keywords as they would appear in aflowlib.out
    for(uint i=0;i<vproperties.size();i++){
      header=vproperties[i];
      //add any processing here
      headers.push_back(header);
    }
  }else{
  //for text response, we decorate nicely by replacing _atom with _[/atom]
    for(uint i=0;i<vproperties.size();i++){
      header=vproperties[i];
      //while this is "pretty", it's NON-STANDARD
      //define in the paper, and leave it be
      //if(vproperties[i]=="url_entry_page"){header="entry_page_url";}
      //if(vproperties[i]=="enthalpy_formation_atom"){header="formation_enthalpy";}
      //if(vproperties[i]=="spin_atom"){header="spin";}
      //if(vproperties[i]=="phases_equilibrium_compound"){header="equilibrium_phases";}
      //if(vproperties[i]=="phases_equilibrium_auid"){header="equilibrium_phases_auids";}
      //if(vproperties[i]=="phases_decomposition_compound"){header="decomposition_phases";}
      //if(vproperties[i]=="phases_decomposition_auid"){header="decomposition_phases_auids";}
      //if(vproperties[i]=="phases_decomposition_coefficient"){header="decomposition_coefficients";}
      //if(vproperties[i]=="enthalpy_formation_atom_difference"){header="formation_enthalpy_difference";}
      //add any processing here before upper
      header=aurostd::toupper(header);
      //units are nice, but again, NON-STANDARD
      //define in the ppaer, and leave it be
      //add any processing here after upper
      //if(vproperties[i]=="enthalpy_formation_atom"){header+="_[meV/atom]";}
      //if(vproperties[i]=="entropic_temperature"){header+="_[K]";}
      //if(vproperties[i]=="spin_atom"){header+="_[mu_B/atom]";}
      //if(vproperties[i]=="enthalpy_formation_atom_difference"){header+="_[meV/atom]";}
      //if(vproperties[i]=="entropic_temperature_difference"){header+="_[K]";}
      headers.push_back(header);
    }
  }
  return ventries;
}

vector<vector<vector<vector<string> > > > ConvexHull::getFacetsData(const string& facet_properties_str,vector<string>& headers,char mode) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getFacetsData():";
  stringstream message;
  
  if(m_naries.size()<2){throw CHullLogicError(soliloquy,"No naries (larger than 1) found");}

  vector<string> vproperties;
  string value;
  vector<vector<vector<vector<string> > > > ventries;
  
  aurostd::string2tokens(facet_properties_str,vproperties,",");
  uint i_facet;
  for(uint i_nary=1;i_nary<m_naries.size();i_nary++){
    if(!m_naries[i_nary].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary["+aurostd::utype2string(i_nary)+"]");}
    if(m_naries[i_nary].m_alloys.size()==0){throw CHullLogicError(soliloquy,"No alloys found in nary["+aurostd::utype2string(i_nary)+"]");}
    if(LDEBUG){cerr << soliloquy << " looking at i_nary=" << i_nary << endl;}
    ventries.push_back(vector<vector<vector<string> > >(0));
    for(uint i_alloy=0;i_alloy<m_naries[i_nary].m_alloys.size();i_alloy++){
      if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw CHullLogicError(soliloquy,"Uninitialized nary[i_nary="+aurostd::utype2string(i_nary)+",i_alloy="+aurostd::utype2string(i_alloy)+"]");}
      if(m_naries[i_nary].m_alloys[i_alloy].m_facets.size()==0){throw CHullLogicError(soliloquy,"No facets found in nary[i_nary="+aurostd::utype2string(i_nary)+",i_alloy"+aurostd::utype2string(i_alloy)+"]");}
      if(LDEBUG){cerr << soliloquy << " looking at i_nary=" << i_nary << ",i_alloy=" << i_alloy << endl;}
      ventries.back().push_back(vector<vector<string> >(0));
      for(uint i=0;i<m_naries[i_nary].m_alloys[i_alloy].m_facets.size();i++){
        i_facet=m_naries[i_nary].m_alloys[i_alloy].m_facets[i];
        const ChullFacet& facet=m_facets[i_facet];
        if(!facet.m_initialized){throw CHullLogicError(soliloquy,"Facet[i_nary="+aurostd::utype2string(i_nary)+",i_alloy"+aurostd::utype2string(i_alloy)+",i_facet="+aurostd::utype2string(i_facet)+"] is not initialized");}
        if(LDEBUG){cerr << soliloquy << " looking at i_nary=" << i_nary << ",i_alloy=" << i_alloy << ",i_facet=" << i_facet << endl;}
        ventries.back().back().push_back(vector<string>(0));
        for(uint j=0;j<vproperties.size();j++){
          value=grabCHFacetProperty(facet,vproperties[j],mode);
          ventries.back().back().back().push_back(value);
        }
      }
    }
  }
  if(LDEBUG){cerr << soliloquy << " created ventries" << endl;}

  string header;
  headers.clear();
  if(mode==_json_){
  //for json response, we want TRUE keywords as they would appear in aflowlib.out
    for(uint i=0;i<vproperties.size();i++){
      header=vproperties[i];
      //add any processing here
      headers.push_back(header);
    }
  }else{
  //for text response, we decorate nicely by replacing _atom with _[/atom]
    for(uint i=0;i<vproperties.size();i++){
      header=vproperties[i];
      //add any processing here before upper
      header=aurostd::toupper(header);
      //add any processing here after upper
      headers.push_back(header);
    }
  }
  if(LDEBUG){cerr << soliloquy << " created headers" << endl;}
  return ventries;
}

void ConvexHull::getPlainTextColumnSizes(const vector<string>& headers,const vector<vector<string> >& ventries,vector<uint>& sizes) const {
  string soliloquy="ConvexHull::getPlainTextColumnSizes():";
  for(uint i=0;i<ventries.size();i++){
    if(headers.size()!=ventries[i].size()){throw CHullLogicError(soliloquy,"Dimension mismatch between headers and ventries");}
  }
  if(sizes.size()==0){  //initialize
    sizes.resize(headers.size());
    for(uint i=0;i<headers.size();i++){sizes[i]=headers[i].size();}
  }
  if(sizes.size()!=headers.size()){throw CHullLogicError(soliloquy,"Dimension mismatch between sizes and headers");}
  uint p_size;
  for(uint i=0;i<ventries.size();i++){
    for(uint j=0;j<ventries[i].size();j++){
      p_size=ventries[i][j].size();
      sizes[j]=std::max(sizes[j],p_size);
    }
  }
}

void ConvexHull::getPlainTextColumnSizesPoints(const vector<string>& headers,const vector<vector<string> >& ventries,vector<uint>& sizes) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getPlainTextColumnSizesPoints():";
  stringstream message;
  sizes.clear();
  getPlainTextColumnSizes(headers,ventries,sizes);
  if(LDEBUG){cerr << soliloquy << " sizes=" << sizes.size() << endl;}
  if(LDEBUG){cerr << soliloquy << " determined sizes" << endl;}
}

void ConvexHull::getPlainTextColumnSizesFacets(const vector<string>& headers,const vector<vector<vector<vector<string> > > >& ventries,vector<uint>& sizes) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::getPlainTextColumnSizesFacets():";
  stringstream message;
  sizes.clear();
  for(uint i=0;i<ventries.size();i++){
    for(uint j=0;j<ventries[i].size();j++){
      getPlainTextColumnSizes(headers,ventries[i][j],sizes);
    }
  }
  if(LDEBUG){cerr << soliloquy << " sizes=" << sizes.size() << endl;}
  if(LDEBUG){cerr << soliloquy << " determined sizes" << endl;}
}

string ConvexHull::addPlainTextTable(const vector<string>& headers,const vector<vector<string> >& ventries,const vector<uint>& sizes) const {
  stringstream out_ss;
  for(uint i=0;i<headers.size();i++){out_ss << aurostd::PaddedPOST(headers[i],sizes[i]+5);}
  out_ss << endl;
  for(uint i=0;i<ventries.size();i++){
    for(uint j=0;j<ventries[i].size();j++){
      out_ss << aurostd::PaddedPOST(ventries[i][j],sizes[j]+5);
    }
    out_ss << endl;
  }
  return out_ss.str();
}

string ConvexHull::addJSONTable(const vector<string>& headers,const vector<vector<string> >& ventries) const {
  stringstream misc_ss;misc_ss.str("");
  vector<string> _vout;_vout.clear();
  vector<string> vout;vout.clear();
  for(uint i=0;i<ventries.size();i++){
    for(uint j=0;j<ventries[i].size();j++){
      misc_ss << aurostd::wrapString(headers[j],"\"") << ":" << ventries[i][j];
      _vout.push_back(misc_ss.str()); misc_ss.str("");
    }
    vout.push_back(aurostd::wrapString(aurostd::joinWDelimiter(_vout,","),"{","}")); _vout.clear();
  }
  return aurostd::wrapString(aurostd::joinWDelimiter(vout,","),"[","]");
}

void ConvexHull::writeText(char mode) const {
  bool LDEBUG=(FALSE || XHOST.DEBUG);
  string soliloquy="ConvexHull::writeText():";
  stringstream message;
  
  if(!(mode==_txt_ || mode==_json_)){throw CHullLogicError(soliloquy,"Unknown mode");}

  if(!m_initialized){throw CHullLogicError(soliloquy,"Hull not initialized");}

  if(mode==_txt_){message << "Starting plain text generator";}
  else{message << "Starting json generator";}
  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

  bool terse_output=false;

  string properties_str_points="compound";
  properties_str_points+=",prototype";
  properties_str_points+=",auid";
  properties_str_points+=",aurl";
  if(!terse_output){properties_str_points+=",url_entry_page";}
  properties_str_points+=",space_group_orig";
  properties_str_points+=",space_group_relax";
  properties_str_points+=",spin_atom";                  //add units later
  properties_str_points+=",enthalpy_formation_atom";    //add units later
  properties_str_points+=",entropic_temperature";       //add units later
  properties_str_points+=",ground_state";
  if(!terse_output){properties_str_points+=",phases_equilibrium_compound";}
  properties_str_points+=",phases_equilibrium_auid";
  if(!terse_output){properties_str_points+=",phases_decomposition_compound";}
  properties_str_points+=",phases_decomposition_auid";
  properties_str_points+=",phases_decomposition_coefficient";
  if(m_formation_energy_hull){properties_str_points+=",enthalpy_formation_atom_difference";}  //add units later
  else{properties_str_points+=",entropic_temperature_difference";}                        //add units later
  
  string facet_properties_str="vertices_position";
  if(!terse_output){facet_properties_str+=",vertices_compound";}
  facet_properties_str+=",vertices_auid";
  facet_properties_str+=",normal";
  facet_properties_str+=",offset";
  facet_properties_str+=",centroid";
  facet_properties_str+=",vertical";
  facet_properties_str+=",artificial";

  stringstream main_text_ss;main_text_ss.str("");
  vector<string> vout;        //json only
  vector<uint> column_sizes;  //plain text only
  
  //POINTS DATA
  vector<string> headers_points;
  vector<vector<string> > ventries_points=getPointsData(properties_str_points,headers_points,mode);
  if(LDEBUG){cerr << soliloquy << " got points data" << endl;}
  
  //FACETS DATA
  vector<string> headers_facets;
  //first layer=nary, second=alloy, third=facet, fourth=properties
  vector<vector<vector<vector<string> > > > ventries_facets=getFacetsData(facet_properties_str,headers_facets,mode);
  if(LDEBUG){cerr << soliloquy << " got facets data" << endl;}
  
  //HEADER
  if(mode==_json_){vout.push_back("\"hull_data\":"+getJSONHeader());}
  else{main_text_ss << getPlainTextHeader();}
  if(LDEBUG){cerr << soliloquy << " created doc header" << endl;}
  
  //points data
  if(mode==_json_){vout.push_back("\"points_data\":"+addJSONTable(headers_points,ventries_points));}
  else{
    getPlainTextColumnSizesPoints(headers_points,ventries_points,column_sizes);
    main_text_ss << "POINTS DATA" << endl;
    main_text_ss << addPlainTextTable(headers_points,ventries_points,column_sizes);
    main_text_ss << endl;
    main_text_ss << endl;
  }
  if(LDEBUG){cerr << soliloquy << " added points data" << endl;}
  
  //facets data
  if(mode==_json_){
    stringstream misc_ss;misc_ss.str("");
    vector<string> _vout;
    for(uint i=0;i<ventries_facets.size();i++){
      for(uint j=0;j<ventries_facets[i].size();j++){
        misc_ss << "\"" << i+2 << "-nary:";
        if(m_velements.size()){misc_ss << aurostd::joinWDelimiter(alloyToElements(i+1,j),"");}
        else{misc_ss << j+1;}
        misc_ss << "\":" << addJSONTable(headers_facets,ventries_facets[i][j]);
        _vout.push_back(misc_ss.str()); misc_ss.str("");
      }
    }
    vout.push_back("\"facets_data\":"+aurostd::wrapString(aurostd::joinWDelimiter(_vout,","),"{","}"));
  }
  else{
    getPlainTextColumnSizesFacets(headers_facets,ventries_facets,column_sizes);
    for(uint i=0;i<ventries_facets.size();i++){
      for(uint j=0;j<ventries_facets[i].size();j++){
        main_text_ss << "FACETS DATA " << i+2 << "-nary ";
        if(m_velements.size()){main_text_ss << "(" << aurostd::joinWDelimiter(alloyToElements(i+1,j),"") << ")";}
        else{main_text_ss << "(" << j+1 << ")";}
        main_text_ss << endl;
        main_text_ss << addPlainTextTable(headers_facets,ventries_facets[i][j],column_sizes);
        if(!(i==ventries_facets.size()-1 && j==ventries_facets[i].size()-1)){main_text_ss << endl;}
      }
      if(i!=ventries_facets.size()-1){main_text_ss << endl;}
    }
  }
  if(LDEBUG){cerr << soliloquy << " added facets data" << endl;}
  
  if(mode==_json_){main_text_ss << aurostd::wrapString(aurostd::joinWDelimiter(vout,","),"{","}");}

  string file_name="aflow_"+aurostd::joinWDelimiter(m_velements,"")+"_hull";
  if(mode==_json_){file_name+=".json";}
  else{file_name+=".txt";}
  
  if(m_cflags.flag("CHULL::SCREEN_ONLY")){
    *p_oss << main_text_ss.str();
    return;
  }
  
  if(LDEBUG){cerr << soliloquy << " now writting to file" << endl;}
  string path = getPath(m_cflags,*p_FileMESSAGE, *p_oss);
  string destination = path + file_name;
  aurostd::stringstream2file(main_text_ss,destination);
  if(!aurostd::FileExist(destination)){throw CHullRuntimeError(soliloquy,"Unable to write "+file_name+" to "+path);}
  message << file_name << " was created successfully, see destination=" << path;
  pflow::logger(soliloquy,message,*p_FileMESSAGE,*p_oss,_LOGGER_COMPLETE_);
}

void ConvexHull::writeWebApp() const {
  string soliloquy = "ConvexHull::writeWebApp():";
  stringstream message;
  pflow::logger(soliloquy, "Starting web-specific JSONifier", *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

  // initializing stringstreams to use
  stringstream main_JSON_ss;
  stringstream id_data_JSON_ss;
  stringstream species_data_JSON_ss;
  vector<string> points_data_JSON_vs;
  vector<string> distances_data_JSON_vs;
  stringstream distances_data_JSON_ss;
  vector<string> stoich_comp_JSON_vs;
  stringstream stoich_comp_JSON_ss;
  vector<string> stoich_data_JSON_vs;
  stringstream stoich_data_JSON_ss;
  vector<string> stoich_points_data_JSON_vs;
  vector<string> vertices_data_JSON_vs;
  stringstream vertices_data_JSON_ss;
  vector<string> hull_points_data_JSON_vs;
  stringstream hull_points_data_JSON_ss;
  vector<string> planes_data_JSON_vs;
  vector<string> decomp_data_JSON_vs;
  stringstream decomp_data_JSON_ss;
  stringstream data_helper_ss;
  stringstream num_ss;  // no precision, for properties calculated by AFLOW

  // initializing some strings
  string main_JSON_file;
  string input;

  // creating name of output file
  input=aurostd::joinWDelimiter(m_velements,"");
  main_JSON_file="aflow_"+input+"_hull.json";
  species_data_JSON_ss << aurostd::joinWDelimiter(aurostd::wrapVecEntries(m_velements,"\""),",");
  //for (uint i = 0; i < m_velements.size(); i++) {
  //  main_JSON_file.append(m_velements[i]);
  //  species_data_JSON_ss << "\"" << m_velements[i] << "\"";
  //  if(i != m_velements.size() - 1) {
  //    species_data_JSON_ss << ",";
  //  }
  //}
  //input = main_JSON_file;
  //main_JSON_file.append("_hull.json");

  // other initializations
  bool stoich_groups_set;
  xvector<double> coord;
  xvector<double> normal;

  //////////////////////////////////////////////////////////////////////////////
  // START Stoichiometry group loop
  //////////////////////////////////////////////////////////////////////////////

  uint i_point,i_phase;
  for (uint i = 0; i < m_coord_groups.size(); i++) {
    stoich_groups_set = false;

    ////////////////////////////////////////////////////////////////////////////
    // START Stoichiometry group points loop
    ////////////////////////////////////////////////////////////////////////////

    for (uint j = 0; j < m_coord_groups[i].m_points.size(); j++) {
      //////////////////////////////////////////////////////////////////////////
      // START Entries filter
      //////////////////////////////////////////////////////////////////////////
      i_point=m_coord_groups[i].m_points[j];
      const ChullPoint& point = m_points[i_point];
      const aflowlib::_aflowlib_entry& entry = point.m_entry;

      //////////////////////////////////////////////////////////////////////////
      // END Entries filter
      //////////////////////////////////////////////////////////////////////////

      if(!stoich_groups_set) {
        ////////////////////////////////////////////////////////////////////////
        // START Stoichiometry group properties output
        ////////////////////////////////////////////////////////////////////////

        stoich_data_JSON_ss << "{";
        // get stoich id and stoichiometries at the same time
        // id_data_JSON_ss will take care of id
        for (uint j = 0; j < (uint)point.m_elements_present.rows; j++) {
          if(point.m_elements_present[j]==1){
            stoich_comp_JSON_ss << "{";
            stoich_comp_JSON_ss << "\"element\":\"" << m_velements[j] << "\",";
            id_data_JSON_ss << m_velements[j] << aurostd::utype2string(point.s_coords[j],CHULL_PRECISION); // make id out of nonzero components
            stoich_comp_JSON_ss << "\"stoichiometry\":" << aurostd::utype2string(point.s_coords[j],CHULL_PRECISION) << "}";
            stoich_comp_JSON_vs.push_back(stoich_comp_JSON_ss.str());
            stoich_comp_JSON_ss.str("");
          }
        }
        stoich_data_JSON_ss << "\"stoichiometries\":[" << aurostd::joinWDelimiter(stoich_comp_JSON_vs, ',') << "],";
        stoich_data_JSON_ss << "\"id\":\"" << id_data_JSON_ss.str() << "\",";
        id_data_JSON_ss.str("");
        // get is_hull
        stoich_data_JSON_ss << "\"isGroundState\":" << (m_coord_groups[i].m_is_on_hull?"true":"false") << ",";
        // get endPoint
        stoich_data_JSON_ss << "\"endPoint\":" << (m_coord_groups[i].m_i_nary==0?"true":"false") << ",";
        // get decomposition information for all phases
        const vector<uint>& decomposition_phases = m_coord_groups[i].m_decomp_phases;
        const xvector<double>& decomposition_coefficients = m_coord_groups[i].m_decomp_coefs;

        ////////////////////////////////////////////////////////////////////////
        // START Gathering info about decomposition reaction (equilibrium phase
        // stuff handled by javascript with FACES)
        ////////////////////////////////////////////////////////////////////////

        if(!decomposition_phases.empty() && scalar_product(decomposition_coefficients, decomposition_coefficients) >= ZERO_TOL) {
          if(decomposition_phases.size() != (uint)decomposition_coefficients.rows-1) {
            throw CHullLogicError(soliloquy,"Size of decomposition phases != size of decomposition coefficients for coordgroup["+aurostd::utype2string(i)+"]");
          }
          for (uint k = 0; k < decomposition_phases.size(); k++) {
            if(abs(decomposition_coefficients(k+1)) < ZERO_TOL) {continue;}
            decomp_data_JSON_ss << "{";
            i_phase=artificialMap(decomposition_phases[k]);
            const ChullPoint& dc_phase=m_points[i_phase];
            if(!dc_phase.m_has_entry) {
              // we need to adjust for missing unaries
              // look for coords
              decomp_data_JSON_ss << "\"entry\":\"" << AFLOW_HULL_ENDPOINT_STRING << ":" << aurostd::joinWDelimiter(alloyToElements(dc_phase),"") << "\",";
            } else {
              const aflowlib::_aflowlib_entry& equation_entry = dc_phase.m_entry;
              decomp_data_JSON_ss << "\"entry\":\"" << equation_entry.auid << "\",";
            }
            decomp_data_JSON_ss << "\"coefficient\":" << aurostd::utype2string(decomposition_coefficients(k+1),CHULL_PRECISION);
            decomp_data_JSON_ss << "}";
            decomp_data_JSON_vs.push_back(decomp_data_JSON_ss.str());
            decomp_data_JSON_ss.str("");
          }
        }
        // print even if empty
        stoich_data_JSON_ss << "\"decomposition_phases\":[" << aurostd::joinWDelimiter(decomp_data_JSON_vs, ',') << "],";
        decomp_data_JSON_vs.clear();
        // filling in "points" is last
        stoich_groups_set = true;

        ////////////////////////////////////////////////////////////////////////
        // END Gathering info about decomposition reaction
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        // END Stoichiometry group properties output
        ////////////////////////////////////////////////////////////////////////
      }

      //////////////////////////////////////////////////////////////////////////
      // START Entry properties output
      //////////////////////////////////////////////////////////////////////////

      if(point.m_has_entry) {
        data_helper_ss << "\"" << entry.auid << "\"";
        stoich_points_data_JSON_vs.push_back(data_helper_ss.str());
        data_helper_ss.str("");
        // remove artificial points from distances
        distances_data_JSON_ss << "{";
        distances_data_JSON_ss << "\"auid\":";
      }
      // get points, distances, vertices
      if(point.m_is_g_state) {
        hull_points_data_JSON_ss << "{";
        hull_points_data_JSON_ss << "\"auid\":";  // why not entry? or all auid? why two different names?
      }
      if(!point.m_has_entry) {
        data_helper_ss << "\"" << AFLOW_HULL_ENDPOINT_STRING << ":" << aurostd::joinWDelimiter(alloyToElements(point),"") << "\"";
        if(point.m_is_g_state) {hull_points_data_JSON_ss << data_helper_ss.str();}
      } else {
        data_helper_ss << "\"" << entry.auid << "\"";
        points_data_JSON_vs.push_back(data_helper_ss.str());
        distances_data_JSON_ss << data_helper_ss.str();
        if(point.m_is_g_state) {hull_points_data_JSON_ss << data_helper_ss.str();}
        data_helper_ss.str("");
        // wrap up distances data
        distances_data_JSON_ss << ",";
        distances_data_JSON_ss << "\"distanceToHull\":" << aurostd::utype2string(chull::convertUnits(point.m_dist_2_hull, _std_),CHULL_PRECISION);
        // ADDED BY EGOSS
        //
        // Changed distances_data to be points data. I believe 
        // points_data_JSON may be removed and replaced with this.
        //
        distances_data_JSON_ss << ",";
        distances_data_JSON_ss << "\"compound\": \""<< entry.compound << "\"";
        distances_data_JSON_ss << ",";
        distances_data_JSON_ss << "\"composition\":[";
        // explicit dimensions
        const xvector<double>& coord = point.s_coords;
        for (uint k = 0; k < (uint)coord.rows; k++) {
          distances_data_JSON_ss << aurostd::utype2string(coord(k),CHULL_PRECISION);  // is 3 digits okay? I normally do 15
          if(k!=(uint)coord.rows-1){distances_data_JSON_ss << ",";}
        }
        distances_data_JSON_ss << "],";
        // fix for unaries, set to 0
        if(!point.m_has_entry) {  // these are only hull_members, so they only happen to
          // endpoints
          // enthalpy of formation, row 4
          // no need for precision for next few columns, leave it same way as
          // received from AFLOW
          distances_data_JSON_ss << "\"enthalpyFormationAtom\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
          distances_data_JSON_ss << ",";
          // entropic temperature, row 5
          distances_data_JSON_ss << "\"entropicTemperature\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
        } else {
          // enthalpy of formation, row 4
          // no need for precision for next few columns, leave it same way as
          // received from AFLOW
          num_ss << chull::Hf_atom(entry, _std_);
          distances_data_JSON_ss << "\"enthalpyFormationAtom\":" << num_ss.str();
          distances_data_JSON_ss << ",";
          num_ss.str("");
          // entropic temperature, row 5
          num_ss << chull::Ts(entry);
          distances_data_JSON_ss << "\"entropicTemperature\":" << num_ss.str();
          num_ss.str("");
        }
        distances_data_JSON_ss << "}";
        distances_data_JSON_vs.push_back(distances_data_JSON_ss.str());
        distances_data_JSON_ss.str("");
      }
      // distances
      // vertices
      if(point.m_is_g_state) {
        hull_points_data_JSON_ss << ",";
        hull_points_data_JSON_ss << "\"compound\": \""<< entry.compound << "\"";
        hull_points_data_JSON_ss << ",";
        hull_points_data_JSON_ss << "\"composition\":[";
        // explicit dimensions
        const xvector<double>& coord = point.s_coords;
        for (uint k = 0; k < (uint)coord.rows; k++) {
          hull_points_data_JSON_ss << aurostd::utype2string(coord(k),CHULL_PRECISION);  // is 3 digits okay? I normally do 15
          if(k!=(uint)coord.rows-1){hull_points_data_JSON_ss << ",";}
        }
        // implicit dimension
        hull_points_data_JSON_ss << "],";
        // fix for unaries, set to 0
        if(!point.m_has_entry) {  // these are only hull_members, so they only happen to
          // endpoints
          // enthalpy of formation, row 4
          // no need for precision for next few columns, leave it same way as
          // received from AFLOW
          hull_points_data_JSON_ss << "\"enthalpyFormationAtom\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
          hull_points_data_JSON_ss << ",";
          // entropic temperature, row 5
          hull_points_data_JSON_ss << "\"entropicTemperature\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
        } else {
          // enthalpy of formation, row 4
          // no need for precision for next few columns, leave it same way as
          // received from AFLOW
          num_ss << chull::Hf_atom(entry, _std_);
          hull_points_data_JSON_ss << "\"enthalpyFormationAtom\":" << num_ss.str();
          hull_points_data_JSON_ss << ",";
          num_ss.str("");
          // entropic temperature, row 5
          num_ss << chull::Ts(entry);
          hull_points_data_JSON_ss << "\"entropicTemperature\":" << num_ss.str();
          num_ss.str("");
        }
        hull_points_data_JSON_ss << "}";
        hull_points_data_JSON_vs.push_back(hull_points_data_JSON_ss.str());
        hull_points_data_JSON_ss.str("");
      }

      //////////////////////////////////////////////////////////////////////////
      // END Entry properties output
      //////////////////////////////////////////////////////////////////////////
    }
    if(stoich_groups_set) {
      stoich_data_JSON_ss << "\"points\":[" << aurostd::joinWDelimiter(stoich_points_data_JSON_vs, ',') << "]";
      stoich_data_JSON_ss << "}";
      stoich_data_JSON_vs.push_back(stoich_data_JSON_ss.str());
      stoich_points_data_JSON_vs.clear();
      stoich_data_JSON_ss.str("");
    }

    ////////////////////////////////////////////////////////////////////////////
    // END Stoichiometry group points loop
    ////////////////////////////////////////////////////////////////////////////
  }

  //////////////////////////////////////////////////////////////////////////////
  // END Stoichiometry group loop
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // START Grabbing planes data
  //////////////////////////////////////////////////////////////////////////////
  // index specific, so we can't loop through stoichGroups

  for (uint i = 0; i < m_facets.size(); i++) {
    const xvector<double> normal = m_facets[i].m_normal;
    if(!m_facets[i].m_is_vertical){
      data_helper_ss << "[" << aurostd::joinWDelimiter(m_facets[i].getCHIndices(), ',') << "]";
      planes_data_JSON_vs.push_back(data_helper_ss.str());
      data_helper_ss.str("");
    }
  }
  //////////////////////////////////////////////////////////////////////////////
  // END Grabbing planes data
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // START Grabbing vertex data (for 3-D visualization of hull)
  //////////////////////////////////////////////////////////////////////////////
  // index specific, so we can't loop through stoichGroups

  vector<uint> vertices=getHullPoints(false);
  for (uint i = 0; i < vertices.size(); i++) {
    vertices_data_JSON_ss << "{";
    vertices_data_JSON_ss << "\"auid\":";  // why not entry? or all auid? why two different names?

    const ChullPoint& point = m_points[vertices[i]];
    const aflowlib::_aflowlib_entry& entry = point.m_entry;
    const xvector<double>& coord = point.s_coords;

    if(!point.m_has_entry) {
      vertices_data_JSON_ss << "\"" << AFLOW_HULL_ENDPOINT_STRING << ":" << aurostd::joinWDelimiter(alloyToElements(point),"") << "\"";
    } else {vertices_data_JSON_ss << "\"" << entry.auid << "\"";}

    vertices_data_JSON_ss << ",";
    vertices_data_JSON_ss << "\"compound\": \"" << entry.compound << "\","; 
    vertices_data_JSON_ss << "\"composition\":[";
    // explicit dimensions
    for (uint k = 0; k < (uint)coord.rows; k++) {
      vertices_data_JSON_ss << aurostd::utype2string(coord(k),CHULL_PRECISION); // is 3 digits okay? I normally do 15
      if(k!=(uint)coord.rows-1){vertices_data_JSON_ss << ",";}
    }
    vertices_data_JSON_ss << "],";
    // fix for unaries, set to 0
    if(!point.m_has_entry) {  // these are only hull_members, so they only happen to
      // endpoints
      // enthalpy of formation, row 4
      // no need for precision for next few columns, leave it same way as
      // received from AFLOW
      vertices_data_JSON_ss << "\"enthalpyFormationAtom\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
      vertices_data_JSON_ss << ",";
      // entropic temperature, row 5
      vertices_data_JSON_ss << "\"entropicTemperature\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
    } else {
      // enthalpy of formation, row 4
      // no need for precision for next few columns, leave it same way as
      // received from AFLOW
      num_ss << chull::Hf_atom(entry, _std_);
      vertices_data_JSON_ss << "\"enthalpyFormationAtom\":" << num_ss.str();
      vertices_data_JSON_ss << ",";
      num_ss.str("");
      // entropic temperature, row 5
      num_ss << chull::Ts(entry);
      vertices_data_JSON_ss << "\"entropicTemperature\":" << num_ss.str();
      num_ss.str("");
    }
    vertices_data_JSON_ss << "}";
    vertices_data_JSON_vs.push_back(vertices_data_JSON_ss.str());
    vertices_data_JSON_ss.str("");
  }
  //////////////////////////////////////////////////////////////////////////////
  // END Grabbing vertex data
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // START Output amalgamation and writing
  //////////////////////////////////////////////////////////////////////////////

  main_JSON_ss << "{";
  main_JSON_ss << "\"name\":\"" << input << "\",";
  main_JSON_ss << "\"species\":[" << species_data_JSON_ss.str() << "],";
  species_data_JSON_ss.str("");
  // CHANGE BY EGOSS 
  // replaced points_data_JSON_vs with distance_data_JSON_vs
  //
  // OLD
  //main_JSON_ss << "\"points\":[" << aurostd::joinWDelimiter(points_data_JSON_vs, ',')
  //             << "],";
  //points_data_JSON_vs.clear();
  main_JSON_ss << "\"points\":[" << aurostd::joinWDelimiter(distances_data_JSON_vs, ',') << "],";
  distances_data_JSON_vs.clear();
  main_JSON_ss << "\"groundStates\":[" << aurostd::joinWDelimiter(hull_points_data_JSON_vs, ',') << "],";
  hull_points_data_JSON_vs.clear();
  main_JSON_ss << "\"vertices\":[" << aurostd::joinWDelimiter(vertices_data_JSON_vs, ',') << "],";
  vertices_data_JSON_vs.clear();
  // CHANGE BY EGOSS
  // distanceToHull is removed. Now distances are contained within the entries 
  // of points
  //
  //main_JSON_ss << "\"distanceToHull\":["
  //             << aurostd::joinWDelimiter(distances_data_JSON_vs, ',') << "],";
  //distances_data_JSON_vs.clear();

  // CHANGE BY EGOSS
  // At this time I do not require stoichiometryGroups for the visualization. 
  // It should be hidden behind a flag for now.

  if(false) {
    main_JSON_ss << "\"stoichiometryGroups\":[" << aurostd::joinWDelimiter(stoich_data_JSON_vs, ',') << "],";
    stoich_data_JSON_vs.clear();
  }

  main_JSON_ss << "\"faces\":[" << aurostd::joinWDelimiter(planes_data_JSON_vs, ',') << "]";
  planes_data_JSON_vs.clear();  // no comma
  main_JSON_ss << "}";

  if(m_cflags.flag("CHULL::SCREEN_ONLY")){
    *p_oss << main_JSON_ss.str();
    return;
  }

  string path = getPath(m_cflags,*p_FileMESSAGE, *p_oss);
  string destination = path + main_JSON_file;
  aurostd::stringstream2file(main_JSON_ss, destination);
  if(!aurostd::FileExist(destination)) {throw CHullRuntimeError(soliloquy,"Could not write "+main_JSON_file+" to "+path);}

  //////////////////////////////////////////////////////////////////////////////
  // END Output amalgamation and writing
  //////////////////////////////////////////////////////////////////////////////

  message << main_JSON_file << " was created successfully, see destination=" << path;
  pflow::logger(soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_COMPLETE_);
}

void ConvexHull::writeAPool() const {
}

bool ConvexHull::sortWithinCoordGroup::operator() (uint i,uint j) {
  //ascending order
  string soliloquy="ConvexHull::sortWithinCoordGroup::operator():";
  if( (i>m_points.size()-1) || (j>m_points.size()-1) ) {throw CHullLogicError(soliloquy,"Invalid index within CoordGroup");}  //safety
  const ChullPoint& ci=m_points[i];
  const ChullPoint& cj=m_points[j];
  if(ci.isGState()!=cj.isGState()){return ci.isGState()>cj.isGState();}
  //always sort by last coord first
  bool energy_sort=(m_sort_energy_ascending ? (ci.getLastCoord()<cj.getLastCoord()) : (ci.getLastCoord()>cj.getLastCoord()));
  if(ci.m_has_entry && cj.m_has_entry){
    //if entry, then we also sort by proto, compound, and then aurl to make final print out pretty
    return ( energy_sort ||
               ((ci.getLastCoord() == cj.getLastCoord()) && 
                (ci.m_entry.prototype<cj.m_entry.prototype)) ||
               ((ci.getLastCoord() == cj.getLastCoord()) &&
                (ci.m_entry.prototype == cj.m_entry.prototype) && 
                (ci.m_entry.compound<cj.m_entry.compound)) ||
               ((ci.getLastCoord() == cj.getLastCoord()) &&
                (ci.m_entry.prototype == cj.m_entry.prototype) && 
                (ci.m_entry.compound == cj.m_entry.compound) && 
                (ci.m_entry.aurl<cj.m_entry.aurl)) );  //aurl is guaranteed to be unique (more so than auid)
  }else{return energy_sort;}
}

bool ConvexHull::sortCHullPoints::operator() (uint i,uint j) const{
  string soliloquy="ConvexHull::sortCHullPoints::operator():";
  if(i>m_points.size()-1 || j>m_points.size()-1){throw CHullLogicError(soliloquy,"Invalid index for m_points");}
  const ChullPoint& ci=m_points[i];
  const ChullPoint& cj=m_points[j];
  sortThermoPoints stp(m_sort_stoich_ascending,m_sort_energy_ascending);
  return stp.operator()(ci,cj);
}

bool ConvexHull::sortFacetsByPoints::operator() (const ChullFacet& fi,const ChullFacet& fj) const {
  string soliloquy="ConvexHull::sortFacetsByPoints::operator():";
  if(fi.m_vertices.size()!=fj.m_vertices.size()){throw CHullLogicError(soliloquy,"Dimension mismatch among facets");} //return m_ascending_order ? fi.m_vertices.size()<rj.m_vertices.size() : fi.m_vertices.size()>rj.m_vertices.size();}
  if(fi.m_normal.rows!=fj.m_normal.rows){throw CHullLogicError(soliloquy,"Dimension mismatch between facet normals");}
  if(!(fi.m_initialized&&fj.m_initialized)){throw CHullLogicError(soliloquy,"Uninitialized facet");}       //ensure we have inward pointing normal and angle
  
  if(m_auto_sort_energy){
    if(fi.m_in_lower_hemisphere!=fj.m_in_lower_hemisphere){return fi.m_in_lower_hemisphere>fj.m_in_lower_hemisphere;} //lower hemisphere first
    if(fi.m_is_vertical!=fj.m_is_vertical){return fi.m_is_vertical>fj.m_is_vertical;} //vertical first
  }

  for(uint i=0;i<fi.m_vertices.size();i++){
    if(fi.m_vertices[i].ch_index!=fj.m_vertices[i].ch_index){
      const ChullPoint& ci=m_points[fi.m_vertices[i].ch_index];
      const ChullPoint& cj=m_points[fj.m_vertices[i].ch_index];
      bool sort_stoich_ascending=m_sort_stoich_ascending;
      bool sort_energy_ascending=m_sort_energy_ascending;
      if(m_auto_sort_stoich){sort_stoich_ascending=!fi.m_in_lower_hemisphere;} //left to right in lower hemisphere
      if(m_auto_sort_energy){sort_energy_ascending=fi.m_in_lower_hemisphere;}  //bottom to top in lower hemisphere
      sortThermoPoints stp(sort_stoich_ascending,sort_energy_ascending);
      return stp.operator()(ci,cj);
    }
  }
  
  return false;
}
} // namespace chull

// ***************************************************************************
// *                                                                         *
// *           Aflow STEFANO CURTAROLO - Duke University 2003-2018           *
// *           Aflow COREY OSES - Duke University 2013-2018                  *
// *                                                                         *
// ***************************************************************************
