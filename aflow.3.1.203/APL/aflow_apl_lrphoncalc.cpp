#include "aflow_apl.h"

namespace apl {

// ///////////////////////////////////////////////////////////////////////////
LinearResponsePC::LinearResponsePC(Supercell& sc, StrPairs& strpair, _xinput& xinput, //_xvasp& xvasp,
                                   _aflags& aflags, _kflags& kflags,
                                   _xflags& xflags, //_vflags& vflags, 
                                   string& AflowIn,
                                   Logger& l)
    : PhononCalculator(sc, strpair, xinput, aflags, kflags, xflags, AflowIn, l) { //xvasp, aflags, kflags, vflags, l) {
  _isPolarMaterial = false;
}

// ///////////////////////////////////////////////////////////////////////////
LinearResponsePC::~LinearResponsePC() {
  clear();
}

// ///////////////////////////////////////////////////////////////////////////
void LinearResponsePC::clear() {
}

//////////////////////////////////////////////////////////////////////////////
void LinearResponsePC::calculateForceFields() {
  // Check if supercell is already built
  if (!_supercell.isConstructed()) {
    throw APLRuntimeError("apl::LinearResponsePC::calculateForceFields(); The supercell structure has not been initialized yet.");
  }

  // Do calculation an additional calculations for polar materials
  bool halfStageBreak = false;
  if (_isPolarMaterial) {
    try {
      // if tarred and compressed directory exists...


      // COREY CHECK THIS
      deque<string> vext; aurostd::string2tokens(".bz2,.xz,.gz",vext,",");vext.push_front(""); // cheat for void string
      string tarfilename =_AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_ + ".tar";
      for(uint iext=0;iext<vext.size();iext++) {
	if (aurostd::FileExist(tarfilename+vext.at(iext))) {
	  // We will extract only what we need OUTCAR and LOCK...
	  if(_kbinFlags.AFLOW_MODE_VASP)
	    aurostd::execute(string("tar -xf ") + tarfilename + vext.at(iext) + " --wildcards "+"/OUTCAR*"); 
	  if(_kbinFlags.AFLOW_MODE_AIMS)
	    aurostd::execute(string("tar -xf ") + tarfilename + vext.at(iext) + " --wildcards "+"/aims.out*");
	}
      }
      //                 " --wildcards "
      //                 " " +
      //                 _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_ + "/OUTCAR*" +
      //                 " " + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_ + "/" + _AFLOWLOCK_);  //CO
      

      // Calc. Born effective charge tensors and dielectric constant matrix
      runVASPCalculationsBE();

      // Parse it from OUTCAR
      if(_kbinFlags.AFLOW_MODE_VASP){readBornEffectiveChargesFromOUTCAR();}
      if(_kbinFlags.AFLOW_MODE_AIMS){readBornEffectiveChargesFromAIMSOUT();}

      // Enforce ASR (Acoustic sum rules)
      symmetrizeBornEffectiveChargeTensors();

      // Parser epsilon from OUTCAR
      if(_kbinFlags.AFLOW_MODE_VASP){readDielectricTensorFromOUTCAR();}
      if(_kbinFlags.AFLOW_MODE_AIMS){readDielectricTensorFromAIMSOUT();}

      //
      _logger << "Dielectric tensor: ";
      for (int a = 1; a <= 3; a++)
        for (int b = 1; b <= 3; b++)
          _logger << sf("%5.3f") << _dielectricTensor(a, b) << " ";
      _logger << apl::endl;

      // precompute
      _inverseDielectricTensor = inverse(_dielectricTensor);
      _recsqrtDielectricTensorDeterminant = 1.0 / sqrt(determinant(_dielectricTensor));

      // Pack/Remove the whole directory...
      // COREY CHECK THIS
      if (DOtar) {
        if (!aurostd::FileExist(tarfilename)) {
	  aurostd::execute(string("tar -cf ") + tarfilename + " " + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_ + "/");
	  aurostd::CompressFile(tarfilename,_kbinFlags.KZIP_BIN);
	}
        if (aurostd::FileExist(tarfilename)) aurostd::execute(string("rm -rf ") + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_ + "/");
      }
    } catch (APLLogicError& e) {
      _logger << apl::error << e.what() << apl::endl;
      _logger << warning << "Switching the dipole-dipole correction off." << apl::endl;
      _isPolarMaterial = false;
    } catch (APLStageBreak& e) {
      halfStageBreak = true;
    }
  }

  // if tarred and compressed directory exists...
  string tarfilename = string(_AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_) + ".tar.bz2";
  if (aurostd::FileExist(tarfilename)) {
    // We will extract only what we need DYNMAT and LOCK...
    aurostd::execute(string("tar -xf ") + tarfilename +
                     " --wildcards "
                     " " +
                     _AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_ + "/DYNMAT*" +
                     " " + _AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_ + "/" + _AFLOWLOCK_);  //CO
  }

  // Call VASP to calculate forces by LR
  runVASPCalculationsFF();

  // Get forces from the DYNMAT file generated by VASP
  readForceFieldsFromDYNMAT();

  // Pack/Remove the whole directory...
  if (DOtar)
    if (!aurostd::FileExist(tarfilename)) aurostd::execute(string("tar -cjf ") + tarfilename + " " + _AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_ + "/");
  if (DOtar)
    if (aurostd::FileExist(tarfilename)) aurostd::execute(string("rm -rf ") + _AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_ + "/");

  // It can happen the forcefields are computed, but the born effective charges not...
  if (halfStageBreak) throw APLStageBreak();

  // Print some information
  int dof = 0;
  for (uint i = 0; i < _uniqueDistortions.size(); i++)
    dof += _uniqueDistortions[i].size();
  _logger << "Found " << dof << " degree(s) of freedom." << apl::endl;
  for (int i = 0; i < _supercell.getNumberOfUniqueAtoms(); i++) {
    int id = _supercell.getUniqueAtomID(i);
    for (uint j = 0; j < _uniqueDistortions[i].size(); j++) {
      _logger << "Atom [" << sf("%03d") << id << "] (" << sf("%f")
              << sw(2) << _supercell.getSupercellStructure().atoms[id].cleanname
              << ") has been distorted in direction ["
              << sf("%5.3f") << _uniqueDistortions[i][j](1) << ","
              << sf("%5.3f") << _uniqueDistortions[i][j](2) << ","
              << sf("%5.3f") << _uniqueDistortions[i][j](3) << "]." << apl::endl;
    }
  }
}

//////////////////////////////////////////////////////////////////////////////
// We will used VASP5.2+ to calculate Born effective charge tensors and
// dielectric constant matrix in primitive cell with very high precision
// Both values are needed by non-analytical term of dynamic matrix for
// correct TO-LO splitting of optical phonon branches of polar systems

void PhononCalculator::runVASPCalculationsBE(void) {
  // Our run;
  _xinput xInput(_xInput); //_xvasp vaspRun(_vaspRun);

  // Create run id name
  string runname = string(_AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_);

  // Setup working directory
  xInput.setDirectory( _xInput.getDirectory() + runname );

  // Generate POSCAR
  xInput.setXStr(_supercell.getInputStructure());

  // If there is already a LOCK file, it means this directory was already generated
  // and computed, hence do not touch and leave, but store this structure in the
  // list, hence it will be used in next part of code.
  if (aurostd::FileExist(xInput.getDirectory() + string("/") + _AFLOWLOCK_)) return;  //CO
                                                                                  // If not, continue in this way, prepare generation of _AFLOWLIN ...
  _logger << "Creating " << xInput.getDirectory() << apl::endl;                       //CO

  if(xInput.AFLOW_MODE_VASP){
  // Common KPOINTS settings with PRIORITIES
    xInput.xvasp.AVASP_KSCHEME = _xFlags.vflags.KBIN_VASP_KPOINTS_KSCHEME.content_string;
    if (_xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.isentry) {
      xInput.xvasp.AVASP_KSCHEME = _xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.content_string;
  }
    //xInput.xvasp.AVASP_value_KPPRA = _xFlags.vflags.KBIN_VASP_KPOINTS_KPPRA.content_int;
    xInput.xvasp.AVASP_value_KPPRA = 10000;  // JJPR Modification: Dielectric tensor and Born charges require a very dense q-point mesh.
    if (_xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.isentry) {
      xInput.xvasp.AVASP_value_KPPRA = _xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.content_uint;
  }
  // [OBSOLETE]  xInput.xvasp.AVASP_KSCHEME = _xFlags.vflags.KBIN_VASP_KPOINTS_KSCHEME.content_string;
  // [OBSOLETE]  xInput.xvasp.AVASP_value_KPPRA = _xFlags.vflags.KBIN_VASP_KPOINTS_KPPRA.content_int;

#ifdef AFLOW_APL_VASP_USE_LCALCEPS
    xInput.xvasp.AVASP_KSCHEME = "GAMMA    // forced by  AFLOW_APL_VASP_USE_LCALCEPS";
#endif
  // Switch off autotune, because....
  _kbinFlags.KBIN_MPI_AUTOTUNE = false;

  // Clear old INCAR and set it as we want...
    xInput.xvasp.INCAR.str(std::string());
  string system;
    for (uint i = 0; i < xInput.getXStr().species.size(); i++)
      system = system + xInput.getXStr().species_pp.at(i);
  system = system + "@" + runname;
    xInput.xvasp.INCAR << "SYSTEM=" << system << std::endl;
    //    xInput.xvasp.INCAR << std::endl;
    xInput.xvasp.INCAR << "# Added by [AFLOW_APL] begin" << std::endl;
    xInput.xvasp.INCAR << "ADDGRID=.TRUE.   # For finer forces" << std::endl;
#ifdef AFLOW_APL_VASP_USE_LEPSILON
    xInput.xvasp.INCAR << "IBRION=8         # Linear Response method (needs VASP 5.2 or higher)" << std::endl;
    xInput.xvasp.INCAR << "LEPSILON=.TRUE.  # Calculate Born effective charges and dielectric constants" << std::endl;
#endif
#ifdef AFLOW_APL_VASP_USE_LCALCEPS
    xInput.xvasp.INCAR << "LCALCEPS=.TRUE.  # Calculate Born effective charges and dielectric constants" << std::endl;
    xInput.xvasp.INCAR << "### not necessary EFIELD_PEAD= 0.001 0.001 0.001   # ten times smaller than the default" << std::endl;
#endif
    xInput.xvasp.INCAR << "# Added by [AFLOW_APL] end" << std::endl;

  // For this we need VASP5
    xInput.getXStr().is_vasp4_poscar_format = false;
    xInput.getXStr().is_vasp5_poscar_format = true;
  }

  if(xInput.AFLOW_MODE_AIMS){
    xInput.xaims.CONTROL.str(std::string());
    KBIN::AIMS_Produce_CONTROL(xInput.xaims,_AflowIn,_logger.getOutputStream(),_aflowFlags,_kbinFlags,_xFlags.aimsflags);  //DEFAULT
    KBIN::AIMS_Modify_CONTROL(xInput.xaims,_logger.getOutputStream(),_aflowFlags,_kbinFlags,_xFlags.aimsflags);            //DEFAULT
  }

  // Create _AFLOWIN_
  writeOUTPUT(xInput);
}

//////////////////////////////////////////////////////////////////////////////
void LinearResponsePC::runVASPCalculationsFF() {
  // Our run;
  _xinput xInput(_xInput); //_xvasp vaspRun(_vaspRun);

  // Create run id name
  string runname = string(_AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_);

  // Setup working directory
  xInput.setDirectory( _xInput.getDirectory() + runname );

  // Generate POSCAR
  xInput.setXStr(_supercell.getSupercellStructureLight());

  // If there is already a LOCK file, it means this directory was already generated
  // and computed, hence do not touch and leave, but store this structure in the
  // list, hence it will be used in next part of code.
  if (aurostd::FileExist(xInput.getDirectory() + string("/") + _AFLOWLOCK_)) return;
  // If not, continue in this way, prepare generation of _AFLOWLIN ...

  _logger << "Creating " << xInput.getDirectory() << apl::endl;

  if(xInput.AFLOW_MODE_VASP){
  // Common KPOINTS settings with PRIORITIES
    xInput.xvasp.AVASP_KSCHEME = _xFlags.vflags.KBIN_VASP_KPOINTS_KSCHEME.content_string;
    if (_xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.isentry)
      xInput.xvasp.AVASP_KSCHEME = _xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.content_string;
    xInput.xvasp.AVASP_value_KPPRA = _xFlags.vflags.KBIN_VASP_KPOINTS_KPPRA.content_int;
    if (_xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.isentry)
      xInput.xvasp.AVASP_value_KPPRA = _xFlags.vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.content_uint;
    // [OBSOLETE]  xInput.xvasp.AVASP_KSCHEME = _xFlags.vflags.KBIN_VASP_KPOINTS_KSCHEME.content_string;
    // [OBSOLETE]  xInput.xvasp.AVASP_value_KPPRA = _xFlags.vflags.KBIN_VASP_KPOINTS_KPPRA.content_int;

  // Switch off autotune, because....
  _kbinFlags.KBIN_MPI_AUTOTUNE = false;

  // Clear old INCAR and set it as we want...
    xInput.xvasp.INCAR.str(std::string());
  string system;
    for (uint i = 0; i < xInput.getXStr().species.size(); i++)
      system = system + xInput.getXStr().species_pp.at(i);
  system = system + "@" + runname;
    xInput.xvasp.INCAR << "SYSTEM=" << system << std::endl;
    xInput.xvasp.INCAR << std::endl;
    xInput.xvasp.INCAR << "# Added by [AFLOW_APL] begin" << std::endl;
    xInput.xvasp.INCAR << "NELMIN=4         # The forces have to be well converged" << std::endl;
    xInput.xvasp.INCAR << "NELM = 120       # Many electronic steps (SC2013)" << std::endl;
    xInput.xvasp.INCAR << "ADDGRID=.TRUE.   # For finer forces" << std::endl;
    xInput.xvasp.INCAR << "IBRION=8         # Linear Response method (needs VASP 5.2 or higher)" << std::endl;
    xInput.xvasp.INCAR << "# Added by [AFLOW_APL] end" << std::endl;

  // For this we need VASP5
    xInput.getXStr().is_vasp4_poscar_format = false;
    xInput.getXStr().is_vasp5_poscar_format = true;
  }

  if(xInput.AFLOW_MODE_AIMS){
    xInput.xaims.CONTROL.str(std::string());
    KBIN::AIMS_Produce_CONTROL(xInput.xaims,_AflowIn,_logger.getOutputStream(),_aflowFlags,_kbinFlags,_xFlags.aimsflags);  //DEFAULT
    KBIN::AIMS_Modify_CONTROL(xInput.xaims,_logger.getOutputStream(),_aflowFlags,_kbinFlags,_xFlags.aimsflags);            //DEFAULT
  }

  // Create _AFLOWIN_
  writeOUTPUT(xInput);
}

//////////////////////////////////////////////////////////////////////////////
void PhononCalculator::readBornEffectiveChargesFromAIMSOUT(void) {
  string directory = string("./") + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_;
  string infilename = directory + string("/aims.out");

  if (!aurostd::EFileExist(infilename, infilename)) {
    //_logger << apl::warning << "The aims.out file in " << directory << " directory is missing." << apl::endl;
    //throw APLLogicError("apl::LinearResponsePC::readBornEffectiveChargesFromAIMSOUT(); Missing data from one job.");
    throw APLStageBreak();
  }

  throw APLLogicError("apl::LinearResponsePC::readBornEffectiveChargesFromAIMSOUT(); This functionality has yet to be implemented.");
}
//////////////////////////////////////////////////////////////////////////////
void PhononCalculator::readBornEffectiveChargesFromOUTCAR(void) {
  string directory = string("./") + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_;

  //if (!aurostd::FileExist(directory + string("/") + _AFLOWLOCK_))  //CO
  //  throw APLStageBreak();

  //CO - START
  string infilename = directory + string("/OUTCAR.static");

  if (!aurostd::EFileExist(infilename, infilename)) {
    infilename = directory + string("/OUTCAR");
    if (!aurostd::EFileExist(infilename, infilename)) {
      //_logger << apl::warning << "The OUTCAR file in " << directory << " directory is missing." << apl::endl;
      //throw APLLogicError("apl::LinearResponsePC::readBornEffectiveChargesFromOUTCAR(); Missing data from one job.");
      throw APLStageBreak();
    }
  }

  // Open our file
  //CO - START
  vector<string> vlines;
  aurostd::efile2vectorstring(infilename, vlines);
  if (!vlines.size()) {
    //CO - END
    throw apl::APLLogicError("apl::LinearResponsePC::readBornEffectiveChargesFromOUTCAR(); Cannot open input OUTCAR.static file.");
  }

  string line;
  uint line_count = 0;  //CO
#ifdef AFLOW_APL_VASP_USE_LEPSILON
  // Find with LEPSILON
  const string KEY = string("BORN EFFECTIVE CHARGES (in e, cummulative output)");
#endif
#ifdef AFLOW_APL_VASP_USE_LCALCEPS
  // Find with LCALCEPS
  const string KEY = string("BORN EFFECTIVE CHARGES (including local field effects)");
#endif
  while (true) {
    // Get line
    //CO - START
    //getline(infile,line);
    //if( infile.eof() ) {
    if (line_count == vlines.size()) {
      //CO - END
      throw apl::APLLogicError("apl::LinearResponsePC::readBornEffectiveChargesFromOUTCAR(); No information about Born effective charges in OUTCAR.");
    }
    line = vlines[line_count++];  //CO

    // Check for our key line
    if (line.size() < KEY.size()) continue;
    if (line.find(KEY) != string::npos) break;
  }
  // Read in all ...
  xmatrix<double> m(3, 3);
  vector<string> tokens;
  //CO - START
  //getline(infile,line); // Skip line "----------------...."
  line = vlines[line_count++];
  for (uint i = 0; i < _supercell.getInputStructure().atoms.size(); i++) {
    // Get atom ID but not use it...
    //getline(infile,line);
    line = vlines[line_count++];
    //tokenize(line,tokens,string(" "));
    //auto int id = aurostd::string2utype<int>(tokens.at(1)) - 1;
    //if( id != _supercell.getInputStructure().iatoms[i][0] ) continue;
    //tokens.clear();

    // Get its charge tensor
    for (int j = 1; j <= 3; j++) {
      //getline(infile,line);
      line = vlines[line_count++];
      tokenize(line, tokens, string(" "));
      m(j, 1) = aurostd::string2utype<double>(tokens.at(1));
      m(j, 2) = aurostd::string2utype<double>(tokens.at(2));
      m(j, 3) = aurostd::string2utype<double>(tokens.at(3));
      tokens.clear();
    }

    // Store it
    _bornEffectiveChargeTensor.push_back(m);
  }

  // Clear used stuff
  //infile.clear();
  //infile.close();
  //CO - END
}

//////////////////////////////////////////////////////////////////////////////
void PhononCalculator::symmetrizeBornEffectiveChargeTensors(void) {
  //CO - START
  // Test of stupidity...
  if (_supercell.getEPS() == AUROSTD_NAN) {
    throw APLRuntimeError("apl::PhononCalculator::buildForceConstantMatrices(); Need to define symmetry tolerance.");
  }
  //CO - END
  // Show charges
  _logger << "Input born effective charge tensors (for primitive cell):" << apl::endl;
  for (uint i = 0; i < _bornEffectiveChargeTensor.size(); i++) {
    int id = i;
    _logger << "Atom [" << sf("%03d") << id << "] (" << sf("%f")
            << sw(2) << _supercell.getInputStructure().atoms[id].cleanname
            << ") Born effective charge = ";
    for (int a = 1; a <= 3; a++)
      for (int b = 1; b <= 3; b++)
        _logger << sf("%+5.3f") << _bornEffectiveChargeTensor[i](a, b) << " ";
    _logger << apl::endl;
  }
  _logger << sf("%f");

  //_logger << "Symmetrization of born effective charge tensors (1)." << apl::endl;

  // Step1
  for (int i = 0; i < _supercell.getNumberOfUniqueAtoms(); i++) {
    // Get the number of this atom in the whole list
    int basedUniqueAtomID = _supercell.getUniqueAtomID(i);

    xmatrix<double> sum(3, 3);
    for (int j = 0; j < _supercell.getNumberOfUniqueAtomsOfType(i); j++) {
      try {  //CO
        const _sym_op& symOp = _supercell.getSymOpWhichMatchAtoms(_supercell.getUniqueAtomID(i, j), basedUniqueAtomID, _FGROUP_);
        sum += inverse(symOp.Uc) * _bornEffectiveChargeTensor[_supercell.sc2pcMap(_supercell.getUniqueAtomID(i, j))] * symOp.Uc;
      }
      //CO - START
      catch (APLLogicError& e) {
        _logger << error << "Mapping problem " << _supercell.getUniqueAtomID(i, j) << " <-> " << basedUniqueAtomID << "?" << apl::endl;
        throw APLLogicError("apl::PhononCalculator::symmetrizeBornEffectiveChargeTensors(); Mapping failed.");
      }
      //CO - END
    }

    sum = (1.0 / _supercell.getNumberOfUniqueAtomsOfType(i)) * sum;

    for (int j = 0; j < _supercell.getNumberOfUniqueAtomsOfType(i); j++)
      _bornEffectiveChargeTensor[_supercell.sc2pcMap(_supercell.getUniqueAtomID(i, j))] = sum;
  }

  //_logger << "Symmetrization of born effective charge tensors (2)." << apl::endl;

  // Step2
  vector<xmatrix<double> > newbe = _bornEffectiveChargeTensor;
  const vector<vector<_sym_op> >& agroup = _supercell.getAGROUP();  //CO
  for (int i = 0; i < _supercell.getNumberOfAtoms(); i++) {
    // Translate the center to this atom
    _supercell.center(i);

    xmatrix<double> sum(3, 3);
    for (uint symOpID = 0; symOpID < agroup[i].size(); symOpID++) {
      const _sym_op& symOp = agroup[i][symOpID];
      sum = sum + (inverse(symOp.Uc) * _bornEffectiveChargeTensor[_supercell.sc2pcMap(i)] * symOp.Uc);
    }
    newbe[_supercell.sc2pcMap(i)] = (1.0 / agroup[i].size()) * sum;
    // Translate the center back
    //_supercell.center_original(); //CO
  }
  // Translate the center back
  //_supercell.center(0);
  _supercell.center_original();  //CO

  _bornEffectiveChargeTensor.clear();
  _bornEffectiveChargeTensor = newbe;
  newbe.clear();

  // Step 3
  _logger << "Forcing the acoustic sum rule (ASR). Resulted born effective charges (for supercell):" << apl::endl;

  xmatrix<double> sum(3, 3);
  for (uint i = 0; i < _bornEffectiveChargeTensor.size(); i++)
    sum += _bornEffectiveChargeTensor[i];
  sum = (1.0 / _bornEffectiveChargeTensor.size()) * sum;
  for (uint i = 0; i < _bornEffectiveChargeTensor.size(); i++)
    _bornEffectiveChargeTensor[i] -= sum;

  // Make list only for unique atoms
  for (int i = 0; i < _supercell.getNumberOfUniqueAtoms(); i++)
    newbe.push_back(_bornEffectiveChargeTensor[_supercell.sc2pcMap(_supercell.getUniqueAtomID(i))]);
  _bornEffectiveChargeTensor.clear();
  _bornEffectiveChargeTensor = newbe;
  newbe.clear();

  // Show charges
  for (int i = 0; i < _supercell.getNumberOfUniqueAtoms(); i++) {
    int id = _supercell.getUniqueAtomID(i);
    _logger << "Atom [" << sf("%03d") << id << "] (" << sf("%f")
            << sw(2) << _supercell.getSupercellStructure().atoms[id].cleanname
            << ") Born effective charge = ";
    for (int a = 1; a <= 3; a++)
      for (int b = 1; b <= 3; b++)
        _logger << sf("%+5.3f") << _bornEffectiveChargeTensor[i](a, b) << " ";
    _logger << apl::endl;
  }
  _logger << sf("%f");
}

//////////////////////////////////////////////////////////////////////////////
void PhononCalculator::readDielectricTensorFromAIMSOUT(void) {
  string directory = string("./") + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_;

  //CO - START
  string infilename = directory + string("/aims.out");
  if (!aurostd::EFileExist(infilename, infilename)) {
    //_logger << apl::warning << "The OUTCAR file in " << directory << " directory is missing." << apl::endl;
    //throw APLLogicError("apl::LinearResponsePC::readDielectricTensorFromOUTCAR(); Missing data from one job.");
    throw APLStageBreak();
  }
  throw APLLogicError("apl::LinearResponsePC::readDielectricTensorFromAIMSOUT(); This functionality has yet to be implemented.");
}
//////////////////////////////////////////////////////////////////////////////
void PhononCalculator::readDielectricTensorFromOUTCAR(void) {
  string directory = string("./") + _AFLOW_APL_BORN_EPSILON_DIRECTORY_NAME_;

  //if (!aurostd::FileExist(directory + string("/") + _AFLOWLOCK_))  //CO
  //  throw APLStageBreak();

  //CO - START
  string infilename = directory + string("/OUTCAR.static");
  if (!aurostd::EFileExist(infilename, infilename)) {
    infilename = directory + string("/OUTCAR");
    if (!aurostd::EFileExist(infilename, infilename)) {
      //_logger << apl::warning << "The OUTCAR file in " << directory << " directory is missing." << apl::endl;
      //throw APLLogicError("apl::LinearResponsePC::readDielectricTensorFromOUTCAR(); Missing data from one job.");
      throw APLStageBreak();
    }
  }

  // Open our file
  vector<string> vlines;
  uint line_count = 0;
  string line;
  aurostd::efile2vectorstring(infilename, vlines);
  if (!vlines.size()) {
    throw apl::APLLogicError("LinearResponsePC::readDielectricTensorFromOUTCAR(); Cannot open input OUTCAR file.");
  }
//CO - END

// Find
#ifdef AFLOW_APL_VASP_USE_LEPSILON
  const string KEY = string("MACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects in DFT)");
#endif
#ifdef AFLOW_APL_VASP_USE_LCALCEPS
  const string KEY = string("MACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects)");
#endif

  while (true) {
    // Get line
    //CO - START
    //getline(infile,line);
    //if( infile.eof() )
    if (line_count == vlines.size()) {
      throw apl::APLLogicError("LinearResponsePC::readDielectricTensorFromOUTCAR(); No information about dielectric tensor in OUTCAR.");
    }
    line = vlines[line_count++];
    //CO - END

    // Check for our key line
    if (line.size() < KEY.size()) continue;
    if (line.find(KEY) != string::npos) break;
  }

  // Read in all ...
  //CO - START
  //getline(infile,line); // Skip line "----------------...."
  line = vlines[line_count++];

  // Get it
  vector<string> tokens;
  for (int j = 1; j <= 3; j++) {
    //getline(infile,line);
    line = vlines[line_count++];
    tokenize(line, tokens, string(" "));
    _dielectricTensor(j, 1) = aurostd::string2utype<double>(tokens.at(0));
    _dielectricTensor(j, 2) = aurostd::string2utype<double>(tokens.at(1));
    _dielectricTensor(j, 3) = aurostd::string2utype<double>(tokens.at(2));
    tokens.clear();
  }

  //???MACROSCOPIC STATIC DIELECTRIC TENSOR IONIC CONTRIBUTION
  /*
      const string KEY2 = string("MACROSCOPIC STATIC DIELECTRIC TENSOR IONIC CONTRIBUTION");
      while( true ) {
      // Get line
      //getline(infile,line);
      line=vlines[line_count++];
      //if( infile.eof() )
      if( line_count==vlines.size() ) {
      {
      throw apl::APLLogicError("LinearResponsePC::readDielectricTensorFromOUTCAR(); No information about dielectric tensor in OUTCAR.");
      }

      // Check for our key line
      if( line.size() < KEY2.size() ) continue;
      if( line.find(KEY2) != string::npos ) break;
      }

      // Read in all ...
      //getline(infile,line); // Skip line "----------------...."
      line=vlines[line_count++];

      // Get it
      for(int j = 1; j <= 3; j++) {
      //getline(infile,line);
      line=vlines[line_count++];
      tokenize(line,tokens,string(" "));
      _dielectricTensor(j,1) -= aurostd::string2utype<double>(tokens.at(0));
      _dielectricTensor(j,2) -= aurostd::string2utype<double>(tokens.at(1));
      _dielectricTensor(j,3) -= aurostd::string2utype<double>(tokens.at(2));
      tokens.clear();
      }
    */
  // Clear used stuff
  //infile.clear();
  //infile.close();
  //CO - END

  // Symmetrize
  /*
      const vector<_sym_op>& pgroup = _supercell.getSupercellStructure().pgroup;
      xmatrix<double> sum(3,3);
      for(uint symOpID = 0; symOpID < pgroup.size(); symOpID++) {
      const _sym_op& symOp = pgroup[symOpID];
      sum = sum + ( inverse(symOp.Uc) * _dielectricTensor * symOp.Uc );
      }
      _dielectricTensor = ( 1.0 / pgroup.size() ) * sum;
    */
}

//////////////////////////////////////////////////////////////////////////////
void LinearResponsePC::readForceFieldsFromDYNMAT() {
  string directory = string("./") + _AFLOW_APL_FORCEFIELDS_DIRECTORY_NAME_;

  //if (!aurostd::FileExist(directory + string("/") + _AFLOWLOCK_))  //CO
  //  throw APLStageBreak();

  string infilename = directory + string("/DYNMAT");
  if (!aurostd::EFileExist(infilename, infilename)) {  //CO
    infilename = directory + string("/DYNMAT.static");
    if (!aurostd::EFileExist(infilename, infilename))  //CO
    {
      _logger << apl::warning << "The DYNMAT file in " << directory << " directory is missing." << apl::endl;
      throw APLLogicError("apl::LinearResponsePC::readForceFieldsFromDYNMAT(); Missing data from one job.");
    }
  }

  // Clear old lists
  clear();

  // Open our file
  //CO - START
  vector<string> vlines;
  aurostd::efile2vectorstring(infilename, vlines);
  //ifstream infile(infilename.c_str());
  //if( !infile.is_open() ) {
  if (!vlines.size()) {
    throw apl::APLRuntimeError("LinearResponsePC::readForceFieldsFromDYNMAT(); Cannot open input DYNMAT file.");
  }

  // Header
  vector<int> values;
  uint line_count = 0;
  aurostd::string2tokens<int>(vlines[line_count++], values);
  //int ntypes=values[0]; //not used
  //int ntypes;
  //infile >> ntypes;

  int natoms = values[1];
  int nfree = values[2];
  //int natoms;
  //infile >> natoms;
  //int nfree;
  //infile >> nfree;
  //for(int i = 0; i < ntypes; i++) {
  //  double dtemp;
  //  infile >> dtemp;
  //}
  line_count++;
  //CO - END

  // Get forces
  vector<xvector<double> > distortionsOfOneAtom;
  vector<vector<xvector<double> > > forceFieldsOfOneAtom;
  int old_atom_id = 0;
  aurostd::string2tokens<int>(vlines[line_count++], values);  //CO
  for (int i = 0; i < nfree; i++) {
    int atom_id = values[0];  //CO
    //int atom_id;  //CO
    //infile >> atom_id;  //CO
    if (i == 0) old_atom_id = atom_id;

    //if(infile.eof()) break; //CO
    if (line_count == vlines.size()) break;  //CO

    // Distortion ID
    //CO - START
    //int idir=values[1]; //not used
    //int idir;
    //infile >> idir;

    // Distortion vector
    xvector<double> distortion(3);
    distortion(1) = values[2];
    distortion(2) = values[3];
    distortion(3) = values[4];
    //infile >> distortion(1);
    //infile >> distortion(2);
    //infile >> distortion(3);
    //CO - END
    double distortionLength = aurostd::modulus(distortion);
    DISTORTION_MAGNITUDE = distortionLength;
    distortion(1) = distortion(1) / distortionLength;
    distortion(2) = distortion(2) / distortionLength;
    distortion(3) = distortion(3) / distortionLength;

    // Get forces and calculate drift
    vector<xvector<double> > qm_forces;
    xvector<double> force(3);
    xvector<double> drift(3);
    for (int k = 0; k < natoms; k++) {
      //CO - START
      aurostd::string2tokens(vlines[line_count++], values);
      force(1) = values[0];
      force(2) = values[1];
      force(3) = values[2];
      //infile >> force(1);
      //infile >> force(2);
      //infile >> force(3);
      //CO - END
      qm_forces.push_back(force);
      drift = drift + force;
    }
    drift(1) = drift(1) / natoms;
    drift(2) = drift(2) / natoms;
    drift(3) = drift(3) / natoms;
    for (int k = 0; k < natoms; k++)
      qm_forces[k] = qm_forces[k] - drift;

    // Finish this atoms list and stasrt new one
    if (atom_id != old_atom_id) {
      _uniqueForces.push_back(forceFieldsOfOneAtom);
      _uniqueDistortions.push_back(distortionsOfOneAtom);
      old_atom_id = atom_id;
      for (uint i = 0; i < distortionsOfOneAtom.size(); i++)
        distortionsOfOneAtom[i].clear();
      distortionsOfOneAtom.clear();
      for (uint i = 0; i < forceFieldsOfOneAtom.size(); i++)
        forceFieldsOfOneAtom[i].clear();
      forceFieldsOfOneAtom.clear();
    }

    // Store distortions and forces
    distortionsOfOneAtom.push_back(distortion);
    forceFieldsOfOneAtom.push_back(qm_forces);

    // Final store ....
    if (i == nfree - 1) {
      _uniqueForces.push_back(forceFieldsOfOneAtom);
      _uniqueDistortions.push_back(distortionsOfOneAtom);
      for (uint i = 0; i < distortionsOfOneAtom.size(); i++)
        distortionsOfOneAtom[i].clear();
      distortionsOfOneAtom.clear();
      for (uint i = 0; i < forceFieldsOfOneAtom.size(); i++)
        forceFieldsOfOneAtom[i].clear();
      forceFieldsOfOneAtom.clear();
    }
  }

  // Clear used stuff
  //infile.clear(); //CO
  //infile.close(); //CO
}

//////////////////////////////////////////////////////////////////////////////

}  // namespace apl
